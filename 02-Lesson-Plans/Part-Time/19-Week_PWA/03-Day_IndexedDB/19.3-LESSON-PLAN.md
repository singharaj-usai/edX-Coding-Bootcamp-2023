# 19.3 Weekday Lesson Plan: IndexedDB and PWAs

## Overview

In today's class, students will have a chance to learn about a low-level API called IndexedDB, which lets us store large amounts of data on the client side. We have used `localStorage` in the past for client-side storage, but we were very limited in the amount and type of data we could store. IndexedDB can help us store more data in more complex data structures.

## Instructor Notes

* In this lesson, students will complete activities `21-Ins_IndexedDB` through `28-Stu_Mini-Project`.

* All of the activities besides the `28-Stu_Mini-Project` solely use a front end. The `28-Stu_Mini-Project` requires a back end for us to successfully deploy the project to Heroku.

* We are dealing with client and web caching, so make sure to clear your cache before each activity or take advantage of the [incognito window in Google Chrome](https://support.google.com/chrome/answer/95464?hl=en&co=GENIE.Platform%3DDesktop#:~:text=You%20can%20also%20use%20a,Press%20%E2%8C%98%20%2B%20Shift%20%2B%20n.).

* Some of these activities rely on a browser response. If you are not seeing the intended results, please close your browser entirely and restart to begin a new browser session. This will often clear any issues.

* When demoing the activities, please use `Live Server` to open the `index.html` file from the `dist` directory, unless specified otherwise. If you have not yet downloaded Live Server for VS Code, refer to these [instructions for downloading Live Server](https://marketplace.visualstudio.com/items?itemName=ritwickdey.LiveServer).

* PWAs and IndexedDB can be frustrating at times, so take some time to familiarize yourself with the behavior of each activity. This is also a good opportunity for students to practice troubleshooting unexpected behaviors in their application.

* Remind students to do a `git pull` of the class repo and to have today's activities ready and open in VS Code.

* If you are comfortable doing so, live code the solutions to the activities. If not, just use the solutions provided and follow the prompts and talking points for review.

* Let students know that the Bonus at the end of each activity is not meant to be extra coding practice, but instead is a self-study on topics beyond the scope of this module for those who want to further their knowledge.

* If the students struggle with the "Everyone Do: Git" activity, walk through it using the talking points provided. Otherwise, support the students as they do the activity and give a brief review at the end.

## Learning Objectives

By the end of class, students will be able to:

* Implement IndexedDB inside a JavaScript application.

* Implement CREATE, READ, UPDATE, and DELETE commands for an IndexedDB instance.

* Convert an existing application into a Progressive Web Application (PWA).

* Deploy a PWA to Heroku.

## Time Tracker

| Start  | #   | Activity Name                      | Duration |
| ------ | --- | ---------------------------------- | -------- |
| 0:00   | 1   | Instructor Do: Stoke Curiosity     | 0:05     |
| 0:05   | 2   | Instructor Demo: IndexedDB         | 0:05     |
| 0:10   | 3   | Student Do: IndexedDB              | 0:15     |
| 0:25   | 4   | Instructor Review: IndexedDB       | 0:10     |
| 0:35   | 5   | Instructor Demo: IndexedDB CRUD    | 0:05     |
| 0:40   | 6   | Student Do: IndexedDB CRUD         | 0:15     |
| 0:55   | 7   | Instructor Review: IndexedDB CRUD  | 0:10     |
| 1:05   | 8   | Instructor Demo: Manifest          | 0:05     |
| 1:10   | 9   | Student Do: Manifest               | 0:15     |
| 1:25   | 10  | BREAK                              | 0:10     |
| 1:35   | 11  | Instructor Review: Manifest        | 0:10     |
| 1:45   | 12  | Everyone Do: Git                   | 0:10     |
| 1:55   | 13  | Instructor Demo: Mini-Project      | 0:05     |
| 2:00   | 14  | Student Do: Mini-Project           | 0:45     |
| 2:45   | 15  | Instructor Review: Mini-Project    | 0:10     |
| 2:55   | 16  | Introduce Challenge                | 0:05     |
| 3:00   | 17  | END                                | 0:00     |

---

## Class Instruction

### 1. Instructor Do: Stoke Curiosity (5 min)

* Welcome students to class.

* Congratulate the class on learning how to implement new web technologies such as webpack and workbox. These tools can give our applications a performance boost and improve the user experience.

* Remind students that the React module is on the horizon and that much of what they've learned in this module can be applied to learning React.

* Today's class will be focused on making our application installable on users' devices!

* The web applications we create can be configured to act like a native application.

* Ask the class the following questions (☝️) and call on students for the answers (🙋):

  * ☝️ What are some examples of native applications?

  * 🙋 Microsoft Word, Zoom . . . basically, any application that you need to install.

  * ☝️ What are some benefits of a native application?

  * 🙋 Native applications don't require an internet connection and desktop icon to work.

* We also will be taking a look at a new API called IndexedDB which will unlock a more advanced front-end data storage option.

* Ask the class the following questions (☝️) and call on students for the answers (🙋):

  * ☝️ How have we stored data on the front end in the past?

  * 🙋 Local storage!

* We will be able to run CRUD operations and process data much more efficiently with IndexedDB versus local storage.

* Answer any questions before proceeding to the next activity.

### 2. Instructor Demo: IndexedDB (5 min)

* Open `21-Ins_IndexedDB/assets/js/database.js` in your IDE and explain the following:

  * 🔑 We have to install the `idb` package as a regular dependency and import it into the `database.js` file.

    ```js
    import { openDB } from 'idb';
    ```

  * The `idb` package is a lightweight wrapper that takes care of some of the more messy parts of IndexedDB. The main reason we are using the `idb` package is that it allows us to take advantage of async/await.

  * We have created an asynchronous function called `initDB()`, which will immediately invoke the `OpenDB` method we imported earlier.

    ```js
    const initdb = async () =>
      openDB('demo-db', 1, {
    });
    ```

  * 🔑 The first argument is the name of the database we want, which is `demo-db`, followed by the version number.

  * The version number allows us to check if our user is using an old version of our schema. This will be our only schema, so we will not have to worry about changing versions.

  * A schema in IndexedDB is basically just a data store.

  * 🔑 Next, we set the correct schema using the `upgrade` method.

     ```js
      const initdb = async () =>
        openDB('demo-db', 1, {
          upgrade(db) {
          if (db.objectStoreNames.contains('demo-db')) {
            console.log('demo-db database already exists');
            return;
          }

          db.createObjectStore('demo-db', { keyPath: 'id', autoIncrement: true });
          console.log('demo-db database created');
        },
    });
    ```

  * 🔑 Check to see if the user already has the `demo-db` object. If not, create a new one called `demo-db` with the `createObjectStore()` method.

  * 🔑 We use the `keyPath` property to specify the name of the key field in the `demo-db` object and set it to auto-increment.

  * Finally, we call the `initDb()` function at the bottom of the `database.js` file.

    ```js
    initDb()
    ```

* Run `npm install` and `npm run start` and open up the `index.html` in the `dist` directory using Live Server.

* Navigate to the Application tab in Chrome DevTools and demonstrate the following:

  * 🔑 In the `IndexedDb` section, if we expand it, we can see the `demo-db` storage object.

  * 🔑 By clicking on the storage object, we can already see the id field even though we have zero records.

* Ask the class the following questions (☝️) and call on students for the answers (🙋):

  * ☝️ How would we build this?

  * 🙋 By using the `OpenDB()` from the `idb` package.

* Answer any questions before proceeding to the next activity.

* In preparation for the activity, ask TAs to start directing students to the activity instructions found in `22-Stu_IndexedDB/README.md`.

### 3. Student Do: IndexedDB (15 min)

* Direct students to the activity instructions found in `22-Stu_IndexedDB/README.md`, which are also shown below.

* Break your students into pairs that will work together on this activity.

  ```md
  # 📐 Add Comments to Implementation of IndexedDB

  Work with a partner to add comments that describe the functionality of the code found in the [database.js](./Unsolved/src/js/database.js) file.

  ## 📝 Notes

  This activity takes place in Chrome DevTools; we will hook up the UI in later activities.

  To launch the application and view the IndexedDB store in Chrome DevTools, follow these steps:

  1. In the command line, navigate to `22-Stu_IndexedDB/Unsolved`.

  2. Run `npm install`.

  3. To launch the application, run `npm run start`.

  4. Open the `index.html` file in the browser from the  `dist` directory.

  5. To view the IndexedDB store, visit the `Application` tab in Chrome DevTools.

  Refer to the documentation:

  * [NPM docs on IndexedDB](https://www.npmjs.com/package/idb)

  * [MDN Web Docs on the IndexedDB API](https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API)

  ---

  ## 🏆 Bonus

  If you have completed this activity, work through the following challenge with your partner to further your knowledge:

  * How does an object store in IndexedDB compare to a table or collection in other databases?

  Use [Google](https://www.google.com) or another search engine to research this.
  ```

* While breaking everyone into groups, be sure to remind students and the rest of the instructional staff that questions on Slack or otherwise are welcome and will be handled. It's a good way for your team to prioritize students who need extra help.

### 4. Instructor Review: IndexedDB (10 min)

* Ask the class the following questions (☝️) and call on students for the answers (🙋):

  * ☝️ How comfortable do you feel with IndexedDB? (Poll via Fist to Five, Slack, or Zoom)

* Assure students that we will cover the solution to help solidify their understanding. If questions remain, remind them to use Office Hours to get extra help.

* Use the prompts and talking points (🔑) below to review the following key points:

  * ✔️ Set up IndexedDB

  * ✔️ Create an object store

  * ✔️ Versions

* Open `22-Stu_IndexedDB/Solved/assets/js/database.js` in your IDE and explain the following:

  * We import in the `idb` package and create an asynchronous  `initDB()` function.

    ```js
    import { openDB } from 'idb';

    const initdb = async () =>
    ```

  * 🔑 The `idb` package allows us to make IndexedDB asynchronous and cleans up a lot of the messy syntax that IndexedDB has.

  * We call the `OpenDB()` method from the `idb` package.

    ```js
    const initdb = async () =>
    openDB('todos', 1, {
      upgrade(db) {
        if (db.objectStoreNames.contains('todos')) {
          console.log('todos database already exists');
          return;
        }

        db.createObjectStore('todos', { keyPath: 'id', autoIncrement: true });
        console.log('todos database created');
      },
    });
    ```

  * 🔑 For the `OpenDB()` method, we pass in the name of our database and the version we want to use.

  * 🔑 Next, we call the `upgrade()` function, which takes our database as an argument. Check to see if the object store already exists in the users' web browser.

  * 🔑 Finally, we create a new object store if one doesn't already exist. The object store will always have an `id keyPath` that auto-increments for us.

* Ask the class the following questions (☝️) and call on students for the answers (🙋):

  * ☝️ What does the `keyPath` do?

  * 🙋 It automatically creates a new key to identify data records that are stored in the database.

  * ☝️ On which tab in Chrome DevTools can we inspect our object store?

  * 🙋 The Application tab under `IndexedDB`.

  * ☝️ What can we do if we don't completely understand this?

  * 🙋 We can refer to supplemental material, read the [MDN Web Docs on IndexedDB](https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API), and attend Office Hours to ask for help.

* Answer any questions before proceeding to the next activity.

### 5. Instructor Demo: IndexedDB CRUD (5 min)

* Open `23-Ins_IndexedDB-CRUD/assets/js/database.js` in your IDE and explain the following:

  * 🔑 To use the IndexedDB object store that we set up, we need to implement a CRUD operation.

  * We create and export an asynchronous function called `postDb()`.

    ```js
    export const postDb = async (content) => {
    };
    ```

  * The `postDb()` function will accept the `content` that we want to store in the database as an argument.

  * Next, we open a transaction with our database.

    ```js
    export const postDb = async (content) => {
      const todosDb = await openDB('todos', 1);

      const tx = todosDb.transaction('todos', 'readwrite');

      const store = tx.objectStore('todos');

      const request = store.add({ todo: content });

      const result = await request;
      console.log('🚀 - data saved to the database', result);
    };
    ```

  * 🔑 We store the connection to our database inside a variable called `todosDb`.

  * 🔑 Next, we create a new `transaction` that expects the database name and privileges. Because we are writing to the database, we need to set the privileges to `readwrite`.

  * 🔑 Create a variable that will hold a reference to the object store.

  * 🔑 Finally, we use the `add()` method that is attached to the object store and pass in the `contents`.

  * Once we have finished writing to the database, we expect a result to confirm the transaction.

  * Let's look at how we can retrieve all the data in the database.

    ```js
    // Export a function we will use to GET all from the database.
    export const getAllDb = async () => {
      // Create a connection to the database database and version we want to use.
      const todosDb = await openDB('todos', 1);

      // Create a new transaction and specify the database and data privileges.
      const tx = todosDb.transaction('todos', 'readonly');

      // Open up the desired object store.
      const store = tx.objectStore('todos');

      // Use the .getAll() method to get all data in the database.
      const request = store.getAll();

      // Get confirmation of the request.
      const result = await request;
      console.log('result.value', result);
      return result;
    };
    ```

  * 🔑 This is similar to earlier, but this time we are using `getAll()` on the object store.

  * Let's look at how we can retrieve a single record in the database.

    ```js
    export const getOneDb = async (id) => {
      console.log('GET from the database');

      // Create a connection to the database and version we want to use.
      const todosDb = await openDB('todos', 1);

      // Create a new transaction and specify the database and data privileges.
      const tx = todosDb.transaction('todos', 'readonly');

      // Open up the desired object store.
      const store = tx.objectStore('todos');

      // Use the .get() method to get a piece of data from the database based on the id.
      const request = store.get(id);

      // Get confirmation of the request.
      const result = await request;
      console.log('result.value', result);
      return result;
    };
    ```

  * 🔑 This is similar to what we did earlier, but this time we are using `get()` on the object store and pass in the `id`.

* Run `npm run dev` and open up the `localhost:8080` to demonstrate the following:

  * Add an item to the TODO list and open the Application tab in Chrome DevTools. Under the `IndexedDB` section, inspect the contents of the object store.

  * 🔑 We see that our data is now being stored and retrieved from the IndexedDB object store.

* Ask the class the following questions (☝️) and call on students for the answers (🙋):

  * ☝️ How would we build this?

  * 🙋 We need to open a transaction with the desired object store, and use it to correct the method on our store.

* Answer any questions before proceeding to the next activity.

* In preparation for the activity, ask TAs to start directing students to the activity instructions found in `24-Stu_IndexedDB-CRUD/README.md`.

### 6. Student Do: IndexedDB CRUD (15 min)

* Direct students to the activity instructions found in `24-Stu_IndexedDB-CRUD/README.md`, which are also shown below.

* Break your students into pairs that will work together on this activity.

  ```md
  # 🐛 The Delete Button Does Not Remove the List Item When Clicked

  Work with a partner to resolve the following issues:

  * As a user, I want to be able to delete a list item from a list when I click on the list item.

  * As a user, I want to be able to edit a list item when I click the Edit button.

  ## Expected Behavior

  When a user clicks on an item, it is removed from the list of tasks.

  When a user clicks on the Edit button, a text input is displayed with the list item to be edited. After pressing the Enter key, the list item is updated accordingly.

  ## Actual Behavior

  When a user clicks on the item, it is noy removed from the list of tasks.

  When a user clicks the Edit button, a text input does not appear with the list item to be edited. After pressing the Enter key, the list item is not updated properly.

  ## Steps to Reproduce the Problem

  To reproduce the problem, follow these steps:

  1. In the command line, navigate to `24-Stu_IndexedDB-CRUD/Unsolved`.

  2. Run `npm install`.

  3. To launch the application, run `npm run dev`.

  4. Navigate to `http://localhost:8080` in your browser.

  5. Create a new To Do item at the bottom of the page.

  6. Click on a list item to attempt to delete it.

  7. Click the Edit button to attempt to edit the list item.

  ## Assets

  The following image demonstrates the web application's appearance and functionality:

  ![Demo of the TODO list by adding, removing, and editing a list item.](./Assets/todo-list.gif)

  ---

  ## 💡 Hints

  What types of permissions do you need to alter data inside a database?

  ## 🏆 Bonus

  If you have completed this activity, work through the following challenge with your partner to further your knowledge:

  * How does the usage of CRUD operations with IndexedDB compare with their usage with SQL databases?

  Use [Google](https://www.google.com) or another search engine to research this.
  ```

* While breaking everyone into groups, be sure to remind students and the rest of the instructional staff that questions on Slack or otherwise are welcome and will be handled. It's a good way for your team to prioritize students who need extra help.

### 7. Instructor Review: IndexedDB CRUD (10 min)

* Ask the class the following questions (☝️) and call on students for the answers (🙋):

  * ☝️ How comfortable do you feel with CRUD in IndexedDB? (Poll via Fist to Five, Slack, or Zoom)

* Assure students that we will cover the solution to help solidify their understanding. If questions remain, remind them to use Office Hours to get extra help.

* Use the prompts and talking points (🔑) below to review the following key points:

  * ✔️ IndexedDB CRUD

  * ✔️ `.delete()`

  * ✔️ `.put()`

* Open `24-Stu_IndexedDB-CRUD/Solved/assets/js/database.js` in your IDE and explain the following:

  * 🔑 Because we are altering a record in the database, we need to use `readwrite` privileges in our transaction.

    ```js
    export const deleteDb = async (id) => {
      console.log('DELETE from the database', id);
      const todosDb = await openDB('todos', 1);
      const tx = todosDb.transaction('todos', 'readwrite');
      const store = tx.objectStore('todos');
      const request = store.delete(id);
      const result = await request;
      console.log('result.value', result);
      return result;
    };
    ```

  * 🔑 We must use the `todos` database in the transaction for the proper data to be updated.

    ```js
    export const putDb = async (id, content) => {
      console.log('PUT to the database');
      const todosDb = await openDB('todos', 1);
      const tx = todosDb.transaction('todos', 'readwrite');
      const store = tx.objectStore('todos');
      const request = store.put({ id: id, todo: content });
      const result = await request;
      console.log('🚀 - data saved to the database', result);
    };
    ```

* Ask the class the following questions (☝️) and call on students for the answers (🙋):

  * ☝️ What is the name of the method to get all of the records in the database?

  * 🙋 `getAll()`

  * ☝️ What can we do if we don't completely understand this?

  * 🙋 We can refer to supplemental material, read the [MDN Web Docs on IndexedDB](https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API), and attend Office Hours to ask for help.

* Answer any questions before proceeding to the next activity.

### 8. Instructor Demo: Manifest (5 min)

* Open `25-Ins_Manifest/manifest.json` in your IDE and explain the following:

  * 🔑 The `manifest.json` file is a JSON file that contains certain metadata about our web application that informs the user's browser or mobile device how to run the application.

  * 🔑 For our web application, we have to provide a `name` property inside the `manifest.json` file.

  * We can optionally provide a `short_name` for our web application.

    ```json
    "short_name": "Manifest",
    "name": "TODOs Manifest Example",
    ```

  * 🔑 Next, we provide our `icons` for all different types of screens.

    ```json
    "icons": [
      {
        "src": "./assets/images/icon_96x96.png",
        "type": "image/png",
        "sizes": "96x96",
        "purpose": "any maskable"
      },
      {
        "src": "./assets/images/icon_128x128.png",
        "type": "image/png",
        "sizes": "128x128",
        "purpose": "any maskable"
      },
      {
        "src": "./assets/images/icon_192x192.png",
        "type": "image/png",
        "sizes": "192x192",
        "purpose": "any maskable"
      },
      {
        "src": "./assets/images/icon_512x512.png",
        "type": "image/png",
        "sizes": "512x512",
        "purpose": "any maskable"
      }
    ],
    ```

  * 🔑 We have to provide an image that is 512px large so that our `manifest.json` file can create a loading screen for our application. We must have this icon for our app to be installable!

  * 🔑 The`orientation` allows us to define which angle our application is viewed in, while the  `display` property allows us to define preferred display mode.

    ```json
    "orientation": "portrait",
    "display": "standalone",
    ```

  * 🔑 Next, we define where we want our applications starting URL.

    ```json
    "start_url": "./",
    ```

  * 🔑 Finally, we give our application a description and some styling for the boarders of our application.

    ```json
    "description": "Keep track of important tasks!",
    "background_color": "#7eb4e2",
    "theme_color": "#7eb4e2"
    ```

* Open `25-Ins_Manifest/assets/js/install.js` in your IDE and explain the following:

  * 🔑 When we launch the application in our browser and our app is installable, we will see an install button inside of the address bar.

  * 🔑 We also can create our own install button, using the following:

    ```js
    const installBtn = document.getElementById('installBtn');
    const textHeader = document.getElementById('textHeader');

    window.addEventListener('beforeinstallprompt', (event) => {
      event.preventDefault();
      installBtn.style.visibility = 'visible';
      textHeader.textContent = 'Click the button to install!';

      installBtn.addEventListener('click', () => {
        event.prompt();
        installBtn.setAttribute('disabled', true);
        installBtn.textContent = 'Installed!';
      });
    });

    window.addEventListener('appinstalled', (event) => {
      textHeader.textContent = 'Successfully installed!';
      console.log('👍', 'appinstalled', event);
    });
    ```

* Open `25-Ins_Manifest/service-worker.js` in your IDE and explain the following:

  * 🔑 For the `manifest.json` file to work, we need to have, at the minimum, a service worker that registers, has scope, and has a fetch method in place.

    ```js
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', function() {
        navigator.serviceWorker.register('./service-worker.js').then(function(registration) {
          // Registration was successful
          console.log('ServiceWorker registration successful with scope: ', registration.scope);
        }, function(err) {
          // registration failed :(
          console.log('ServiceWorker registration failed: ', err);
        });
      });
    }

    this.addEventListener('fetch', function (event) {
      // This fetch function is required for the SW to be detected and is intentionally empty
      // For a more robust, real-world SW example see: https://developers.google.com/web/fundamentals/primers/service-workers
    });
    ```

* Open `25-Ins_Manifest/index.html` in your IDE and explain the following:

  * 🔑 For the `manifest.json` file to work, we also need to import it into our `index.html` file.

    ```html
    <link rel="manifest" href="./manifest.json">
    ```

* Open `25-Ins_Manifest/index.html` with Live Server and demonstrate the following:

  * Click the button that states "Click Me to Install!" on the webpage.

* Navigate to your computer's Launchpad (Mac) or Desktop (Windows) to demonstrate the following:

  * The app is installed and the icon appears.

  * When we click on the icon, the app launches.

* Ask the class the following questions (☝️) and call on students for the answers (🙋):

  * ☝️ What file do we need to create an installable PWA?

  * 🙋 A `manifest.json` file!

* Answer any questions before proceeding to the next activity.

* In preparation for the activity, ask TAs to start directing students to the activity instructions found in `26-Stu_Manifest/README.md`.

### 9. Student Do: Manifest (15 min)

* Direct students to the activity instructions found in `26-Stu_Manifest/README.md`, which are also shown below.

* Break your students into pairs that will work together on this activity.

  ```md
  # 📖 Implement a Manifest.json File with Webpack

  Work with a partner to implement the following user story:

  * As a developer, I want to be able to automatically generate a `manifest.json` file inside `dist` when I run my application.

  ## Acceptance Criteria

  * It is done when I can install my application as a Progressive Web App.

  * It is done when I can see my `manifest.json` file generated inside Chrome DevTools.

  ## 📝 Notes

  Refer to the documentation:

  [Webpack PWA Manifest plugin documentation.](https://www.npmjs.com/package/webpack-pwa-manifest)

  ---

  ## 💡 Hints

  How could our JSON be represented in a JavaScript object?

  ## 🏆 Bonus

  If you have completed this activity, work through the following challenge with your partner to further your knowledge:

  * What is each key in a `manifest.json` file responsible for?

  Use [Google](https://www.google.com) or another search engine to research this.
  ```

* While breaking everyone into groups, be sure to remind students and the rest of the instructional staff that questions on Slack or otherwise are welcome and will be handled. It's a good way for your team to prioritize students who need extra help.

### 10. BREAK (10 min)

### 11. Instructor Review: Manifest (10 min)

* Ask the class the following questions (☝️) and call on students for the answers (🙋):

  * ☝️ How comfortable do you feel with `manifest.json`? (Poll via Fist to Five, Slack, or Zoom)

* Assure students that we will cover the solution to help solidify their understanding. If questions remain, remind them to use Office Hours to get extra help.

* Use the prompts and talking points (🔑) below to review the following key points:

  * ✔️ `manifest.json`

  * ✔️ Installable web applications

  * ✔️ `manifest.json` properties

* Open `26-Stu_Manifest/Solved/webpack.config.js` in your IDE and explain the following:

  * 🔑 Install the webpack plugin `webpack-pwa-manifest`.

    ```bash
    npm install --save-dev webpack-pwa-manifest
    ```

  * Import the `webpack-pwa-manifest` package into your `webpack.config.js` file.

    ```js
    const WebpackPwaManifest = require('webpack-pwa-manifest');
    ```

  * 🔑 Under the `plugins` property, declare a new plugin using `WebpackPwaManifest`.

    ```js
    plugins: [
        new HtmlWebpackPlugin({
          template: './index.html',
        }),

        new GenerateSW(),
        new WebpackPwaManifest({ }),

      ],
    ```

  * 🔑 Fill out the JavaScript object with the properties that we saw inside the `manifest.json` file earlier.

    ```js
    plugins: [
        new HtmlWebpackPlugin({
          template: './index.html',
        }),

        new GenerateSW(),
        new WebpackPwaManifest({
          name: 'TODOs',
          short_name: 'TODOs',
          description: 'Keep track of important tasks!',
          background_color: '#7eb4e2',
          theme_color: '#7eb4e2',
          start_url: './',
          publicPath: './',
          icons: [
            {
              src: path.resolve('assets/images/logo.png'),
              sizes: [96, 128, 192, 256, 384, 512],
              destination: path.join('assets', 'icons'),
            },
          ],
         }),

      ],
    ```

* 🔑 You can see most of the JSON coordinates to a key in the JavaScript object, but we have two properties that look different.

* 🔑 The `publicPath` tells webpack where to serve the bundled.

* 🔑 The `icons` now generate the properly sized icons for us based on one provided image.

* Ask the class the following questions (☝️) and call on students for the answers (🙋):

  * ☝️ What is the name of the webpack plugin that we use to generate a `manifest.json` file?

  * 🙋 `webpack-pwa-manifest`

  * ☝️ Do we need a service worker for us to use a `manifest.json` file?

  * 🙋 Yes!

  * ☝️ What can we do if we don't completely understand this?

  * 🙋 We can refer to supplemental material, read the [MDN Web Docs on manifest.json](https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/manifest.json), and attend Office Hours to ask for help.

* Answer any questions before proceeding to the next activity.

* In preparation for the activity, ask TAs to start directing students to the activity instructions found in `27-Evr_Git-Hooks/README.md`.

### 12. Everyone Do: Git (10 min)

* Open the [Git Docs on Git hooks](https://git-scm.com/book/en/v2/Customizing-Git-Git-Hooks) in your browser and explain the following:

  * When working with a team, we often have a certain set of practices that we want everyone to follow when using a repository. Git hooks provide a convenient way to execute custom scripts when a certain action is performed in order to remind the team of the established rules.

  * For example, if we want to add a reminder to our teammates about the way the commit message should be styled, we can set up a Git hook to listen for a commit event and then execute a script to send an automated reminder.

  * Each Git hook is local to a single repository, and we must install the hook in each repository where we want the script to execute.

  * To install a Git hook, we either start with a pre-written sample hook provided by Git or write a custom hook on our own.

* Direct students to the activity instructions found in `27-Evr_Git-Hooks/README.md`.

* While everyone is working on the activity, be sure to remind students and the rest of the instructional staff that questions on Slack or otherwise are welcome and will be addressed. It's a good way for your team to prioritize students who need extra help.

* Open the command line and demonstrate the following:

  * 🔑 We initialize a new repository and enter `ls .git/hooks` to see a list of pre-written sample hooks that Git provides with each new repository.

    ```bash
    mkdir hook-test
    cd hook-test
    git init
    ls .git/hooks
    ```

  * Let's explore one of these hooks. We enter `code .git/hooks/pre-commit.sample` to open the `pre-commit` hook in VS Code.

  * 🔑 We see that Git hooks are written as shell hooks, and this hook is executed before a commit is made to check if files that use non-ASCII names are being used. To apply this hook to our repository, we simply rename it and remove the `.sample` extension.

    ```bash
    mv .git/hooks/pre-commit.sample .git/hooks/pre-commit
    ```

  * 🔑 We can also write our own custom hooks. To start, we add a new file in the `hooks` directory to hold our custom hook and set the permissions to execute.

    ```bash
    touch .git/hooks/post-checkout
    chmod +x .git/hooks/post-checkout
    code .git/hooks/post-checkout
    ```

  * We then add the shell script logic to set a safe list of issue/feature names, get the current branch, and check if the name matches a name in the safe list.

    ```bash
    #!/bin/sh
    safelist=("main", "develop", "staging")
    branch=$(git branch --show-current)
    if [[ ! ${safelist[*]} =~ "$branch" ]] && [[ ! "$branch" =~ ^(issue/|feature/).* ]]
    then
      echo "Warning!"
      echo 'If feature or issue branch, please use "issue/" or "feature/" prefix.'
    fi
    ```

  * We can now use our new Git hook to set a reminder to use the team's naming convention within the repository.

* Answer any questions before proceeding to the next activity.

### 13. Instructor Demo: Mini-Project (5 min)

* Navigate to `28-Stu_Mini-Project/Main` from the command line and run `npm install` and `npm run start`.

* Open [http://localhost:3000](http://localhost:3000) in your browser and demonstrate the following:

  * The homepage is a simple form with contact information.

  * When we fill out the form and submit it, we create a new contact card.

* Open the Application tab in Chrome DevTools and demonstrate the following:

  * 🔑 We see that the cards are being saved and retrieved by the `contact` object store under the `IndexedDB` section.

  * 🔑 We can also see that we have a manifest file and active service worker caching assets.

  * We can also install our application via the button in the header or address bar.

* Open the `Elements` tab in Chrome DevTools, expand the `<head>` element, and demonstrate the following:

  * 🔑 We see that our files are being bundled with webpack.

* Ask the class the following questions (☝️) and call on students for the answers (🙋):

  * ☝️ How would we build this?

  * 🙋 With webpack, workbox, and IndexedDB!

* Answer any questions before allowing students to start the mini-project.

### 14. Student Do: Mini-Project (45 min)

* Direct students to the activity instructions found in `28-Stu_Mini-Project/README.md`, which are also shown below.

* Break your students into groups that will work together on this activity.

  ```md
  # Module 19 Mini-Project: Deploy Contact Directory App on Heroku with Script

  In this mini-project, you are given a simple application that needs to be updated to use webpack, service workers, and IndexedDB. In addition, it must have PWA functionality in order to work properly. Once you have updated the application with these new features, you will deploy it to Heroku. Heroku is not new to you, but you will need to add a handful of special scripts so that it knows to deploy your bundled application.

  ## User Stories

  Work with your group to resolve the following issues:

  * As a user, I want to be able to install the web application as a PWA.

  * As a user, I want to be able to add and remove my contact cards.

  * As a developer, I want all my scripts to run from the root directory `package.json`.

  * As a developer, I want to be able to run `npm run start` in the command line and have both my client and server start.

  * As a developer, I want to be able to run `npm run start:prod` in the command line to run our build script and start our server.

  * As a developer, I want to be able to run `npm run server` in the command line and have just our server start without the client.

  * As a developer, I want to be able to run `npm run build` in the command line and have our client run the webpack build script.

  * As a developer, I want to be able to run `npm run install` in the command line and have all of the client's dependencies installed.

  * As a developer, I want to be able to run `npm run client` in the command line and have just our client start without the server.

  ## Acceptance Criteria

  The mini-project is complete when the following criteria are met:

  * The application uses webpack for bundling.

  * The application uses a service worker to cache static assets.

  * The application uses IndexedDB GET, ADD, and DELETE methods.

  * The application uses object store for async/await.

  * The application uses CSS loaders.

  * Scripts are placed in the root and client directory's `package.json`.

  * `npm run start` starts both the client and server.

  * `npm run start:prod` runs the `build` script and starts the server.

  * `npm run server` starts just the server and not the client.

  * `npm run build` runs the webpack build script in the client.

  * `npm run install` installs the dependencies for the client.

  * `npm run client` starts the client without the server.

  * The web application can be installed from the web address provided by Heroku.

  * The web application is deployed using Heroku.

  ---

  ## 💡 Hints

  * How do you navigate to different directories inside bash?

  * What is the operator for "and"?

  ## 🏆 Bonus

  If you have completed this activity, work through the following challenge with your partner to further your knowledge:

  * Incorporate a way to edit information on the contact card using a PUT method with IndexedDB.
  ```

* While breaking everyone into groups, be sure to remind students and the rest of the instructional staff that questions on Slack or otherwise are welcome and will be handled. It's a good way for your team to prioritize students who need extra help.

### 15. Instructor Review: Mini-Project  (10 min)

* Ask the class the following questions (☝️) and call on students for the answers (🙋):

  * ☝️ How comfortable do you feel with this mini-project? (Poll via Fist to Five, Slack, or Zoom)

* Assure students that we will cover the solution to help solidify their understanding. If questions remain, remind them to use Office Hours to get extra help.

* Use the prompts and talking points (🔑) below to review the following key points:

  * ✔️ Deploy to Heroku

  * ✔️ Build scripts

  * ✔️ IndexedDB

* Open `28-Stu_Mini-Project/Main/package.json` in your IDE and explain the following:

  * We need to create a few basic scripts to get the application running.

    ```json
     "scripts": {
        "server": "cd server nodemon server.js --ignore client",
        "build": "cd client && npm run build",
        "install": "cd server && npm i && cd ../client && npm i",
        "client": "cd client && npm start"
    },
    ```

  * 🔑 `server` will start up only the server side of our application.

  * 🔑 `build` will change directories into the `client` and run the clients build script, which we will look at shortly.

  * 🔑 `install` will change directories into the `client` and install all the necessary packages.

  * 🔑 `client` will just start the client.

  * 🔑 We now have to install the `concurrently` package for our next script.

    ```json
     "scripts": {
        "start:dev": "concurrently \"cd server && npm run server\" \"cd client && npm run dev\"",
        "start": "npm run build && cd server && node server.js",
        "server": "cd server nodemon server.js --ignore client",
        "build": "cd client && npm run build",
        "install": "cd server && npm i && cd ../client && npm i",
        "client": "cd client && npm start"
    },
    ```

  * 🔑 `start:dev` will run our server and webpack server at the same time.

  * 🔑 `start` will run our server and webpack build the client for us.

* Open `28-Stu_Mini-Project/Main/client/package.json` in your IDE and explain the following:

  * For the root level `package.json` scripts to work, we need to set up the webpack scripts in the client `package.json` file.

    ```json
    "scripts": {
      "dev": "webpack-dev-server",
      "build": "webpack --mode production",
      "start": "webpack --watch"
    },
    ```

  * 🔑 Now the root level `package.json` can communicate with the client `package.json`.

* Open `28-Stu_Mini-Project/Main/client/src-sw.js` in your IDE and explain the following:

  * Now we create a simple service worker with a workbox to cache static assets for us.

    ```js
    const { StaleWhileRevalidate } = require('workbox-strategies');
    const { registerRoute } = require('workbox-routing');
    const { CacheableResponsePlugin } = require('workbox-cacheable-response');
    const { precacheAndRoute } = require('workbox-precaching/precacheAndRoute');

    precacheAndRoute(self.__WB_MANIFEST);

    // Set up asset cache
    registerRoute(
      ({ request }) => ['style', 'script', 'worker'].includes(request.destination),
      new StaleWhileRevalidate({
        cacheName: 'asset-cache',
        plugins: [
          new CacheableResponsePlugin({
            statuses: [0, 200],
          }),
        ],
      })
    );
    ```

  * 🔑 With workbox, we need to first specify our `precacheAndRoute(self.__WB_MANIFEST);`.

  * 🔑 Next, we use workbox routing with a caching strategy to set up a cache called `asset-cache`.

* Open `28-Stu_Mini-Project/Main/client/webpack.config.js` in your IDE and explain the following:

  * We have our `entry` files set up, so now we can specify the `output` files.

    ```js
    output: {
        filename: '[name].bundle.js',
        path: path.resolve(__dirname, 'dist'),
      },
    ```

  * The files will be bundled and placed in the `dist` directory.

  * Next, we specify the `plugins` we want to use.

    ```js
    plugins: [
      new HtmlWebpackPlugin({
        template: './index.html',
      }),

      new InjectManifest({
        swSrc: './src-sw.js',
        swDest: 'src-sw.js',
      }),
      new WebpackPwaManifest({
        fingerprints: false,
        inject: true,
        name: 'Contact Cards',
        short_name: 'Contact',
        description: 'Never forget your contacts!',
        background_color: '#225ca3',
        theme_color: '#225ca3',
        start_url: './',
        publicPath: './',
        icons: [
          {
            src: path.resolve('src/images/logo.png'),
            sizes: [96, 128, 192, 256, 384, 512],
            destination: path.join('assets', 'icons'),
          },
        ],
      }),
    ],
    ```

  * `HtmlWebpackPlugin` helps us generate an `index.html` file inside the `dist` directory.

  * `InjectManifest` will inject our custom service worker into our webpack build.

  * `WebpackPwaManifest` will create a `manifest.json` file with the provided object.

  * Finally, we can add CSS loaders and Babel.

    ```js
    module: {
      rules: [
        {
          test: /\.css$/i,
          use: ['style-loader', 'css-loader'],
        },
        {
          test: /\.m?js$/,
          exclude: /node_modules/,
          use: {
            loader: 'babel-loader',
            options: {
              presets: ['@babel/preset-env'],
              plugins: ['@babel/plugin-proposal-object-rest-spread', '@babel/transform-runtime'],
            },
          },
        },
      ],
    },
    ```

* Open `28-Stu_Mini-Project/Main/client/src/js/database.js` in your IDE and explain the following:

  * Here, we initialize the database and create an object store named `contacts`.

    ```js
    const initdb = async () =>
      openDB('contact', 1, {
        upgrade(db) {
          if (db.objectStoreNames.contains('contact')) {
            console.log('contact database already exists');
            return;
          }
          db.createObjectStore('contact', { keyPath: 'id', autoIncrement: true });
          console.log('contact database created');
        },
      });
    ```

  * Next, we create a POST function for our database.

    ```js
    export const postDb = async (name, home, cell, email)  => {
      const contactDb = await openDB('contact', 1);
      const tx = contactDb.transaction('contact', 'readwrite');
      const store = tx.objectStore('contact');
      const request = store.add({ name: name, home_phone: home, cell_phone: cell, email: email });
      const result = await request;
      console.log('🚀 - data saved to the database', result);
    };
    ```

  * We open a transaction in the `contact` database with `readwrite` privileges.

  * Once open, we use the `.add()` method on the `store` and pass in the appropriate parameters.

  * Next, we create a GET function for our database.

    ```js
    export const getDb = async () => {
      const contactDb = await openDB('contact', 1);
      const tx = contactDb.transaction('contact', 'readonly');
      const store = tx.objectStore('contact');
      const request = store.getAll();
      const result = await request;
      console.log('result.value', result);
      return result;
    };
    ```

  * This is the same as earlier, except that we are using the `.getAll()` method instead, which only requires `readonly` privileges.

  * Finally, we create a DELETE function for our database.

    ```js
    export const deleteDb = async (id) => {
      const contactDb = await openDB('contact', 1);
      const tx = contactDb.transaction('contact', 'readwrite');
      const store = tx.objectStore('contact');
      const request = store.delete(id);
      const result = await request;
      console.log('result.value', result);
      return result?.value;
    };
    ```

* This is the same as earlier, except that we are using the `.delete()` method with the appropriate `id`.

* Open `28-Stu_Mini-Project/Main/.npmrc` in your IDE and explain the following:

  * 🔑 This file tells Heroku to not purge our dev dependencies when we deploy to Heroku. We need webpack for our application to work properly, and webpack is a dev dependency.

  * 🔑 Run the following commands to deploy to Heroku:

    ```sh
    git init
    git add -A
    git commit -m "Ready to deploy!"
    heroku create
    git push heroku main
    ```

  * 🔑 After a couple of minutes, our PWA should be successfully deployed to Heroku!

* Ask the class the following questions (☝️) and call on students for the answers (🙋):

  * ☝️ Why do we want to deploy with the dev dependencies?

  * 🙋 We need access to webpack, which is a dev dependency!

  * ☝️ Why do we use `concurrently`?

  * 🙋 So that we can run both the webpack server and node server during development.

  * ☝️ What can we do if we don't completely understand this?

  * 🙋 We can refer to supplemental material, read the [Heroku deployment guide](https://devcenter.heroku.com/articles/git), and attend Office Hours to ask for help.

* Answer any questions before proceeding to the next activity.

### 16. Instructor Demo: Introduce Challenge (5 min)

* Navigate to `02-Challenge/Main` from the command line and run `npm install` and `npm run start`.

* Open [http://localhost:3000](http://localhost:3000) in your browser and demonstrate the following:

  * We are building a PWA text editor with JavaScript syntax highlighting.

* Try writing `console.log()` in the JavaScript syntax editor opened in the browser to demonstrate the following:

  * Click the install button, and demonstrate that even when we open and close the installed version of the app, the console.log() we have typed is saved.

* Open the Application tab in Chrome DevTools. Under the "Cache Storage" section, inspect the contents of the object store.

  * We are storing the contents of the editor in IndexedDB and saving `onBlur()` on the window.

  * We can also inspect the service worker, which is caching our static assets so the application can work offline.

  * All of this is bundled with the help of a webpack!

* Ask the class the following questions (☝️) and call on students for the answers (🙋):

  * ☝️ What are we learning?

  * 🙋 PWAs, webpack, workbook, and IndexedDB!

  * ☝️ How does this project build on or extend previously learned material?

  * 🙋 We get to apply the PUT method and we use a more complex `index.html` template.

  * ☝️ How does this project relate to your career goals?

  * 🙋 You get to flex some of your usual JavaScript skills with a hint of web performance!

* Ask TAs to direct students to the Challenge Requirements found in `02-Challenge/README.md`.

* Answer any questions before ending the class.

### 17. END (0 min)

How did today’s lesson go? Your feedback is important. Please take 5 minutes to complete this [anonymous survey](https://forms.gle/RfcVyXiMmZQut6aJ6).

---
© 2022 edX Boot Camps LLC. Confidential and Proprietary. All Rights Reserved.
