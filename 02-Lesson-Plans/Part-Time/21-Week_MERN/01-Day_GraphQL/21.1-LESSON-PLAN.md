# 21.1 Weekday Lesson Plan: GraphQL

## Overview

This class covers GraphQL, including using the Apollo Server to set up `typeDefs` and `resolvers`, making queries and using mutations, and using the Apollo Sandbox. The three-layer MERN architecture is also discussed.

## Instructor Notes

* In this lesson, students will complete activities `01-Ins_Apollo-Server` through `10-Stu_Mutations`.

* It is highly recommended that prior to class, you go through each demo and activity so that you are familiar with the code and can anticipate issues that students new to GraphQL and the MERN framework may face.

* Today's slide deck includes an introduction to the MERN framework. This is a great opportunity to remind students of how far they have come since starting with HTML and CSS and encourage them to start thinking about how they can apply their new skills to their final, full-stack projects and their future careers.

* The activities in this module will require some familiarity with GraphQL and the Apollo Sandbox tool. If you've never worked with GraphQL or the Apollo Sandbox tool, please refer to the [Apollo Docs on Apollo Sandbox](https://www.apollographql.com/docs/studio/explorer/sandbox/).

* Apollo Sandbox is an Apollo Studio Explorer tool used for local development and replaces the now-deprecated GraphQL Playground. To use Sandbox, you do not have to register for an Apollo account. Instead, Sandbox can be accessed on the same URL as the GraphQL server. For most activities during today‚Äôs class, you will do the following to start Sandbox: start the app using `npm install`, `npm run seed`, and `npm start`. Then, navigate to `localhost:3001/graphql` in the browser to view Sandbox in the browser.

* Today's activities use Apollo Server 3, which include a number of breaking changes from Apollo Server 2. Apollo Server 3 requires `graphql` 15.3.0 or later to run successfully. For more information about migrating to Apollo Server 3, including bumped dependencies and removed integrations, refer to [Apollo Docs on migrating to Apollo Server 3](https://www.apollographql.com/docs/apollo-server/migration/).

* The GraphQL activities and instructor demonstrations require a minimum npm version of 7.0.0 or greater. Prior to class, please be sure to check your npm version and update if needed. Refer to the [NPM docs on updating to latest stable version](https://docs.npmjs.com/try-the-latest-stable-version-of-npm).

* For students who need help opening up the apps used in today's activities or accessing the Apollo Sandbox, step-by-step instructions are found in `02-Stu_Apollo-Server/README.md`.

* Remind students to do a `git pull` of the class repo and to have today's activities ready and open in VS Code.

* If you are comfortable doing so, live-code the solutions to the activities. If not, just use the solutions provided and follow the prompts and talking points for review.

* Let students know that the Bonus at the end of each activity is not meant to be extra coding practice, but instead is a self-study on topics beyond the scope of this module for those who want to further their knowledge.

## Learning Objectives

By the end of class, students will be able to:

* Explain how the client, server, and database layers work together to build a full-stack MERN app.

* Integrate an Apollo Server with Express.js to create a GraphQL server.

* Write queries using the GraphQL query language.

* Design a schema using `typedefs` and `resolvers`.

* Use mutations to modify server-side data.

## Slide Deck

* [Module 21 Slide Deck](https://docs.google.com/presentation/d/15HFGsli3B1UvM8-khsTi7-DjkN1zX8mpLULMn7oGwX4/edit?usp=sharing)

## Time Tracker

| Start  | #   | Activity Name                             | Duration |
| ------ | --- | ----------------------------------------- | -------- |
| 0:00   | 1   | Instructor Do: Stoke Curiosity            | 0:10     |
| 0:10   | 2   | Instructor Demo: Apollo Server            | 0:05     |
| 0:15   | 3   | Student Do: Apollo Server                 | 0:15     |
| 0:30   | 4   | Instructor Review: Apollo Server          | 0:10     |
| 0:40   | 5   | Instructor Demo: Queries                  | 0:05     |
| 0:45   | 6   | Student Do: Queries                       | 0:15     |
| 1:00   | 7   | Instructor Review: Queries                | 0:10     |
| 1:10   | 8   | Instructor Demo: typeDefs and Resolvers   | 0:05     |
| 1:15   | 9   | Student Do: typeDefs and Resolvers        | 0:15     |
| 1:30   | 10  | BREAK                                     | 0:15     |
| 1:45   | 11  | Instructor Review: typeDefs and Resolvers | 0:10     |
| 1:55   | 12  | Instructor Demo: Arguments                | 0:05     |
| 2:00   | 13  | Student Do: Arguments                     | 0:15     |
| 2:15   | 14  | Instructor Review: Arguments              | 0:10     |
| 2:25   | 15  | Instructor Demo: Mutations                | 0:05     |
| 2:30   | 16  | Student Do: Mutations                     | 0:15     |
| 2:45   | 17  | Instructor Review: Mutations              | 0:15     |
| 3:00   | 18  | END                                       | 0:00     |

---

## Class Instruction

### 1. Instructor Do: Stoke Curiosity (10 min)

* Welcome students to class.

* Open the [Module 21 slide deck](https://docs.google.com/presentation/d/15HFGsli3B1UvM8-khsTi7-DjkN1zX8mpLULMn7oGwX4/edit?usp=sharing) and follow these prompts on their corresponding slides:

  * **What Is the MERN Stack?**: The MERN stack is a group of four technologies that, when used together, create our ‚Äústack‚Äù. There are other stacks besides MERN, but the MERN stack uses technologies we already learned to quickly build a full-stack app. The four MERN technologies are: MongoDB, Express.js, React.js, and Node.js.

  * **How Does the MERN Stack Work?**: The MERN stack has a three-layered architecture based on the Model-View-Controller design pattern. Each interconnected layer performs a specific function in the application.

  * **The Client Layer: React.js**: React.js is a front-end JavaScript library that allows us to turn reusable components into interactive user interfaces. The client layer controls what the user sees and how the user interacts with data. In the client layer, data retrieved from the database can be displayed. Users can also input data using the user interface.

  * **The Server Layer: Express.js and Node.js**: Express.js is a web framework for Node.js that handles requests and connects the client layer with the database layer. The server layer defines how data is handled in our apps and routes it between the database and client layers. The server layer listens for events from the client layer and then responds by executing methods that save and retrieve data from the database layer.

  * **The Database Layer: MongoDB**: MongoDB is a general purpose, document-based, distributed NoSQL database. The database layer is used to store all the data needed for your application to function. MongoDB stores JSON natively (technically BSON) making it work easily with JavaScript apps.

* After you run through the slides, preview the mini-project for the class. In the command line, navigate to `28-Stu_Mini-Project/Main` and run `npm install`, `npm run seed`, and `npm run develop`. Be sure to have a MongoDB instance running!

* Open `http://localhost:3000/` to demonstrate the following:

  * This app is built using the MERN framework and uses technologies that we have already learned: React.js, Node.js, Express.js, and MongoDB.

  * When we open the app, everything we see is the client layer. The **client layer**, or front end, is the how the user inputs and views data.

  * When we interact with the app by selecting technologies for a matchup or voting on existing matchup pairs, we trigger an event that is handled on the backend. The backend contains the logic for handling data and is not seen by the user.

  * The **server layer** listens for events triggered by the client. For example, when we vote or select a pair of technologies to create a matchup using the user interface, the server layer responds to that event by executing a function to save the user generated data in the database.

  * The server layer can also retrieve data from the **database layer**.

  * When we click on View All Matchups, the server layer executes a method to retrieve the requested data from the database layer. The populated list of matchups is displayed to the user.

  * This three-layer architecture makes it easier to store, manipulate, and represent data. This makes the MERN stack an ideal solution for highly interactive apps and those that require data to be fetched quickly and easily.

  * During today's class, we will focus on fetching and storing data by using an add-on technology that builds on our existing Express.js server.

* Ask the class the following questions (‚òùÔ∏è) and call on students for the answers (üôã):

  * ‚òùÔ∏è What are we learning?

  * üôã We are learning how to structure a full-stack app by using the MERN stack.

  * ‚òùÔ∏è How does this project build on or extend previously learned material?

  * üôã The MERN stack relies on JavaScript and technologies that we have learned throughout the course: React.js, MongoDB, Express.js, and Node.js.

  * ‚òùÔ∏è How does this project relate to your career goals?

  * üôã The MERN framework uses the MVC pattern, a pattern common in software development, to connect a front end, back end, and database to create a full-stack app. It also uses JavaScript technologies commonly used in development on the job. Learning MERN is also a great way to become familiar with full-stack web development and gain skills in building interactive apps that are scalable and capable of handling large data sets.

* Answer any questions before proceeding to the next activity.

### 2. Instructor Demo: Apollo Server (5 min)

* Navigate to `01-Ins_Apollo_Server` in your command line and run `npm install`, `npm run seed`, and `npm start`.

* Open `localhost:3001/graphql` in your browser and demonstrate the following:

  * At the heart of interactive full-stack apps is the need to retrieve data quickly and accurately.

  * üîë We use GraphQL to efficiently and precisely fetch the data queried in a single request.

  * üîë **GraphQL** is a query language that allows us to build even complex queries quickly and concisely, helping to make sure our queries fetch data -- and only the data we need -- quickly.

  * Apollo Sandbox is an Apollo Studio Explorer tool and is a great way to to visually explore how GraphQL can be used to request and fetch data.

  * üîë Using the Apollo Sandbox, we can enter a query to retrieve data from our database. This query will return the names of all the classes in our database:

    ```gql
    query classes{
      classes {
        name
      }
    }
    ```

  * Next, when we click the rectangular play button at the top of the screen we see a JSON object that contains only the data we requested in the response field on the left. This ability to easily write specific queries and return precise results is one of the main advantages of GraphQL.

  * We will be using the Apollo Sandbox in today's class to test our code amd make sure our queries work.

  * üîë To use GraphQL, we will need to set up a GraphQL server. Apollo Server is a popular GraphQL server that can be used as an add-on to an existing Node.js and Express.js server.

* Open `01-Ins_Apollo_Server/server.js` in your IDE and demonstrate the following:

  * To add Apollo Server to our existing Express.js and Node.js server structure, we run `npm install apollo-server-express` and import the `ApolloServer` class:

     ```js
     const { ApolloServer } = require('apollo-server-express');
     ```

  * We must also import the schemas directory. GraphQL relies on a schema bundle that includes two parts: the `typeDefs`, which defines the schema, and `resolvers`, or functions, that are responsible for populating data for a single field in the schema:

     ```js
     const { typeDefs, resolvers } = require('./schemas');
     ```

  * We create a new instance of the `ApolloServer` class. The `ApolloServer` class instance takes both `typeDefs` and `resolvers` as parameters:

     ```js
     const server = new ApolloServer({
       typeDefs,
       resolvers
     });
     ```

  * Next, we create an async function that will take in our `typeDefs` and `resolvers` and start our Apollo Server instance:

    ```js
    const startApolloServer = async (typeDefs, resolvers) => {...}
    ```

  * Inside the `startApolloServer` function, we use `await` to start our server. Don't forget, we must wrap `await` inside an async function. Otherwise, we will get an error!

    ```js
    await server.start()
    ```

  * We call the `.applyMiddleware()` method to integrate Express.js with the Apollo Server and connect the schema. This will enable our app to use GraphQL:

     ```js
     server.applyMiddleware({ app });
     ```

  * Since our Apollo Server works together with Express, we also create an instance of our Express app inside our async function and use it. Using an Express server gives us more flexibility in our server setup and allows additional configurations.

    ```js
    const app = express();

    app.use(express.urlencoded({ extended: false }));
    app.use(express.json());
    ```

  * Then, we start our database and call `app.listen()` to listen the connections on our specified port.

    ```js
    db.once('open', () => {
      app.listen(PORT, () => {
        console.log(`API server running on port ${PORT}!`);
        console.log(`Use GraphQL at http://localhost:${PORT}${server.graphqlPath}`);
        })
      })
    };
    ```

  * Since, we can enclosed our functionality in an async function, don't forget to call it at the bottom of of the file to run the scripts!

    ```js
    startApolloServer(typeDefs, resolvers);
    ```

* Ask the class the following questions (‚òùÔ∏è) and call on students for the answers (üôã):

  * ‚òùÔ∏è How would we build this?

  * üôã To integrate GraphQL in our MERN apps, we must connect a GraphQL schema to our Express.js server. We do this by adding an Apollo Server to our existing `service layer` and importing our schema.

* Answer any questions before proceeding to the next activity.

* In preparation for the activity, ask TAs to start directing students to the activity instructions found in `02-Stu_Apollo_Server/README.md`.

### 3. Student Do: Apollo Server (15 min)

* Direct students to the activity instructions found in `02-Stu_Apollo_Server/README.md`.

* Break your students into pairs that will work together on this activity.

    ```md
    # üìê Add Comments to Implementation of an Apollo Server

    Work with a partner to add comments describing the functionality of the code found in the following files:

    * [server.js](./Unsolved/server.js)

    * [schemas/typeDefs.js](./Unsolved/schemas/typeDefs.js)

    * [schemas/resolvers.js](./Unsolved/schemas/resolvers.js)

    ## üìù Notes

    To Launch Apollo Sandbox, follow these steps:

    1. In the command line, navigate to `02-Stu_Apollo-Server/Unsolved`.

    2. Run `npm install`.

    3. With a MongoDB instance running, run `npm run seed` to seed the data.

    4. To start the server and launch the app, run `npm start`.

    5. To launch the Apollo Sandbox, open <localhost:3001/graphql> in the browser.

    Refer to the documentation:

    * [Apollo Docs on getting started with Apollo Server](https://www.apollographql.com/docs/apollo-server/getting-started/)

    * [Apollo Docs on integrating with Node.js middleware](https://www.apollographql.com/docs/apollo-server/integrations/middleware/)

    ---

    ## üèÜ Bonus

    If you have completed this activity, work through the following challenge with your partner to further your knowledge:

    * What are the pros and cons of GraphQL vs. REST?

    Use [Google](https://www.google.com) or another search engine to research this.
    ```

* While breaking everyone into groups, be sure to remind students and the rest of the instructional staff that questions on Slack or otherwise are welcome and will be addressed. It's a good way for your team to prioritize students who need extra help.

### 4. Instructor Review: Apollo Server (10 min)

* Ask the class the following questions (‚òùÔ∏è) and call on students for the answers (üôã):

  * ‚òùÔ∏è How comfortable do you feel with integrating Apollo Server? (Poll via Fist to Five, Slack, or Zoom)

* Assure students that we will cover the solution to help solidify their understanding. If questions remain, remind them to use office hours to get extra help.

* Use the prompts and talking points (üîë) below to review the following key points:

  * ‚úîÔ∏è `require('apollo-server-express')`

  * ‚úîÔ∏è `require('./schemas')`

  * ‚úîÔ∏è `new ApolloServer({typeDefs,resolvers})`

  * ‚úîÔ∏è `applyMiddleware()`

  * ‚úîÔ∏è `typeDefs`

  * ‚úîÔ∏è `resolvers`

  * ‚úîÔ∏è `startApolloServer` async function


* Open `02-Stu_Apollo-Server/Solved/server.js` in your IDE and explain the following:

  * üîë Apollo Server is a library that we use with an existing Express.js server. We require the `apollo-server-express` dependency and import the `ApolloServer` class:

     ```js
     const { ApolloServer } = require('apollo-server-express');
     ```

  * üîë We also import the `typedefs` and `resolvers` from the `schemas` directory:

     ```js
     const { typeDefs, resolvers } = require('./schemas');
     ```

  * üîë Next, we create a new instance of the `ApolloServer` class named `server`. This instance takes both parts of the schema -- the `typedefs` and `resolvers` -- as parameters, and allows us to use our schema to handle our data:

     ```js
     const server = new ApolloServer({
       typeDefs,
       resolvers
     });
     ```

  * We call the `.applyMiddleware()` method to update Express.js to use Apollo Server. Our GraphQL server is now set up and ready to use with our schema:

     ```js
     server.applyMiddleware({ app });
     ```

* Open `02-Stu_Apollo-Server/Solved/schemas/typeDefs.js` in your IDE and explain the following:

  * üîë We use `typeDefs` to define our schema and the types it contains.

  * Most defined types are objects. Each object holds a collection of fields that describes the data. The `Class` object will have fields for an id, name, and building as well as the credit hours for the course:

     ```js
      type Class {
       _id: ID
       name: String
       building: String
       creditHours: Int
     }
     ```

  * We also have access to another type, Query. **Query types** define the entry point of every GraphQL query, and control what data can be accessed. The `classes` query type allows us to query an array of all the `Class` objects:

     ```js
     type Query {
       classes: [Class]
     }
     ```

* Open `02-Stu_Apollo-Server/Solved/schemas/resolvers.js` in your IDE and explain the following:

  * üîë A **resolver** is a function that's responsible for populating the data that has been defined by our typeDefs.

  * üîë To write a resolver, we use the name of a defined entry point and then assign the action that will be used to fetch the data:

     ```js
     const resolvers = {
       Query: {
         classes: async () => {
         return await Class.find({});
         }
       }
     };
     ```

* We will use the Apollo Sandbox to explore queries, typeDefs, and resolvers in greater depth in the next activities.

* Ask the class the following questions (‚òùÔ∏è) and call on students for the answers (üôã):

  * ‚òùÔ∏è How do we use Apollo Server to integrate GraphQL into our app?

  * üôã Apollo Server is a GraphQL server that helps you connect a GraphQL schema to a HTTPS server such as Express.js. To use GraphQL in our app, we must update Express.js to use Apollo Server and connect a schema that defines our data and how that data should be handled.

  * ‚òùÔ∏è What can we do if we don't completely understand this?

  * üôã We can refer to supplemental material, read the [Apollo Docs on getting started with Apollo Server](https://www.apollographql.com/docs/apollo-server/getting-started/), and stay for office hours to ask for help.

* Answer any questions before proceeding to the next activity.

### 5. Instructor Demo: Queries (5 min)

* Navigate to `03-Ins_Queries` in your command line and run `npm install`, `npm run seed`, and `npm start`.

  * To open the Apollo Sandbox when using Apollo Server, we start up our app and navigate to `localhost:3001/graphql`. No further setup is needed.

* Open `localhost:3001/graphql` in your browser and demonstrate the following:

  * üîë We click on the `schema` icon at the top left under the Apollo logo. Then select `SDL` inspect our app's schema. If the server has been correctly set up, we should see the schema's object and query types auto-populate.

  * `Object types` represent objects we can fetch and the fields it contains. The Class object has an `id`, `name`, `building`, and `creditHours` fields. In addition, the `professor` field is a queryable field that holds a single `Professor` object:

     ```js
     type Class {
       _id: ID
       name: String
       building: String
       creditHours: Int
       professor: Professor
     }
     ```

  * üîë The `query type` tells us what data we can access and the entry point to that data. To access the array of `Class` objects, we use the `classes` entry point:

     ```js
     type Query {
       schools: [School]
       classes: [Class]
       professors: [Professor]
     }
     ```

  * Click on the square explorer icon located below the schema icon to return to the Sandbox main page. The Operations section in the center of the page is used to enter and execute queries. A sample query should be shown in the section.

  * üîë To create a query, we start by entering the name of the entry point we want to use. Because we want to work with `Class` objects, we use the `classes` entry point. We then list the fields we want included in our results. The `Class` object contains a `name` field, so we list the field `name` inside the brackets:

     ```gql
     query classes {
       classes {
       name
       }
     }
     ```

  * We click on the rectangular play button to run the query. A list containing the name of each class is returned.

  * üîë To access the professor data in the same query, we start by adding `professor` to the list of fields. Then, to display data from the `Professor` object, we use a sub-query to list the names of the fields from the `Professor` object. The Apollo Sandbox makes this simple by providing a list of the names of the fields we can use:

     ```gql
     query classes {
      classes {
        name
        professor {
         name
        }
      }
     }
     ```

* Ask the class the following questions (‚òùÔ∏è) and call on students for the answers (üôã):

  * ‚òùÔ∏è How do we build a query using GraphQL?

  * üôã GraphQL is organized using types and fields. The query type gives us the entry point for our query. The object type provides the fields that we can use to retrieve data. We start by listing the entry point for the data we want to use. Then, we add the fields we want included in our results.

* Answer any questions before proceeding to the next activity.

* In preparation for the activity, ask TAs to start directing students to the activity instructions found in `04-Stu_Queries/README.md`.

### 6. Student Do: Queries (15 min)

* Direct students to the activity instructions found in `04-Stu_Queries/README.md`.

* Break your students into pairs that will work together on this activity.

     ```md
     # üèóÔ∏è Write GraphQL Queries for Front-End Team

     Work with a partner to implement the following user story:

     * As a developer, I want a list of queries that I will need to use on the front end.

     ## Acceptance Criteria

     * It's done when I have a GraphQL query that returns the following:

       * Every school's name, location, and student body count

       * Every class's name

       * Every professor's name

     * It's done when I have a GraphQL query that returns the following:

       * Every class's name, credit hours, and building number

       * Every professor's name and student review score

     * It's done when I have a GraphQL query that returns the following:

       * Every professor's ID, name, student review score, office hours, and office building number

     ---

     ## üí° Hints

     * What tools within the Apollo Sandbox can reveal the data that is available to you?

     ## üèÜ Bonus

     If you have completed this activity, work through the following challenge with your partner to further your knowledge:

     * What other GraphQL IDEs can you use besides the built-in Sandbox?

     Use [Google](https://www.google.com) or another search engine to research this.
     ```

* While breaking everyone into groups, be sure to remind students and the rest of the instructional staff that questions on Slack or otherwise are welcome and will be addressed. It's a good way for your team to prioritize students who need extra help.

### 7. Instructor Review: Queries (10 min)

* Ask the class the following questions (‚òùÔ∏è) and call on students for the answers (üôã):

  * ‚òùÔ∏è How comfortable do you feel with GraphQL queries? (Poll via Fist to Five, Slack, or Zoom)

* Assure students that we will cover the solution to help solidify their understanding. If questions remain, remind them to use office hours to get extra help.

* Use the prompts and talking points (üîë) below to review the following key points:

  * ‚úîÔ∏è Types and fields

  * ‚úîÔ∏è Queryable fields

  * ‚úîÔ∏è Query type

* Navigate to `04-Stu_Queries/Unsolved` in your command line and run `npm install`, `npm run seed`, and `npm start`.

* Open `localhost:3001/graphql` in your browser and demonstrate the following:

  > **Important:** You will use the **Unsolved** code to demonstrate the solution. The solution queries are found at `04-Stu_Queries/Solved/Queries.md`.

  * üîë GraphQL uses types and fields to organize data. We open the `schema` view and select the 'Reference' tab to view the entry points for our data as well as the fields contained in each object. These will be used to write our queries.

  * We click on the square `Explorer` icon to return to the main screen where we can enter a query.

  * üîë To query the `Professor` data, we use the `professors` entry point. Then we list the fields on the `Professor` object that we want included in the results. This query returns the `id`, `name`, `student score`, `office hours`, and `office location` for each professor:

    ```gql
    query professors {
      professors {
        _id
        name
        studentScore
        officeHours
        officeLocation
      }
    }
    ```

  * üîë We can also write more complex queries. When we inspect the `Class` object, we see that it contains a queryable field that can retrieve a single `Professor` object. This makes it easy to access the `Professor` data and `Class` data by using a single query:

     ```js
     type Class {
       _id: ID
       name: String
       building: String
       creditHours: Int
       professor: Professor
     }
     ```

  * üîë We access the array of Class objects using the `classes` entry point and list the names of the fields that we want retrieved. Then we list the fields from the `Professor` object that we want retrieved.

  * This query returns each class object and the associated professor's name and student score:

     ```gql
     query classes {
       classes {
         name
         creditHours
         building
         professor {
           name
           studentScore
         }
       }
     }
     ```

  * üîë We can also nest queries easily. The entry point `schools` gives us access to the array of `School` objects. The `School` object also includes a queryable field that returns an array of all the `Class` objects:

     ```js
     type School {
       _id: ID
       name: String
       location: String
       studentCount: Int
       classes: [Class]
     }
     ```

  * Using `schools` as our entry point, we can return data from the `School`, `Class`, and `Professor` objects all in a single query because `School` gives us access to the `Class` objects and the `Class` objects gives us access to the `Professor` object:

     ```gql
     query schools {
       schools {
         name
         location
         studentCount
         classes {
           name
           professor {
          name
           }
         }
       }
     }
     ```

* Ask the class the following questions (‚òùÔ∏è) and call on students for the answers (üôã):

  * ‚òùÔ∏è How do we use schemas to help us write our queries?

  * üôã The schema defines the data objects and the entry points to access that data. When we write a query, we start with the entry point used to access the data and then list the fields from our data object that contains the data we need.

  * ‚òùÔ∏è What can we do if we don't completely understand this?

  * üôã We can refer to supplemental material, read the [GraphQL Docs on queries and mutations](https://graphql.org/learn/queries/) and the [Apollo Docs on Apollo Sandbox](https://www.apollographql.com/docs/studio/explorer/sandbox/), and stay for office hours to ask for help.

* Answer any questions before proceeding to the next activity.

### 8. Instructor Demo: typeDefs and Resolvers (5 min)

* Open `05-Ins_TypeDefs-Resolvers/schemas/typeDefs.js` in your IDE and demonstrate the following:

  * üîë For our queries to work, we must define our types to provide access to the data that we will need.

  * üîë Each object contains a collection of related fields that return a particular type of data. These fields determine what data can be accessed from the database and provide a shape to our data.

  * The `Professor` object contains fields that will return data containing  `name`, `id`, `officeHours`, `officelocation`, and `studentScore` data. These fields should match how the data in your database is structured:

     ```js
     type Professor {
       _id: ID
       name: String
       officeHours: String
       officeLocation: String
       studentScore: Float
     }
     ```

  * üîë We also use fields to define relationships between objects.

  * The `Class` object needs to access the information about a single related `Professor` object. We use a queryable field to retrieve a single `Professor` object. When the data from the `Class` object is queried, the data from the corresponding `Professor` object will also be available:

     ```js
       type Class {
       _id: ID
       name: String
       building: String
       creditHours: Int
       professor: Professor
     }
     ```

  * Likewise, the `School` object needs access to all of the `Class` objects. We use a queryable field to retrieve an array of all the `Class` objects:

     ```js
     type School {
       _id: ID
       name: String
       location: String
       studentCount: Int
       classes: [Class]
     }
     ```

  * üîë To access our data, we must also define an entry point. These entry points control the data that the query has access to. The `professors` entry point is used to access the array of all `Professor` objects. Likewise, the `schools` entry point controls the access to the array of all the `School` objects:

     ```js
     type Query {
       schools: [School]
       classes: [Class]
       professors: [Professor]
     }
     ```

* Open `05-Ins_TypeDefs-Resolvers/schemas/resolvers.js` in your IDE and demonstrate the following:

  * To respond to a query, we must also write a function that determines how the data for each field is populated when we make a query.

  * üîë Because we are using Mongoose, we must import our models. These models create and read data from the MongoDB database:

     ```js
     const { School, Class, Professor } = require('../models');
     ```

  * üîë When we write a query using the `professors` entry point, we call `.find()` on the `Professor` model that we imported to return all the data contained in the model instance, or document. This populates the fields:

     ```js
     professors: async () => {
       return await Professor.find({});
     }
     ```

  * We can also write a resolver that populates the data of a queryable field.

  * üîë The `.populate()` method allows us to reference documents in other MongoDB collections easily. We use `.populate()`, to fetch data for queryable field `professor`:

     ```js
     classes: async () => {
       return await Class.find({}).populate('professor');
     }
     ```

* Ask the class the following questions (‚òùÔ∏è) and call on students for the answers (üôã):

  * ‚òùÔ∏è How would we build this?

  * üôã To query data with GraphQL, we need a schema that will define the shape of the data. The `object type` contains fields that will determine what type of data will be returned. The `query type` defines the entry points. Then, to make our queries work, we write `resolvers`, which are functions used to populate the data fields.

* Answer any questions before proceeding to the next activity.

* In preparation for the activity, ask TAs to start directing students to the activity instructions found in `06-Stu_TypeDefs-Resolvers/README.md`.

### 9. Student Do: typeDefs and Resolvers (15 min)

* Direct students to the activity instructions found in `06-Stu_TypeDefs-Resolvers/README.md`.

* Break your students into pairs that will work together on this activity.

    ```md
    # üèóÔ∏è Update Professors to Include Their Classes

    Work with a partner to implement the following user story:

    * As a developer, I want to be able to query for professors and their classes at the same time.

    ## Acceptance Criteria

    * It's done when a query in the Apollo Sandbox is able to return data similar to the following:

      "professors": [
        {
          "name": "Rebecca Watts",
          "classes": [
            {
              "name": "Introduction to Computational Thinking"
            },
            {
              "name": "User Interface Design"
            },
            {
              "name": "Internet Architecture and Protocols"
            }
          ]
        }
      ]
    ---

    ## üí° Hints

    * What back-end components make up a complete GraphQL schema?

    ## üèÜ Bonus

    If you have completed this activity, work through the following challenge with your partner to further your knowledge:

    * What other types can be used in a GraphQL schema?

    Use [Google](https://www.google.com) or another search engine to research this.
    ```

* While breaking everyone into groups, be sure to remind students and the rest of the instructional staff that questions on Slack or otherwise are welcome and will be addressed. It's a good way for your team to prioritize students who need extra help.

### 10. BREAK (15 min)

### 11. Instructor Review: typeDefs and Resolvers (10 min)

* Ask the class the following questions (‚òùÔ∏è) and call on students for the answers (üôã):

  * ‚òùÔ∏è How comfortable do you feel with typeDefs and resolvers? (Poll via Fist to Five, Slack, or Zoom)

* Assure students that we will cover the solution to help solidify their understanding. If questions remain, remind them to use office hours to get extra help.

* Use the prompts and talking points (üîë) below to review the following key points:

  * ‚úîÔ∏è `typeDef`

  * ‚úîÔ∏è `resolver`

  * ‚úîÔ∏è `populate()`

* Open `06-Stu_TypeDefs-Resolvers/Solved/schemas/typeDefs.js` in your IDE and explain the following:

  * üîë The `Professor` object contains a queryable field that returns an array of `Class` objects:

     ```js
     type Professor {
       _id: ID
       name: String
       officeHours: String
       officeLocation: String
       studentScore: Float
       classes: [Class]
     ```

  * üîë To access the array of `Professor` objects, we use the `professors` entry point:

     ```js
     type Query {
       schools: [School]
       classes: [Class]
       professors: [Professor]
     }
     ````

* Open `06-Stu_TypeDefs-Resolvers/Solved/schemas/resolvers.js` in your IDE and explain the following:

  * We write a query using the `professors` entry point and call `.find()` on the `Professor` model we imported to populate the data:

     ```js
     professors: async () => {
       return await Professor.find({})
     }
     ```

  * üîë We then call the `.populate()` method to access the class data needed so we can query the array of `Class` objects. The data for both the professors and associated classes will be returned:

     ```js
     professors: async () => {
       return await Professor.find({}).populate('classes');
     }
     ```

* Navigate to `06-Stu_TypeDefs-Resolvers/Solved` in your command line and run `npm install`, `npm run seed`, and `npm start`.

* Open `localhost:3001/graphql` in your browser and demonstrate the following:

  * To test if our `typeDefs` and `resolvers` work, we write a query using the `professors` entry point to return data that contains both the professor's name and the name of each class they teach:

     ```gql
     query professorsClasses {
       professors{
         name
         classes {
           name
         }
       }
     }
     ```

* Ask the class the following questions (‚òùÔ∏è) and call on students for the answers (üôã):

  * ‚òùÔ∏è Why do we need to write resolvers to query our data?

  * üôã Resolvers are the functions that determine how the data fields are populated. Without resolvers, we wouldn't have any data to work with!

  * ‚òùÔ∏è What can we do if we don't completely understand this?

  * üôã We can refer to supplemental material, read the [Apollo Docs on resolvers](https://www.apollographql.com/docs/apollo-server/data/resolvers/) and the [Apollo Docs on schema basics](https://www.apollographql.com/docs/apollo-server/schema/schema/), and stay for office hours to ask for help.

* Answer any questions before proceeding to the next activity.

### 12. Instructor Demo: Query Arguments (5 min)

* Navigate to `07-Ins_Query-Arguments` in your command line and run `npm install`, `npm run seed`, and `npm start`.

* Open `localhost:3001/graphql` in your browser and demonstrate the following:

  * üîë We can also create more specific queries by passing arguments.

  * üîë Up until now, we have been using an entry point that returns an array of all the objects and returns one or more fields in each object. For example, we use the `classes` entry point to return the id of all the `Class` objects:

     ```gql
     query classIDs {
       classes {
       _id
       }
     }
     ```

  * Often, though, we want to query a more specific result like a single class.

  * When we open up the schema tab, we see a new entry point has been defined in the query type. The `class` entry point provides access to a single `Class` object. Note that single objects don't have brackets around them!

     ```js
     class(id: ID!): Class
     ```

  * üîë The class entry point also has an argument that allows us to define the id of the class object we want to fetch:

     ```js
     class(id: ID!)
     ```

  * The `ID!` is important here. The `ID` specifies the type of data that must be returned. The exclamation point `!` means that the data is required. Because we want our resolver function to search by ID for a particular class object, if that data is not provided, the search will not work.

  * üîë To create a query, we start with the `class` endpoint and then specify the id of the specific `Class` object we want queried. (**Note**: the query will not yet return data):

     ```gql
     query classInline {
       class(id: "1000") {
         name
       }
     }
     ```

  * The data passed in the argument is then used by the resolver to retrieve the specific class. Because no resolver has been written, no data is returned. In the next activity, you will be building that resolver to make it work.

  * üîë To make our queries more durable, we can also add a variable. Variables are identified by a dollar sign `$` and allow us to reuse the same query over and over:

     ```gql
      query classVariable($id: ID!) {
       class(id: $id) {
         name
       }
     }
     ```

  * We start by requiring our variable and setting the data type of the variable to the required type. For an id, it is the ID type. We also want to make sure that we only run the query if the variable is not null, so we add the exclamation point:

     ```gql
     query classVariable($id: ID!)
     ```

  * We then use the `class` entry point, and assign the `id` a value as we did before. In this case, we set the value of `id` to be the value held in the variable.

  * In our completed apps, the value for the variable is typically provided by the client. However, we can test the query using the Apollo Sandbox.

  * We enter the variable name and pass a value -- in JSON -- in the Query Variables pane, to test the query. We use just the variable name, not the `$` identifier:

     ```js
     {
       "id": "1000"
     }
     ```

  * This variable provides the information needed by the resolver to fetch the data. Our next task is to set up the resolver so our queries work.

* Ask the class the following questions (‚òùÔ∏è) and call on students for the answers (üôã):

  * ‚òùÔ∏è Why would we add an argument to our query?

  * üôã An argument allows us to write more specific queries. When we add an argument to our query, the argument is then passed to our resolver function. The resolver can then use that information to make a more targeted search.

* Answer any questions before proceeding to the next activity.

* In preparation for the activity, ask TAs to start directing students to the activity instructions found in `08-Stu_Query-Arguments/README.md`.

### 13. Student Do: Query Arguments (15 min)

* Direct students to the activity instructions found in `08-Stu_Query-Arguments/README.md`.

* Break your students into pairs that will work together on this activity.

    ```md
    # üìñ Create a Class Resolver to Return Individual Classes

    Work with a partner to implement the following user story:

    * As a developer, I want to be able to query for individual classes.

    ## Acceptance Criteria

    * It's done when the following GraphQL query returns a single class object:

      query class($id: ID!) {
        class(id: $id) {
          name
          professor {
            name
          }
        }
      }

    ## üìù Notes

    Refer to the documentation:

    [Apollo Docs on handling arguments](https://www.apollographql.com/docs/apollo-server/data/resolvers/#handling-arguments)

    ---

    ## üí° Hints

    * What database query would retrieve a single object?

    ## üèÜ Bonus

    If you have completed this activity, work through the following challenge with your partner to further your knowledge:

    * How do you differentiate between required and optional arguments?

    Use [Google](https://www.google.com) or another search engine to research this.
    ```

* While breaking everyone into groups, be sure to remind students and the rest of the instructional staff that questions on Slack or otherwise are welcome and will be addressed. It's a good way for your team to prioritize students who need extra help.

### 14. Instructor Review: Query Arguments (10 min)

* Ask the class the following questions (‚òùÔ∏è) and call on students for the answers (üôã):

  * ‚òùÔ∏è How comfortable do you feel with query arguments? (Poll via Fist to Five, Slack, or Zoom)

* Assure students that we will cover the solution to help solidify their understanding. If questions remain, remind them to use office hours to get extra help.

* Use the prompts and talking points (üîë) below to review the following key points:

  * ‚úîÔ∏è `args`

  * ‚úîÔ∏è `findById()`

  * ‚úîÔ∏è `populate()`

* Open `08-Stu_Query-Arguments/Solved/schemas/resolvers.js` in your IDE and explain the following:

  * When we use a query with arguments, we create an object that holds the information we need to pass to our resolver.

  * üîë To have access to that object, our resolver function uses `args`.

  * Because `args` is the second of the positional parameters that the resolver can take, we list `args` second so it keeps its place:

     ```js
     class: async (parent, args) => {
     ```

  * üîë To return the data we need, we call the method `findById()` on the `Class` model we imported to read data from the MongoDB database. The `findById()` method is a built-in method on Mongoose models that allows us to easily search for a single method by `id`. Because we want the data in the `id`, we use `args.id`:

     ```js
     return await Class.findById(args.id);
     ```

  * üîë To access the related `Professor` object, we use `populate()`:

     ```js
     return await Class.findById(args.id).populate('professor');
     ```

* Navigate to `08-Stu_Query-Arguments/Solved` in your command line and run `npm install`, `npm run seed`, and `npm start`.

* Open `localhost:3001/graphql` in your browser and demonstrate the following:

  * üîë We use the `classes` entry point to query all the `Class` objects using the field `name` and `_id`. This will give us a list of the the names and ids for all of the classes:

     ```gql
     query getAllClassIdNames {
       classes {
         name
         _id
       }
     }
     ```

  * We copy one of the ids returned:

     ```json
     "_id": "Copy_This_ID"
     ```

  * In the Query Variables pane, we give the value of the `id` variable the value of the id that we just copied, and we make sure that both `id` and the id that we just copied are surrounded by quotes:

     ```json
     {
       "id" : "Add_Copied_ID_Here"
     }
     ```

  * We enter the query using a variable into the query editor:

     ```gql
     query class($id: ID!) {
       class(id: $id) {
         name
         professor {
           name
         }
       }
     }
     ```

  * We click the play button. If our resolver is successful, both the class and professor's name will be fetched.

* Ask the class the following questions (‚òùÔ∏è) and call on students for the answers (üôã):

  * ‚òùÔ∏è How can we get more specific results using arguments?

  * üôã Arguments allow us to query for more specific data by passing information from our query to our resolver. For example, we can search for a specific `id` by passing the information about that `id` to the resolver, which then can use that information to search the database for that specific object using that data.

  * ‚òùÔ∏è Why use variables in our queries?

  * üôã Variables allow us to make our queries more durable. For example, by using a variable when searching by id, we only had to change the value of the variable to search for another object. If we didn't have variables, we would have to write a whole new query.

  * ‚òùÔ∏è What can we do if we don't completely understand this?

  * üôã We can refer to supplemental material, read the [Apollo Docs on handling arguments](https://www.apollographql.com/docs/apollo-server/data/resolvers/#handling-arguments), and stay for office hours to ask for help.

* Answer any questions before proceeding to the next activity.

### 15. Instructor Demo: Mutations (5 min)

* Open `09-Ins_Mutations/schemas/typeDefs.js` in your IDE and explain the following:

  * GraphQL does more than retrieve existing data. We can also use GraphQL to write data as well.

  * üîë The mutation type is similar to the query type. However, instead of providing an entry point to read an object or objects, the mutation type provides an entry point to write an object or objects.

  * üîë We create an entry point `addSchool` and set the object that it will write to to be a `School` object.

  * üîë We also pass in arguments that define the fields that will be written. This information will be passed to the resolver.

     ```js
       type Mutation {
         addSchool(name: String!, location: String!, studentCount: Int!): School
       }
     ```

* Open `09-Ins_Mutations/schemas/resolvers.js` in your IDE and explain the following:

  * üîë We enter the arguments that we wanted passed in as a parameter in the same order as we defined the fields in the mutation type:

     ```js
     addSchool: async (parent, { name, location, studentCount }) => {
     ```

  * üîë We call `create()` on the imported `School` model to write to our MongoDB database:

     ```js
     return await School.create({ name, location, studentCount });
     ```

* Ask the class the following questions (‚òùÔ∏è) and call on students for the answers (üôã):

  * ‚òùÔ∏è How would we build this?

  * üôã A mutation is way to write data using GraphQL. We use the mutation type to define the entry point to the data to be written and a mutation resolver to provide the functionality to write the data to our database.

* Answer any questions before proceeding to the next activity.

* In preparation for the activity, ask TAs to start directing students to the activity instructions found in `10-Stu_Mutations/README.md`.

### 16. Student Do: Mutations (15 min)

* Direct students to the activity instructions found in `10-Stu_Mutations/README.md`.

* Break your students into pairs that will work together on this activity.

     ```md
     # üêõ Class Mutation Does Not Show that Object Was Updated

     Work with a partner to resolve the following issue:

     * As a developer, I want access to updated values so the front end can be updated accordingly.

     ## Expected Behavior

     Updating a class's building number should show the new value in the returned object.

     ## Actual Behavior

     The returned object still shows the old building number.

     ## Steps to Reproduce the Problem

     Follow these steps to reproduce the problem:

     1. In the command line, navigate to `10-Stu_Mutations/Unsolved`.

     2. Run `npm install`, `npm run seed`, and `npm start`.

     3. Open <localhost:3001/graphql> in the browser.

     4. Set the following variables in the Query Variables panel:

       {
         "id": "<insert ID of a class here>",
         "building": "AA"
       }

     5. Run the following mutation:

         mutation updateClass($id: ID!, $building: String!) {
           updateClass(id: $id, building: $building) {
             name
             building
           }
         }

     6. Note that the `building` property in the returned data is not set to `"AA"`.

     ---

     ## üí° Hints

     * How else could you verify if the data is being updated correctly?

     ## üèÜ Bonus

     If you have completed this activity, work through the following challenge with your partner to further your knowledge:

     * What tools will you need to run GraphQL queries in your own front end?

     Use [Google](https://www.google.com) or another search engine to research this.
     ```

* While breaking everyone into groups, be sure to remind students and the rest of the instructional staff that questions on Slack or otherwise are welcome and will be addressed. It's a good way for your team to prioritize students who need extra help.

### 17. Instructor Review: Mutations (15 min)

* Ask the class the following questions (‚òùÔ∏è) and call on students for the answers (üôã):

  * ‚òùÔ∏è How comfortable do you feel with mutations? (Poll via Fist to Five, Slack, or Zoom)

* Assure students that we will cover the solution to help solidify their understanding. If questions remain, remind them to use office hours to get extra help.

* Use the prompts and talking points (üîë) below to review the following key points:

  * ‚úîÔ∏è `findOneAndUpdate()`

  * ‚úîÔ∏è `{new: true}`

* Open `10-Stu_Mutations/Solved/schemas/resolvers.js` in your IDE and explain the following:

  * When your mutation is not working as expected, a great place to look is the resolver.

  * We have written a mutation to update the building for a specific class. However, it looks like when we run the mutation, the building is not being updated.

  * When your mutation is not working as expected, a great place to look is the resolver.

  * Because we are using Mongoose, we must import the model to write data to MongoDB. It looks like we have imported the `Class` model successfully.

     ```js
     const { School, Class, Professor } = require('../models');
     ```

  * We also need to make sure that our arguments are passed to the resolver. It looks like this is working too:

     ```js
     updateClass: async (parent, { id, building }) => {
     ```

  * üîë To write the data, we call the `.findOneAndUpdate()` method on the imported `Class` model and pass in the specific information needed to find the class by id and update the building:

     ```js
     return await Class.findOneAndUpdate(
       { _id: id },
       { building },
     )
     ```

  * üîë By default, the object returned will not be the one updated. To return the new object, we set `new` to be `true`. Adding this line will fix the bug in our resolver:

     ```js
     { new: true }
     ```

* Navigate to `10-Stu_Mutations/Solved` in your command line and run `npm install`, `npm run seed`, and `npm start`.

* Open `localhost:3001/graphql` in your browser and demonstrate the following:

  * üîë We test if our resolver is now working by using an existing `Class` object id and adding the the provided test object to the Query Variable editor:

     ```json
       {
         "id": "<insert ID of a class here>",
         "building": "AA"
       }
       ```

  * üîë Next we run the provided mutation:

     ```gql
       mutation updateClass($id: ID!, $building: String!) {
         updateClass(id: $id, building: $building) {
           name
           building
         }
       }
     ```

  * The updated information should now be fetched.

* Ask the class the following questions (‚òùÔ∏è) and call on students for the answers (üôã):

  * ‚òùÔ∏è How can we use mutations to create and update data?

  * üôã We use the mutation type to define the entry point for the object we want to write or update. We write a mutation resolver that performs the task of creating or updating the data.

  * ‚òùÔ∏è What can we do if we don't completely understand this?

  * üôã We can refer to supplemental material, read the [Apollo Docs on mutations](https://www.apollographql.com/docs/android/essentials/mutations/#gatsby-focus-wrapper), and stay for office hours to ask for help.

* Answer any questions before ending the class.

### 18. END (0 min)

How did today‚Äôs lesson go? Your feedback is important. Please take 5 minutes to complete this [anonymous survey](https://forms.gle/RfcVyXiMmZQut6aJ6).

---
¬© 2022 edX Boot Camps LLC. Confidential and Proprietary. All Rights Reserved.
