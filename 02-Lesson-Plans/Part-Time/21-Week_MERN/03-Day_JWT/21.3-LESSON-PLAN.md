# 21.3 Weekday Lesson Plan: JSON Web Tokens (JWT)

## Overview

This class focuses on using JSON Web Tokens to add authentication to a MERN-stack application. Students will also work in groups to refactor a fully functioning MERN-stack app to use a GraphQL API built with Apollo Server and Apollo Client.

## Instructor Notes

* In this lesson, students will complete activities `11-Ins_Sign-JWT` through `28-Stu_Mini-Project`.

* It is highly recommended that prior to class, you go through each demo and activity so that you are familiar with the code and can anticipate issues that students new to token based authentication and the MERN framework may face.

* If you get an `eslint` preflight check error when running the Challenge application, add an `.env` folder to the root of the project and add `SKIP_PREFLIGHT_CHECK=true`. The error can also be avoided by running the Challenge from the class repo to avoid conflicting `eslint` installations.

* Remind students to do a `git pull` of the class repo and to have today's activities ready and open in VS Code.

* If you are comfortable doing so, live-code the solutions to the activities. If not, just use the solutions provided and follow the prompts and talking points for review.

* Let students know that the Bonus at the end of each activity is not meant to be extra coding practice, but instead is a self-study on topics beyond the scope of this module for those who want to further their knowledge.

* If the students struggle with the `Everyone Do: Git` activity, walk through it with the students using the talking points provided. Otherwise, support the students as they work on the activity and do a brief review at the end.

## Learning Objectives

By the end of class, students will be able to:

* Create and verify a JSON Web Token to log in the user.

* Store, check expiration of, and pass JSON Web Tokens to an Apollo Client.

* Implement server-side authentication in GraphQL API.

* Explain a practical use case for implementing GitHub Actions.

## Time Tracker

| Start  | #   | Activity Name                       | Duration |
| ------ | --- | ----------------------------------- | -------- |
| 0:00   | 1   | Instructor Do: Stoke Curiosity      | 0:05     |
| 0:05   | 2   | Instructor Demo: Sign JWT           | 0:05     |
| 0:10   | 3   | Student Do: Sign JWT                | 0:15     |
| 0:25   | 4   | Instructor Review: Sign JWT         | 0:10     |
| 0:35   | 5   | Instructor Demo: Decode JWT         | 0:05     |
| 0:40   | 6   | Student Do: Decode JWT              | 0:15     |
| 0:55   | 7   | Instructor Review: Decode JWT       | 0:10     |
| 1:05   | 8   | Instructor Demo: Resolver Context   | 0:05     |
| 1:10   | 9   | Student Do: Resolver Context        | 0:15     |
| 1:25   | 10  | BREAK                               | 0:10     |
| 1:35   | 11  | Instructor Review: Resolver Context | 0:10     |
| 1:45   | 12  | Everyone Do: Git                    | 0:10     |
| 1:55   | 13  | Instructor Demo: Mini Project       | 0:05     |
| 2:00   | 14  | Student Do: Mini Project            | 0:45     |
| 2:45   | 15  | Instructor Review: Mini Project     | 0:10     |
| 2:55   | 16  | Introduce Challenge                 | 0:05     |
| 3:00   | 17  | END                                 | 0:00     |

---

## Class Instruction

### 1. Instructor Do: Stoke Curiosity (5 min)

* Welcome students to class.

* Explain that as we develop more complex data-driven and user-interactive web apps, it is important to keep data security in mind.

* One way to accomplish this is to use a token to securely transmit information between parties as a JSON object. Let's take a look at the components of a JSON Web Token, or JWT.

* Open the [JSON Web Token Debugger](https://jwt.io/#debugger-io) in your browser and demonstrate the following:

  * We use a JSON Web Token to securely send signed and verified data as a JSON object. Each JWT is made up of three parts: the header, payload, and signature.

  * We use the header to hold the token's metadata. This includes the algorithm used and the token type:

    ```js
    {
      "alg": "HS256",
      "typ": "JWT"
    }
    ```

  * The second part is the payload. We use the payload to hold the JSON object containing the data we wish to transmit as well as a `iat` property, which stands for "Issued at" and describes the time the JWT was issued:

    ```js
    {
      "sub": "1234567890",
      "name": "John Doe",
      "iat": 1516239022
    }
    ```

  * Finally, we use a signature to validate that the token comes from the sender and has not been tampered with. The signature takes the encoded header and payload and then signs it using a secret, which is a key that is used to verify the token:

    ```js
    HMACSHA256(
    base64UrlEncode(header) + "." +
    base64UrlEncode(payload),
    your-256-bit-secret)
    ```

  * When we put all three parts together, we get three Base64-URL strings separated by dots that can be easily passed around to help keep our data secure:

    ```js
    eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.
    eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c
    ```

  * Explain that later during today's class, we will learn how to use a JSON Web Token to add authentication to our MERN-stack apps.

### 2. Instructor Demo: Sign JWT (5 min)

* Navigate to `21-Ins_Sign-JWT` in your command line and run `npm install`, `npm run seed`, and `npm start`.

* Open `21-Ins_Sign-JWT/utils/auth.js` in your IDE to demonstrate the following:

  * 🔑 To generate a token in our apps, we start by adding a `auth.js` file to our server's `utils` directory and requiring the `jsonwebtoken` library to provide the functionality to check the validity of the token using a `secret` and `expiration`:

    ```js
    const jwt = require('jsonwebtoken');
    ```

  * 🔑 We then assign values for both a `secret` and `expiration`. The `secret` is a private key that signs the token and enables the server to verify whether the token is valid. The `expiration` is the length of time the token remains valid before expiring:

     ```js
     const secret = 'mysecretsshhhhh';
     const expiration = '2h';
     ```

  * 🔑 Next, we add a `signToken()` function to combine the payload, secret, and string and return our token as a string:

     ```js
     signToken: function ({ email, name, _id }) {
       const payload = { email, name, _id };
       return jwt.sign({ data: payload }, secret, { expiresIn: expiration });
     },
     ```

* Open `21-Ins_Sign-JWT/schemas/resolvers.js` in your IDE to demonstrate the following:

  * 🔑 We call the `signToken()` function in the resolvers where we want to transmit data securely to generate a signed token:

    ```js
    addProfile: async (parent, { name, email, password }) => {
      const profile = await Profile.create({ name, email, password });
      const token = signToken(profile);
      return { token, profile };
    }
    ```

* Open `21-Ins_Sign-JWT/models/Profile.js` in your IDE to demonstrate the following:

  * We also need a way to handle a password in the resolvers. We start by importing `bcrypt`, a library that is used to safely store a password in the `Profile` model:

    ```js
    const bcrypt = require('bcrypt');
    ```

  * Next, we add a save hook to encrypt a password when a new profile is created:

    ```js
    profileSchema.pre('save', async function (next) {
      if (this.isNew || this.isModified('password')) {
        const saltRounds = 10;
        this.password = await bcrypt.hash(this.password, saltRounds);
      }
      next();
    });
    ```

  * We also add an `isCorrectPassword()` method that checks to determine if the correct password was provided by the user:

    ```js
    profileSchema.methods.isCorrectPassword = async function (password) {
      return bcrypt.compare(password, this.password);
    }
    ```

  * We then export the model so the functionality can be used in our resolvers to handle our passwords.

* Open `localhost:3001/graphql` in your browser and demonstrate the following:

  * Now, that we have a way to generate a token and handle a password, we also need to add definitions to our existing GraphQL schema to handle our token.

  * 🔑 When we open the `schema` tab, we see that there is an object type `auth`, that contains `token` and a `profile` field. This defines the `Auth` data we will have access to:

    ```js
    type Auth {
      token: ID!
      profile: Profile
    }
    ```

  * 🔑 We can access this `auth` object through two mutation entry points: `login` and `addProfile`. Let's use the `addProfile` entry point to add a new profile to see a generated token.

  * We write a mutation in the editor that takes in three values: name, email, and password:

    ```js
    mutation addProfile($name: String!, $email: String!, $password: String!) {
      addProfile(name: $name, email: $email, password: $password) {
        token
        profile {
          _id
        }
      }
    }
    ```

  * We then assign values to our variables in the `Query Variables` editor to replicate the user-provided data and test if our mutation works:

    ```js
    {
      "name": "sample",
      "email": "me@me.com",
      "password": "password"
    }
    ```

  * When we click the play button, we see that a signed token is stored in the `token` field.

* Open the [JSON Web Token Debugger](https://jwt.io/#debugger-io) in your browser and demonstrate the following:

  * 🔑 When we copy the generated token into the decoder, we see that the payload contains the `name` and `email` that we added, an `iat` that describes when the data was created, and the token's expiration:

    ```js
    {
      "data": {
      "email": "me@me.com",
      "name": "sample",
      "_id": "601a054d40fbcbf267a3f253"
    },
      "iat": 1612318029,
      "exp": 1612325229
    }
    ```

* The process of generating a signed token takes place in the resolver.

* Ask the class the following questions (☝️) and call on students for the answers (🙋):

  * ☝️ How do we use the `signToken()` function to generate a signed token?

  * 🙋 The `signToken()` function expects an object that contains data and will add that object's properties to a token. The `secret` and `expiration` are also added.

* Answer any questions before proceeding to the next activity.

* In preparation for the activity, ask TAs to start directing students to the activity instructions found in `22-Stu_Sign-JWT/README.md`.

### 3. Student Do: Sign JWT (15 min)

* Direct students to the activity instructions found in `22-Stu_Sign-JWT/README.md`.

* Break your students into pairs that will work together on this activity.

  ```md
  # 📐 Add Comments to Implementation of JWT Signing

  Work with a partner to add comments that describe the functionality of the code found in [resolvers.js](./Unsolved/schemas/resolvers.js).

  ---

  ## 🏆 Bonus

  If you have completed this activity, work through the following challenge with your partner to further your knowledge:

  * What are the pros and cons of using JSON Web Tokens?

  Use [Google](https://www.google.com) or another search engine to research this.
  ```

* While breaking everyone into groups, be sure to remind students and the rest of the instructional staff that questions on Slack or otherwise are welcome and will be addressed. It's a good way for your team to prioritize students who need extra help.

### 4. Instructor Review: Sign JWT (10 min)

* Ask the class the following questions (☝️) and call on students for the answers (🙋):

  * ☝️ How comfortable do you feel with creating a signed token server-side? (Poll via Fist to Five, Slack, or Zoom)

* Assure students that we will cover the solution to help solidify their understanding. If questions remain, remind them to use office hours to get extra help.

* Use the prompts and talking points (🔑) below to review the following key points:

  * ✔️ `User.create({ username, email, password })`

  * ✔️ `const token = signToken(user)`

  * ✔️ `User.findOne({ email })`

  * ✔️ `user.isCorrectPassword(password)`

* Open `22-Stu_Sign-JWT/Solved/schemas/resolvers.js` in your IDE and explain the following:

  * We import the `signToken()` method and the `User` model to access the functionality needed in our resolvers to generate a signed token and check a password:

    ```js
    const { User, Thought } = require('../models');
    const { signToken } = require('../utils/auth');
    ```

  * 🔑 We then write an `addUser` resolver and pass in `username`, `email`, and `password` as arguments. This resolver will use our imported `signToken()` method:

    ```js
    addUser: async (parent, { username, email, password }) => {
    ```

  * 🔑 We use the data passed in to create a new user in the database:

    ```js
    const user = await User.create({ username, email, password });
    ```

  * 🔑 Next, we call the `signToken()` function to generate a signed token that includes the user information as the payload. The newly created `user` and `token` are then returned:

    ```js
    const token = signToken(user);
    return { token, user };
    ```

  * 🔑 For the `login` mutation, we pass in the `email` and `password` that we want to check against an existing user:

    ```js
    login: async (parent, { email, password }) => {
    ```

  * 🔑 We use the `.findOne()` method to search the database for a matching `email`:

    ```js
    const user = await User.findOne({ email });
    ```

  * If no user is found, we return an error message indicating there is no match:

    ```js
    if (!user) {
      throw new AuthenticationError('No user found with this email address');
    }
    ```

  * 🔑 If a match is found, we use the `.isCorrectPassword()` method from the `Profile` model to check if the password is also match:

    ```js
    const correctPw = await user.isCorrectPassword(password);
    ```

  * If there is no password match, we return an error. Otherwise, we use the `signToken()` function to generate a signed token that contains the user information:

    ```js
    if (!correctPw) {
      throw new AuthenticationError('Incorrect credentials');
    }
    const token = signToken(user);
    return { token, user };
    ```

* Ask the class the following questions (☝️) and call on students for the answers (🙋):

  * ☝️ How do we update the mutation resolvers to generate a token that includes our data?

  * 🙋 We create a `signToken()` method that uses the `jsonwebtoken` library's `sign()` method to add a signature and expiration date to the data payload. Then, we import and execute the `signToken()` method in our resolvers.

  * ☝️ How do we determine if the the entered password matches an existing account?

  * 🙋 We create an `isCorrectPassword()` method that uses the `bcrypt` library's `compare` method to check if the provided password matches.  Then, we import and execute the `isCorrectPassword()` method in our resolvers.

  * ☝️ What can we do if we don't completely understand this?

  * 🙋 We can refer to supplemental material, read the [JSON Web Tokens introduction](https://jwt.io/introduction), and stay for office hours to ask for help.

* Answer any questions before proceeding to the next activity.

### 5. Instructor Demo: Decode JWT (5 min)

* Navigate to `23-Ins_Decode-JWT` in your command line and run `npm install`, `npm run seed`, and `npm start`.

* Open `23-Ins_Decode-JWT/client/src/utils/auth.js` in your IDE to demonstrate the following:

  * 🔑 When a token is returned to our front end after a user is successfully logged in, it must be stored and decoded. We import the `jwt-decode` library to decode the data a token holds as well as when it expires:

    ```js
    import decode from 'jwt-decode';
    ```

  * Next, we create a new class `AuthService` and add the functionality needed to store our token so we can easily retrieve it and include it with a request to the server:

    ```js
    class AuthService {}
    ```

  * 🔑 Inside this class, we use the `getToken` method to retrieve an existing token from local storage, if it exists:

    ```js
    getToken() {
      return localStorage.getItem('id_token');
    }
    ```

  * 🔑 We then call the `getToken` method in the `loggedIn` method to check if a token has been returned. If a user has been successfully logged in, a token will be returned from local storage. If not, no user is logged in:

    ```js
    loggedIn() {
      const token = this.getToken();
      return token ? true : false;
    }
    ```

    * 🔑 When a user logs in, we store the token in local storage. Then, when a user logs out, we remove the token. This makes sure our token is only held in storage while a user remains logged in:

    ```js
    login(idToken) {
      localStorage.setItem('id_token', idToken);
      window.location.assign('/');
    }

    logout() {
      localStorage.removeItem('id_token');
      window.location.reload();
    }
    ```

  * 🔑 We also add a `getProfile` method that decodes the retrieved token and returns a string so the expiration date and the data in the token can be used:

    ```js
    getProfile() {
      return decode(this.getToken());
    }
    ```

  * We then export our `AuthService` so we can use this functionality in our `Login` page:

    ```js
    export default new AuthService()
    ```

* Open `23-Ins_Decode-JWT/client/src/App.js` in your IDE to demonstrate the following:

  * 🔑 To authenticate requests sent to the back end while a user is logged in, we must add a header containing the token in our requests. We use the `setContext()` function from Apollo Client to do this:

    ```js
    import { setContext } from '@apollo/client/link/context';
    ```

  * 🔑 We then use the `setContext()` method to retrieve an existing token from local storage and attach the JWT token to every request sent from the client. The back end will then use this information to verify the request:

    ```js
    const authLink = setContext((_, { headers }) => {
      const token = localStorage.getItem('id_token');
      return {
        headers: {
        ...headers,
        authorization: token ? `Bearer ${token}` : '',
      },
    };
    ```

* Open `23-Ins_Decode-JWT/client/src/pages/Login.js` in your IDE to demonstrate the following:

  * Using the functionality we just added, we execute the login mutation and receive a token in return. This token is then immediately stored using our `AuthService` functionality:

    ```js
    const handleFormSubmit = async (event) => {
      event.preventDefault();
      console.log(formState);
      try {
        const { data } = await login({
          variables: { ...formState },
        });

        Auth.login(data.login.token);
          } catch (e) {
            console.error(e);
          }
    ```

* Ask the class the following questions (☝️) and call on students for the answers (🙋):

  * ☝️ What library do we use to decode the information in our token on the front end?

  * 🙋 We use the `jwt-decode` library to check what information a token holds and when it expires.

  * ☝️ How do we attach a token as a header to our front-end requests?

  * 🙋 We use the `setContext()` method to retrieve an existing token, if it exists, and attach it to our request.

* Answer any questions before proceeding to the next activity.

* In preparation for the activity, ask TAs to start directing students to the activity instructions found in `24-Stu_Decode-JWT/README.md`.

### 6. Student Do: Decode JWT (15 min)

* Direct students to the activity instructions found in `24-Stu_Decode-JWT/README.md`.

* Break your students into pairs that will work together on this activity.

  ```md
  # 🐛 User Is Immediately Logged Out of Application

  Work with a partner to resolve the following issue:

  * As a user, I want to log in to the application and remain logged in.

  ## Expected Behavior

  A user should be able to sign up or log in to their account and receive a JSON Web Token with a two-hour expiration.

  ## Actual Behavior

  The user's token is immediately deemed expired by the client-side application and is removed from localStorage, logging out the user.

  ## Steps to Reproduce the Problem

  To reproduce the problem, follow these steps:

  1. Navigate to `24-Stu_Decode-JWT/Unsolved` from the command line.

  2. Run `npm install`, `npm run seed`, and `npm run develop`.

  3. Open <localhost:3000/signup> in the browser to create a user and a session or log in as one of the seeded users at <localhost:3000/login>.

  4. When page redirects to the homepage, the user is still prompted to log in or sign up.

  ---

  ## 💡 Hints

  * Where do we store all of our client-side authentication functionality?

  * What unit of time measurement does the JSON Web Token use compared to JavaScript?

  ## 🏆 Bonus

  If you have completed this activity, work through the following challenge with your partner to further your knowledge:

  * When would you use JSON Web Tokens vs. cookies for user authentication?

  Use [Google](https://www.google.com) or another search engine to research this.
  ```

* While breaking everyone into groups, be sure to remind students and the rest of the instructional staff that questions on Slack or otherwise are welcome and will be addressed. It's a good way for your team to prioritize students who need extra help.

### 7. Instructor Review: Decode JWT (10 min)

* Ask the class the following questions (☝️) and call on students for the answers (🙋):

  * ☝️ How comfortable do you feel with decoding and using a token on the front end? (Poll via Fist to Five, Slack, or Zoom)

* Assure students that we will cover the solution to help solidify their understanding. If questions remain, remind them to use office hours to get extra help.

* Use the prompts and talking points (🔑) below to review the following key points:

  * ✔️ `jwt-decode`

  * ✔️ `const decoded = decode(token)`

  * ✔️ `Date.now() / 1000`

* Open `24-Stu_Decode-JWT/Solved/client/src/utils/auth.js` in your IDE to demonstrate the following:

  * We have a bug that is causing our token to be deemed expired. As a result, our user is getting immediately logged out.

  * 🔑 The library that we use to decode the token's expiration time is `jwt-decode`. We see that the library has been successfully imported:

    ```js
    import decode from 'jwt-decode';
    ```

  * 🔑 We also need to apply the `jwt` library's `decode()` method to our token. It looks like the expiration time, as set by the server, is being retrieved and stored in a variable `decoded`:

    ```js
    const decoded = decode(token)
    ```

  * 🔑 Next, we look at the code used to compare the expiration date to the current time. For the comparison to work, the time units we use must be the same. Because `decoded.exp` is in seconds and the `Date.now()` method returns a value in milliseconds, we divide the value that `Date.now()` returns by `1000`. Then a valid comparison can be made:

    ```js
    if (decoded.exp < Date.now() / 1000)
    ```

  * Once a valid comparison is made, the user will be prevented from immediately logging out.

    ```js
    isTokenExpired(token) {
      const decoded = decode(token);
        if (decoded.exp < Date.now() / 1000) {
         localStorage.removeItem('id_token');
         return true;
        }
      return false;
    }
    ```

* Ask the class the following questions (☝️) and call on students for the answers (🙋):

  * ☝️ How can we decode our token's expiration date and then check if the token is expired?

  * 🙋 We use the `jwt-decode` library to decode our token and return the expiration time, as set by our server. We then compare that time to the current time using `Date.now()` to see if the token is expired.

  * ☝️ What can we do if we don't completely understand this?

  * 🙋We can refer to supplemental material, read the [Apollo Docs on setContext](https://www.apollographql.com/docs/react/api/link/apollo-link-context/) and the [NPM Docs on jwt-decode](https://www.npmjs.com/package/jwt-decode), and stay for office hours to ask for help.

* Answer any questions before proceeding to the next activity.

### 8. Instructor Demo: Resolver Context (5 min)

* Open `25-Ins_Resolver-Context/server/utils/auth.js` in your IDE and demonstrate the following:

  * While we can decode our token in the front end and attach it to a request as header, we are still missing the key functionality needed to verify our token and decode it before it reaches our resolver. To do that, we will have to return to our back-end code.

  * We import the `jsonwebtoken` library in our server's `auth.js` file:

    ```js
    const jwt = require('jsonwebtoken');
    ```

  * 🔑 Then, we add a `authMiddleware` function to check if there's a token with the request and, if it exists, verify and decode the token.

  * First, we describe the way our tokens can be received:

    ```js
    let token = req.body.token || req.query.token || req.headers.authorization
    ```

  * 🔑 Next, we use the `jsonwebtoken` library's `verify()` method to check if our token is valid and return the payload data:

    ```js
    const { data } = jwt.verify(token, secret, { maxAge: expiration });
    ```

  * We then return the `req` object and supply the request -- and the needed data -- to the resolver function:

    ```js
    return req;
    ```

* Open `25-Ins_Resolver-Context/server/server.js` in your IDE and demonstrate the following:

  * 🔑 We import the `authMiddleware` function from our `auth.js` file to use it in the context of our `ApolloServer` instance:

    ```js
    const { authMiddleware } = require('./utils/auth');
    ```

  * Previously, we passed `typeDefs` and `resolvers` to our `ApolloServer` instance.  Now, we add a `context` property and set the value to `authMiddleware`. This allows the incoming requests to be verified and the data returned from the `authMiddleware()` function to be made available to our resolvers:

    ```js
    const server = new ApolloServer({
      typeDefs,
      resolvers,
      context: authMiddleware,
    })
    ```

* Open `25-Ins_Resolver-Context/server/schemas/resolvers.js` in your IDE and demonstrate the following:

  * To access the data in the context, we add a `context` parameter to our query and mutation resolvers. This will pass in the data from our token so that it can be used by the resolvers. Because parameters in resolvers are positional, the `context` parameter must always be in the third place:

    ```js
    me: async (parent, args, context) => {
      if (context.user) {
        return Profile.findOne({ _id: context.user._id });
      }
      throw new AuthenticationError('You need to be logged in!');
    },
    ```

* Ask the class the following questions (☝️) and call on students for the answers (🙋):

  * ☝️ How do we verify and decode a token before it reaches the resolver?

  * 🙋 We add a `context` option to our Apollo Server configuration and give it the value of `authMiddleware`. Then, in our `authMiddleware` method, we add the functionality needed to verify and decode our token. This will allow us to intercept any request to the server and check if there's a valid JWT before the request gets to the resolver.

* Answer any questions before proceeding to the next activity.

* In preparation for the activity, ask TAs to start directing students to the activity instructions found in `26-Stu_Resolver-Context/README.md`.

### 9. Student Do: Resolver Context (15 min)

* Direct students to the activity instructions found in `26-Stu_Resolver-Context/README.md`.

* Break your students into pairs that will work together on this activity.

  ```md
  # 🐛 Profile Page Is Not Displaying the Logged-In User's Data

  Work with a partner to resolve the following issue:

  * As a user, I want to see my own thoughts when I visit the profile page.

  ## Expected Behavior

  When a logged-in user visits the `/me` route, they should see the thoughts they created.

  ## Actual Behavior

  The profile page displays a message informing the user they must be logged in to see the content.

  ## Steps to Reproduce the Problem

  To reproduce the problem, follow these steps:

  1. Navigate to `26-Stu_Resolver-Context/Unsolved` from the command line.

  2. Run `npm install`, `npm run seed`, and `npm run develop`.

  3. Open <localhost:3000/login> in the browser.

  4. Log in with the following test credentials, or create your own user and some thoughts:

     {
       "email": "lernantino@techfriends.dev",
       "password": "password10"
     }

  5. Navigate to <localhost:3000/me>.

  6. The app does not display the thoughts from this user.

  ## Assets

  The following image demonstrates the profile page's appearance and functionality:

  ![The logged-in user's profile page displays thoughts they've created and a form to create more thoughts.](./Images/01-screenshot.png)

  ---

  ## 💡 Hints

  * What is the difference between the server-side `QUERY_ME` and `QUERY_SINGLE_USER` query resolvers that would cause one to work and the other to not work?

  ## 🏆 Bonus

  If you have completed this activity, work through the following challenge with your partner to further your knowledge:

  * How could we implement authentication in a React app without using GraphQL?

  Use [Google](https://www.google.com) or another search engine to research this.
  ```

* While breaking everyone into groups, be sure to remind students and the rest of the instructional staff that questions on Slack or otherwise are welcome and will be addressed. It's a good way for your team to prioritize students who need extra help.

### 10. BREAK (10 min)

### 11. Instructor Review: Resolver Context (10 min)

* Ask the class the following questions (☝️) and call on students for the answers (🙋):

  * ☝️ How comfortable do you feel with using context to verify tokens and decode tokens before they reach the resolvers? (Poll via Fist to Five, Slack, or Zoom)

* Assure students that we will cover the solution to help solidify their understanding. If questions remain, remind them to use office hours to get extra help.

* Use the prompts and talking points (🔑) below to review the following key points:

  * ✔️ `authMiddleware`

  * ✔️ `context: authMiddleware`

  * ✔️ `me: async (parent, args, context)`

* Open `26-Stu_Resolver-Context/Solved/server/utils/auth.js` in your IDE and explain the following:

  * We want a logged in user to see the thoughts they created, but it looks like we have a bug and the user is receiving a message that they are not logged in.

  * 🔑 Let's start by taking a looking in our server's `auth.js` file. When a request comes, we need a method to check if a token exists, and if so, verify and decode it. It looks like we have an `authMiddleware` method in place to handle this functionality and return a data object that can be used by our resolver:

    ```js
    authMiddleware: function ({ req }) {
    let token = req.body.token || req.query.token || req.headers.authorization;
      if (req.headers.authorization) {
        token = token.split(' ').pop().trim();
      }
      if (!token) {
        return req;
      }

      try {
        const { data } = jwt.verify(token, secret, { maxAge: expiration });
        req.user = data;
      } catch {
        console.log('Invalid token');
      }
      ```

* Open `26-Stu_Resolver-Context/Solved/server/server.js` in your IDE and explain the following:

  * 🔑 In our `ApolloServer` instance, we add a `context` option. The `context` holds our `authMiddleware` function and passes the data object that is returned to every resolver. This is how the user's login information that is sent by the client reaches the resolver:

    ```js
    const server = new ApolloServer({
      typeDefs,
      resolvers,
      context: authMiddleware,
    });
    ```

* Open `26-Stu_Resolver-Context/Solved/schemas/resolvers.js` in your IDE and explain the following:

  * 🔑 To use the context data, we add a `context` parameter to our resolver. Because resolvers take in positional arguments, the context must always be third. In our broken code, `context` was second, so our login data was not being added in the right place:

    ```js
    me: async (parent, args, context) => {
    ```

  * 🔑 Now that the `context` parameter is in the third position, `context` can be used to check if `user` data exists and if so, find the user by id and then populate the thoughts associated with the user:

    ```js
      if (context.user) {
        return User.findOne({ _id: context.user._id }).populate('thoughts');
      }
      throw new AuthenticationError('You need to be logged in!');
    },
    ```

* Ask the class the following questions (☝️) and call on students for the answers (🙋):

  * ☝️ How do we provide a context to a resolver?

  * 🙋 First, we add a `context` option to our `ApolloServer` instance to hold the value of a function that returns an object or an object itself. Then, to use the object in our resolver, we add `context` as the third parameter.

  * ☝️ What can we do if we don't completely understand this?

  * 🙋 We can refer to supplemental material, read the [Apollo Docs on the context argument](https://www.apollographql.com/docs/apollo-server/data/resolvers/#the-context-argument), and stay for office hours to ask for help.

* Answer any questions before proceeding to the next activity.

* In preparation for the activity, ask TAs to start directing students to the activity instructions found in `27-Evr_GitHub-Actions/README.md`.

### 12. Everyone Do: GitHub Actions (10 min)

* Open the [GitHub Docs Introduction to GitHub Actions](https://docs.github.com/en/actions/learn-github-actions/introduction-to-github-actions) in your browser and explain the following:

  * **GitHub Actions** are automated tasks or workflows that run when certain events are triggered, like pull requests. At their core, they are a series of commands that allow us to automate things like deployment, testing, and linting.

  * Using this guide, you will create a GitHub Action that automatically runs linting checks on any pull request made to the `main` or `develop` branches. Actions like this can especially benefit collaborative efforts like group projects.

* Direct students to the activity instructions found in `27-Evr_GitHub-Actions/README.md`.

* While everyone is working on the activity, be sure to remind students and the rest of the instructional staff that questions on Slack or otherwise are welcome and will be handled. It's a good way for your team to prioritize students who need extra help.

* Open your command line and demonstrate the following:

  * First we create a boilerplate React app:

    ```bash
    npx create-react-app gh-actions-demo
    ```

  * After a few minutes, the `create-react-app` utility will finish, and we move on to creating the GitHub Action.

  * 🔑 We set up the GitHub Action locally and then push it to GitHub. As a result, we still need to install dependencies locally to ensure that they are added to the `package.json` file. To do this, we change into the `gh-actions-demo` folder and run the following command:

    ```sh
    npm i eslint --save-dev
    ```

  * With `eslint` installed as a developer dependency, we add a new script to the `package.json` file that allows us to run linting checks with a single command:

    ```json
    "scripts": {
        "eslint": "eslint src"
    },
    ```

  * Next, we create a GitHub repository named `gh-actions-demo`, and we add the remote to the local repository:

    ```sh
    git remote add origin git@github.com:USERNAME/gh-actions-demo.git
    git branch -M main
    ```

  * We also add and commit all of the files and push to the remote repository:

    ```sh
    git add -A
    git commit -m "Adding existing files"
    git push -u origin main
    ```

  * We build the GitHub workflow by creating directories called `.github` and `.workflows`, with a `main.yml` file inside the `.workflows` directory.

  * Then we add the workflow to the `main.yml` file, telling GitHub which actions to execute when a specific trigger happens:

    ```yml
    #  Name of workflow
    name: Lint workflow
    # Trigger workflow on all pull requests
    on:
        pull_request:
            branches:
                - dev
                - main
    # Jobs to carry out
    jobs:
        test:
            # Operating system to run job on
            runs-on: ubuntu-latest
            # Steps in job
            steps:
                # Get code from repo
                - name: Checkout code
                  uses: actions/checkout@v1
                # Install NodeJS
                - name: Use Node.js 12.x
                  uses: actions/setup-node@v1
                  with:
                      node-version: 12.x
                # Build the app
                - name: 🧰 install deps
                  run: npm install
                - name: Run lint
                  run: npm run eslint
    ```

  * After that, we save the changes, commit all the files, and push to GitHub once again.

  * With the workflow in place in the repository, we can now create a new branch, make a pull request to `dev` or `main`, and witness the workflow in action!

* Answer any questions before students go on break.

### 13. Instructor Demo: Mini-Project (5 min)

* Navigate to `28-Stu_Mini-Project/Solved` in your command line and run `npm install`, `npm run seed`, and `npm run develop`.

* Open `localhost:3000/` in your browser and demonstrate the following:

  * 🔑 As developers, we are often asked to take an existing, functional app and update it to incorporate a new technology. Our task is to convert the app from using an existing RESTful API to an app that uses a GraphQL API built with Apollo Server and Apollo Client.

  * 🔑 When we open the homepage `localhost:3000/` route, we see a list of technologies.

  * 🔑 When we navigate to `localhost:3000/matchup`, we are presented with a form for the user to input matchup choices.

  * 🔑 When we click on the `Create Matchups` pages, we navigate to a new page at `localhost:3000/matchup/<id>`. That page shows only the information for our new matchup.

* Ask the class the following questions (☝️) and call on students for the answers (🙋):

  * ☝️ How would we build this?

  * 🙋 We use Apollo Client to set up our React.js front end to send requests and Apollo Server on the back end to create a GraphQL API.

* Answer any questions before allowing students to start the mini-project.

### 14. Student Do: Mini-Project (45 min)

* Direct students to the activity instructions found in `28-Stu_Mini-Project/README.md`.

* Break your students into groups that will work together on this activity.

  ```md
  # Module 21 Mini-Project: Tech Matchup App

  In this mini-project, you are given a fully functioning MERN-stack application that allows users to create a matchup between two technologies and vote on their favorite technology. The application currently uses a RESTful API. You will need to refactor it to use a GraphQL API built with Apollo Server and Apollo Client. You will also use React Router's `<Route>` component in the routes. During your research, you will likely come across examples and documentation on React Router's `<Switch>` component. As of React Router version 6, the `<Switch>` component no longer exists and will cause your application to break.

  ## User Stories

  Work with your group to resolve the following issues:

  * As a user, I want to see a list of matchups.

  * As a user, I want to be able to create a matchup between two technologies.

  * As a user, I want to be able to vote for one of the two technologies in the matchup.

  * As a user, I want to see the current number of votes for each technology in the matchup.

  * As a user, if I reach a page that doesn't exist, I want to see a 404 page.

  ## Acceptance Criteria

  The mini-project is complete when the following criteria are met:

  * The `/` homepage route renders a list of technologies.

  * The `/matchup` route renders a form to choose two technologies to create a matchup.

  * The `/matchup/:id` route renders a matchup to vote on.

  * An Apollo Server is set up to use GraphQL queries and mutations to fetch and modify data, replacing the existing RESTful API.

  * Apollo Client is set up so that requests can communicate with an Apollo Server.

  * A 404 page `NotFound` is rendered if the user tries to access a page that doesn't exist.

  ---

  ## 💡 Hints

  * After implementing GraphQL on the server, what tool can you use to test the queries and mutations?

  * How can we use `<Route>` to render the `NotFound` page?

  ## 🏆 Bonus

  If you have completed this activity, work through the following challenge with your partner to further your knowledge:

  * Incorporate user authentication so that only logged-in users can create and vote on matchups.
  ```

* While breaking everyone into groups, be sure to remind students and the rest of the instructional staff that questions on Slack or otherwise are welcome and will be addressed. It's a good way for your team to prioritize students who need extra help.

### 15. Instructor Review: Mini-Project (10 min)

* Ask the class the following questions (☝️) and call on students for the answers (🙋):

  * ☝️ How comfortable do you feel with this mini-project? (Poll via Fist to Five, Slack, or Zoom)

* Assure students that we will cover the solution to help solidify their understanding. If questions remain, remind them to use office hours to get extra help.

* If students ran into examples or documentation on React Router's `<Switch>` component, explain to them that it was previously used in place of the current `<Routes>` component. When we previously used `<Switch>`, the first -- and only the first -- match of a route would be rendered. However, with React Router v6, the `<Routes>` component was introduced and behaves much like `<Switch>` but looks for routes that best match instead of traversing routes in order.

* Use the prompts and talking points (🔑) below to review the following key points:

  * ✔️ `const server = new ApolloServer()`

  * ✔️ `typeDefs`

  * ✔️ `resolvers`

  * ✔️ `ApolloClient`

  * ✔️ `ApolloProvider`

  * ✔️ `useQuery()`

  * ✔️ `useMutation()`

  * ✔️ `<Route>`

* Open `28-Stu_Mini-Project/Main/server/server.js` in your IDE and explain the following:

  * We add the `ApolloServer` class to the `server.js` file. We also import the `schemas` directory which holds our `typeDef` and `resolver` files:

    ```js
    const { ApolloServer } = require('apollo-server-express');
    const { typeDefs, resolvers } = require('./schemas');
    ```

  * 🔑 Next, we create a new instance of the `ApolloServer` class, which gives us access to the core functionality needed to implement our GraphQL API. We also pass in our `typeDefs` and `resolvers`, which are used to define the shape of our data and the functionality needed to retrieve it:

    ```js
    const server = new ApolloServer({
      typeDefs,
      resolvers,
    });
    ```

* Open `28-Stu_Mini-Project/Main/server/schemas/typeDefs.js` in your IDE and explain the following:

  * To define our data, we import `gql` from `apollo-server-express` and create a variable called `typeDefs`:

    ```js
    const { gql } = require('apollo-server-express');
    const typeDefs = gql
    ```

  * 🔑 Then, we add our type definitions. An object type is used to define an object that the client may need to interact with, such as a `Matchup`:

    ```js
    type Matchup {
      _id: ID!
      tech1: String!
      tech2: String!
      tech1_votes: Int
      tech2_votes: Int
    }
    ```

  * 🔑 We use a Query type to define the entry point for our data. The `Tech` query provides an entry point for an array of all the Tech objects. The `matchup` entry point uses an argument to point to a single matchup object:

    ```js
    type Query {
      tech: [Tech]
      matchups(_id: String): [Matchup]
    }
    ```

  * 🔑 We use a mutation type to provide an entry point to modify our data. The `createMatchup` mutation creates a new `Matchup` object. The `createVote` mutation modifies the vote count on an existing `Matchup` object:

    ```js
    type Mutation {
      createMatchup(tech1: String!, tech2: String!): Matchup
      createVote(_id: String!, techNum: Int!): Matchup
    }
    ```

* Open `28-Stu_Mini-Project/Main/server/schemas/resolvers.js` in your IDE and explain the following:

  * To write the functions needed to populate our data, we first import our existing models:

     ```js
     const { Tech, Matchup } = require('../models');
     ```

  * 🔑 Then, we use the models to read and write data from our MongoDB database. For each query or mutation to work, we must write an associated function:

    ```js
    tech: async () => {
      return Tech.find({});
    }
    ```

* Open `28-Stu_Mini-Project/Main/client/src/App.js` in your IDE and explain the following:

  * Now that we have the GraphQL API set up on our back end, we can use `Apollo Client` to provide the front-end functionality needed to send requests and handle returned data.

  * 🔑 We start by importing the `ApolloClient` and `InMemoryCache` classes from `apollo/client` as well as the `ApolloProvider` component:

    ```js
    import { ApolloClient, ApolloProvider, InMemoryCache } from '@apollo/client';
    ```

  * 🔑 This will create a new instance of the `ApolloClient` class. This will give us the key functionality that we need to interact with our GraphQL API:

    ```js
    const client = new ApolloClient({
      uri: '/graphql',
      cache: new InMemoryCache(),
      );
    ```

  * 🔑 We then wrap the `ApolloProvider` component around our app so that we can access the functionality we need in our components:

    ```js
    <ApolloProvider client={client}>
    ...
    </ApolloProvider>
    ```

* Open `28-Stu_Mini-Project/Main/client/src/utils/queries.js` in your IDE and explain the following:

  * 🔑 We write a query in the GraphQL query language. To work with our hooks, we then wrap our query with a `gql` function and export it:

    ```js
    export const QUERY_TECH = gql`
      query tech {
      tech {
        _id
        name
      }
    }
    `;
    ```

* Open `28-Stu_Mini-Project/Main/client/src/utils/mutations.js` in your IDE and explain the following:

  * We follow the same process to write and export our mutations, making sure our entry point and fields match our schema exactly and that a variable is declared to hold data that we will need to pass back to our mutation:

    ```js
    export const CREATE_MATCHUP = gql`
      mutation createMatchup($tech1: String!, $tech2: String!) {
      createMatchup(tech1: $tech1, tech2: $tech2) {
        _id
        tech1
        tech2
      }
    }
    `;
    ```

* Open `28-Stu_Mini-Project/Main/client/src/pages/Matchup.js` in your IDE and explain the following:

  * 🔑 In the component where we want the query and mutation to execute, we import the query and mutation as well as the `useQuery()` and `useMutation` hooks:

    ```js
    import { useMutation, useQuery } from '@apollo/client';
    import { QUERY_TECH } from '../utils/queries';
    import { CREATE_MATCHUP } from '../utils/mutations';
    ```

  * 🔑 We apply the `useQuery()` hook to the query. This will execute the query when the page renders, and return a JSON object that can be used to populate the page:

    ```js
    const { loading, data } = useQuery(QUERY_TECH);
    ```

  * 🔑 When we apply the `useMutation()` hook to the imported mutation, it does not execute right away. Instead, it returns a mutation function that we can apply in our code:

    ```js
    const [createMatchup, { error }] = useMutation(CREATE_MATCHUP);
    ```

  * 🔑 We apply the `createMatchup` mutation function inside the form submit handler to fire when the button is clicked and the form is submitted. When the mutation is executed, a JSON object is returned:

    ```js
    const { data } = await createMatchup({
        variables: { ...formData },
      });
    ```

* Open `28-Stu_Mini-Project/Main/client/src/App.js` in your IDE and explain the following:

  * 🔑 Remember to use a `<Routes>` component to wrap all of our routes. This is how to nest our routes properly:

    ```js
    <Routes>
      <Route
        path="/">
        element={<Home />}
      />
      <Route
        path="/matchup">
        element={<Matchup />}
      />
      <Route
        path="/matchup/:id">
        element={<Vote />}
      />
      <Route
        path="*"
        element={<NotFound />}
      />
    </Routes>
    ```

* Ask the class the following questions (☝️) and call on students for the answers (🙋):

  * ☝️ How do we use hooks to retrieve and modify data from our GraphQL API?

  * 🙋 We use the `useQuery()` and `useMutation()` hooks to send requests to our GraphQL API and handle the returned data. The data is returned in a JSON object, which can then be used to display information on our page.

  * ☝️ What can we do if we don't completely understand this?

  * 🙋 We can refer to supplemental material, read the [Apollo Docs on Apollo Client](https://www.apollographql.com/docs/react/why-apollo/), the [Apollo Docs on Apollo Server](https://www.apollographql.com/docs/apollo-server/), and the [React Router Docs](https://reactrouter.com/docs/en/v6/getting-started/overview) and stay for office hours to ask for help.

* Answer any questions before proceeding to the next activity.

### 16. Instructor Demo: Introduce Challenge (5 min)

* Navigate to `02-Challenge/Main` in your command line and run `npm install` and `npm run develop`.

* **Note** If you get an `eslint` preflight check error when running the Challenge application, add an `.env` folder to the root of the project and add `SKIP_PREFLIGHT_CHECK=true`. You can also avoid the error by running the Challenge from the class repo, to avoid conflicting `eslint` installations.

* Open `localhost:3000` in your browser and demonstrate the following:

  * For this week's Challenge, we are taking an existing book search engine that was built using a RESTful API and refactor it to use a GraphQL API.

  * When the app loads, we are presented with an option to "Search for Books" as well as an option to "SignUp/Login".

  * When we enter a word and click on the search button, a list of related books is returned, including the book’s title, author, description, image, and a link to that book on the Google Books site.

  * If we are logged in when we execute a search, we are also presented with an option to save the book to our account.

  * This app is a great way to practice the skills to build a secure, data-driven site that provides a personalized account for each user.

* Ask the class the following questions (☝️) and call on students for the answers (🙋):

  * ☝️ What are we learning?

  * 🙋 We are learning to implement a GraphQL API in a full-stack MERN app.

  * ☝️ How does this project build on or extend previously learned material?

  * 🙋 We will use `Apollo Server` to set up our back end and `Apollo Client` to set up our front end to send requests. We will also write queries and mutations using the GraphQL query language, and use JWT to provide user authentication.

  * ☝️ How does this project relate to your career goals?

  * 🙋 Most modern apps require developers to handle user input and store data. Increasingly, apps are also personalized, with each user having access to their own data stored in accounts. This Challenge is an opportunity to practice the fundamental skills of implementing a GraphQL API in a full-stack MERN app and using authentication to personalize the experience for each user.

* Ask TAs to direct students to the Challenge Requirements found in `02-Challenge/README.md`.

* Answer any questions before ending the class.

### 17. END (0 min)

How did today’s lesson go? Your feedback is important. Please take 5 minutes to complete this [anonymous survey](https://forms.gle/RfcVyXiMmZQut6aJ6).

---
© 2022 edX Boot Camps LLC. Confidential and Proprietary. All Rights Reserved.
