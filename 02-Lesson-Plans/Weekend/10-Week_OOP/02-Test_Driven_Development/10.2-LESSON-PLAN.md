# 10.2 Part-Time Lesson Plan: Test-Driven Development

## Overview

Today's lesson will introduce students to test-driven development, unit tests, and mock data.

## Instructor Notes

* In this lesson, students will complete activities `11-Ins_TDD` through `20-Stu_Mock-Fs`.

* To refresh your memory of some of the specific methods often used by testing frameworks, consider creating a few failing tests before class&mdash;then write the code to make them pass. You might also benefit from installing the [Jest Snippets](https://marketplace.visualstudio.com/items?itemName=andys8.jest-snippets) plugin for VS Code.

* Remind students to do a `git pull` of the class repo to have today's activities ready and open in VS Code.

* If you are comfortable doing so, live-code the solutions to the activities. If not, just use the solutions provided and follow the prompts and talking points for review.

* Let students know that the Bonus at the end of each activity is not meant to be extra coding practice, but instead is a self-study on topics beyond the scope of this module for those who want to further their knowledge.

## Learning Objectives

By the end of class, students will be able to:

* Explain the benefits of test-driven development (TDD).

* Define code requirements for code that hasn't been written yet by using unit tests.

* Write unit tests for preexisting JavaScript functions.

* Test side effects like reading or writing to the file system, printing to the console, and AJAX requests by using mocks.

* Structure test code using the Arrange, Act, Assert pattern.

## Time Tracker

| Start  | #   | Activity Name                       | Duration |
| ------ | --- | ----------------------------------- | -------- |
| 6:30PM | 1   | Instructor Do: Stoke Curiosity      | 0:10     |
| 6:40PM | 2   | Instructor Demo: TDD                | 0:05     |
| 6:45PM | 3   | Student Do: TDD                     | 0:15     |
| 7:00PM | 4   | Instructor Review: TDD              | 0:10     |
| 7:10PM | 5   | Instructor Demo: Pass Tests         | 0:05     |
| 7:15PM | 6   | Student Do: Pass Tests              | 0:15     |
| 7:30PM | 7   | Instructor Review: Pass Tests       | 0:10     |
| 7:40PM | 8   | Instructor Demo: Organizing Tests   | 0:05     |
| 7:45PM | 9   | Student Do: Organizing Tests        | 0:15     |
| 8:00PM | 10  | BREAK                               | 0:15     |
| 8:15PM | 11  | Instructor Review: Organizing Tests | 0:10     |
| 8:25PM | 12  | Instructor Demo: Mocks              | 0:05     |
| 8:30PM | 13  | Student Do: Mocks                   | 0:15     |
| 8:45PM | 14  | Instructor Review: Mocks            | 0:10     |
| 8:55PM | 15  | Instructor Demo: Mock fs            | 0:05     |
| 9:00PM | 16  | Student Do: Mock fs                 | 0:15     |
| 9:15PM | 17  | Instructor Review: Mock fs          | 0:15     |
| 9:30PM | 18  | END                                 | 0:00     |

> **Important**: If this lesson occurs on a Saturday, make sure to adjust the activities to accommodate for the extra hour of class time. Feel free to take your time as you go through the activities; for example, you can add 5 minutes to the `Student Do` and `Instructor Review` sections as you see fit. Remember to take a 40-minute break at noon!

---

## Class Instruction

### 1. Instructor Do: Stoke Curiosity (10 min)

* Welcome students to class.

* Explain to students that **test-driven development (TDD)** is a process and a methodology. Review the following TDD terms:

  * **Unit tests** ensure reliability and validate the expected behavior of things like functions or classes. Unit tests verify that the unit being tested returns the expected output.

  * **Integration tests** ensure the cooperation of units in your application. Integration tests might focus on an API, user input, or a user interface, which could involve subsequent actions like writing to a database or logging output.

  * **End-to-end tests** verify that the application will function as expected from the perspective of a user. These tests usually focus almost entirely on an application's user interface.

* Explain that in this class, we will create tests before we write code, because that is the core tenet of TDD. How we write the code is dictated by the need to make each test pass, setting up a contract-like expectation for ourselves and other developers and keeping the development process focused.

* We will focus first on the basic TDD workflow and eventually expand on each step, but for now we just need to know the following steps:

  * Write a failing test.

  * Make the test pass.

  * Refactor the implementation.

### 2. Instructor Demo: TDD (5 min)

* Open `11-Ins_TDD/package.json` in your IDE and demonstrate the following:

  * We have included `jest` as a dependency in `package.json` and have also included a special test script defined with a value of `jest`, as shown in the following example:

    ```json
    "scripts": {
      "test": "jest"
    },
    ...
      "devDependencies": {
      "jest": "^26.5.2"
    }
    ```

* Run `npm install` and  `npm run test` from the command line to demonstrate the following:

  * üîë When we run the test, it checks in `package.json` for a script with the key `test`. As we just noted, the test script is defined with a value of `jest`.

  * üîë When `jest` is invoked, it will look for files that match a specific pattern (`[filename].test.js`). It will find the one and only test in the `/tests` directory and run it.

  * We can see that everything is passing; now let's examine the actual tests.

* Open `11-Ins_TDD/tests/arithmetic.test.js` in your IDE and demonstrate the following:

  * We have created a `/tests/` folder and an `arithmetic.test.js` file that contains tests for `arithmetic.js`.
  
  * Notice the naming convention for the actual test files: `<filename_prefix>.test.js`

  * At the top of the file, we are importing an object called `Arithmetic` that connects the tests to `arithmetic.js`, as follows:

    ```js
    const Arithmetic = require('./arithmetic');
    ```
  
  * In the first test, we start with a `describe` statement that contains several other `describe` statements. The parent `describe` statement groups together the related tests for different methods, which also improves readability. See the following code for an example:

    ```js
    describe("Arithmetic", () => {
      describe("Initialization", () => {
      ...
      });
      describe("plus", () => {
      ...
      });
      describe("minus", () => {
      ...
      });
      describe("value", () => {
        ...
      });
    });
    ```

  * The `it` portion of this test describes how the function should behave in a successful test case. For example, the first `it` statement indicates that initialization `"should return an object containing a 'number' property when called with the 'new' keyword"`.

  * We then create a new instance of `Arithmetic` and test values using the `expect()` and `toEqual()` methods. In the following example, we are testing whether the key `number` has a truthy value in the newly created object:

    ```js
    describe("Arithmetic", () => {
      describe("Initialization", () => {
        it("should return an object containing a 'number' property when called with the 'new' keyword", () => {
        const obj = new Arithmetic();
        expect("number" in obj).toEqual(true);
    });
    ```

  * The other tests under the parent `describe` statement are formatted in the same way, but they test other methods in `arithmetic.js` called `plus()`, `minus()`, and `value()`.

  * If we right-click on the word `Arithmetic` at the top of the `arithmetic.js` file and select "Go to definition", we will be brought to the file that declares all the methods for which we saw tests in `arithmetic.test.js`.

  * üîë Remember, in a typical TDD cycle, we would write tests first and then write the code that we see here to help the tests pass.

  * The following example shows all of the methods that appeared in the tests in `arithmetic.test.js`:

    ```js
    function Arithmetic(number = 0) {
      this.number = number;
    }

    Arithmetic.prototype.plus = function(num = 0) {
      const newNumber = this.number + num;

      return new Arithmetic(newNumber);
    };

    Arithmetic.prototype.minus = function(num = 0) {
      const newNumber = this.number - num;

      return new Arithmetic(newNumber);
    };

    Arithmetic.prototype.value = function() {
      return this.number;
    };
    ```

    * Remember, the first test expected `number` to be initialized with a value, and that is what the function `Arithmetic()` appears to accomplish, as follows:

      ```js
      function Arithmetic(number = 0) {
        this.number = number;
      }
      ```
  
  * Before we check whether the tests are working, let's examine `index.js`.

* Open `11-Ins_TDD/index.js` in your IDE and explain the following:

  * We see that `index.js` is importing `arithmetic.js` at the top of the file just like in `arithmetic.test.js`, as shown in the following example:

    ```js
    const Arithmetic = require('./arithmetic');
    ```

  * In `index.js`, the methods that were declared in `arithmetic.js` are chained together, performing specific operations one by one and finally logging the value&mdash;as shown in the following example:

    ```js
    const value = new Arithmetic(4)
      .plus(8)
      .plus(15)
      .minus(16)
      .minus(23)
      .plus(42)
      .plus(108)
      .value();

    console.log(value);
    ```

  * If we run `node index.js`, we see the value `138` logged in the console.
  
  * üîë Now that we understand how the tests are written, let's run the tests, as follows:

      ```bash
      npm run test
      ```
  
  * We should see the output in the command line from the testing framework, `jest`. All the passing tests will appear in green, and all failing tests will appear in red.

* Ask the class the following questions (‚òùÔ∏è) and call on students for the answers (üôã):

  * ‚òùÔ∏è How would we build this?

  * üôã We would first build the tests, then create the code to make the tests pass.

  * ‚òùÔ∏è What is the significance of the `expect()`, `it()`, and `toEqual()` methods in the testing framework?

  * üôã These methods each tell the testing framework what output to expect from the functions. You can learn more about how to use these by reading the [Jest documentation on methods](https://jestjs.io/docs/en/expect#expectvalue).

* Answer any questions before proceeding to the next activity.

* In preparation for the activity, ask TAs to start directing students to the activity instructions found in `12-Stu_TDD/README.md`.

### 3. Student Do: TDD (15 min)

* Direct students to the activity instructions found in `12-Stu_TDD/README.md`.

* Break your students into pairs that will work together on this activity.

  ```md
  # üìñ Write Tests for Algorithms

  Work with a partner to implement the following user story:

  * As a developer, I want to create tests to define the expectations for algorithms that haven't been implemented yet. 

  ## Acceptance Criteria

  * It's done when the `reverse()` test expects the string `"Hello World!"` to become `"!dlroW olleH"` after calling `new Algo().reverse()`.

  * It's done when the `isPalindrome()` test expects the string `"racecar"` to return `true` and the string `"neon"` to return `false` after calling `new Algo().isPalindrome()`.

  * It's done when the `capitalize()` test expects the string `"capitalize every first word of the string."` to become `"Capitalize Every First Word Of The String."` after calling `new Algo().capitalize()`.

  * It's done when the tests fail, because no code should be added to the `algo.js` file to fulfill the tests yet.

  ## üìù Notes

  Refer to the documentation: 

  [Jest API documentation](https://jestjs.io/docs/en/api)

  ---

  ## üí° Hints

  How can we use the `describe()`, `it()`, and `expect()` functions in Jest to check for expected behavior?

  ## üèÜ Bonus

  If you have completed this activity, work through the following challenge with your partner to further your knowledge:

  * Where can you find examples of well-written tests? 

  Use [Google](https://www.google.com) or another search engine to research this.
  ```

* While breaking everyone into groups, be sure to remind students and the rest of the instructional staff that questions on Slack or otherwise are welcome and will be handled. It's a good way for your team to prioritize students who need extra help.

### 4. Instructor Review: TDD (10 min)

* Ask the class the following questions (‚òùÔ∏è) and call on students for the answers (üôã):

  * ‚òùÔ∏è How comfortable do you feel with TDD? (Poll via Fist to Five, Slack, or Zoom)

* Assure students that we will cover the solution to help solidify their understanding. If questions remain, remind them to use office hours to get extra help!

* Use the prompts and talking points (üîë) below to review the following key points:

  * ‚úîÔ∏è `describe()`

  * ‚úîÔ∏è `it()`

  * ‚úîÔ∏è `expect()`

  * ‚úîÔ∏è `toEqual()`

* Open `12-Stu_TDD/Solved/test/algo.test.js` in your IDE and explain the following:

  * First we run `require()` for the file that contains the functions we want to test, as shown in the following example:

    ```js
    const Algo = require("../algo");
    ```

  * üîë The tests are wrapped in a parent `describe()` function for `Algo`, as follows:

    ```js
    describe("Algo", () => {
      ...
    }
    ```

  * üîë Now we can build tests for specific functionality, starting with `reverse()`. The `it()` method allows us to describe what the function should do in plain language.

  * Next, we define `str` as the starting string, `reversed` as `str` backwards, and `result` as the actual result of the `reverse()` function.

  * üîë Finally, we pass `result` as an argument into `expect()` and compare it to the value of `reversed` using the `toEqual()` method&mdash;meaning that we expect the value of `result` to equal the value of `reversed`! See the following code for an example:

    ```js
    describe("reverse", () => {
      it("should reverse a given string", () => {
        const str = "Hello World!";
        const reversed = "!dlroW olleH";

        const result = new Algo().reverse(str);

        expect(result).toEqual(reversed);
      });
    });
    ```

  * In each case, we're checking what the method returns given a certain input. We set up the same testing for `isPalindrome()` and `capitalize()`.
  
  * üîë The `describe()` statement for `isPalindrome()` contains two tests because we needed to use `it()` twice&mdash;once to test that `isPalindrome()` returns true when a string is a palindrome and once to return false when it isn't, as shown in the following example:

    ```js
    describe("isPalindrome", () => {
      it("should return true if a string is a palindrome", () => {
        const str = "racecar";

        const result = new Algo().isPalindrome(str);

        expect(result).toEqual(true);
      });

      it("should return false if a string is not a palindrome", () => {
        const str = "neon";

        const result = new Algo().isPalindrome(str);

        expect(result).toEqual(false);
      });
    ```

  * We follow the same format for the test for `capitalize()`. Notice again how Jest allows us to write readable, intuitive tests, as shown in the following example:

    ```js
    describe("capitalize", () => {
      it("should take a string and return a new string with the first letter of each word capitalized", () => {
        const str = "capitalize every first word of the string.";
        const capitalized = "Capitalize Every First Word Of The String.";

        const result = new Algo().capitalize(str);

        expect(result).toEqual(capitalized);
      });
    });
    ```

* Ask the class the following questions (‚òùÔ∏è) and call on students for the answers (üôã):

  * ‚òùÔ∏è When should we use the `describe()` method?

  * üôã When we have several related tests that we want to group together.

  * ‚òùÔ∏è What is the TDD cycle?

  * üôã First we write tests that describe how the code should work. Then we write code, run tests, debug the code, and repeat this part of the process until the tests pass.

* Answer any questions before proceeding to the next activity.

### 5. Instructor Demo: Pass Tests (5 min)

* Open `13-Ins_Pass-Tests/tests/fizz.test.js` in your IDE and demonstrate the following:

  * We are importing `fizz.js`, so the tests in this file should correspond to the code in `fizz.js`.

  * Just like in the previous activity, we have a group of tests bundled in a `describe()` method, as follows:

    ```js
    const fizzBuzz = require('../fizz');
  
      describe('fizzBuzz', () => {
        ...
      }
    ```

  * The first test indicates that if a number in a given array is not a multiple of three or five, that number will be returned, as shown in the following code:

    ```js
      it('should return the number if not a multiple of three or five', () => {
      expect(fizzBuzz([1])).toBe('1');
      expect(fizzBuzz([1, 2])).toBe('1, 2');
    });
    ```

  * The second and third tests indicate that if a number in a given array is a multiple of three or five, the strings `Fizz` and `Buzz` should be returned, respectively.

  * The fourth test indicates that if a number is a factor of both three and five, the string `FizzBuzz` should be returned.

  * Finally, all of the tests expect the final result to be returned as a string, as follows:

    ```js
    it('should return Fizz if multiple of 3', () => {
      expect(fizzBuzz([3])).toBe('Fizz');
      expect(fizzBuzz([3, 6, 12])).toBe('Fizz, Fizz, Fizz');
    });

    it('should return Buzz if multiple of 5', () => {
      expect(fizzBuzz([10])).toBe('Buzz');
      expect(fizzBuzz([10, 20, 25])).toBe('Buzz, Buzz, Buzz');
    });

    it('should return FizzBuzz if a multiple of both 3 and 5', () => {
      expect(fizzBuzz([15])).toBe('FizzBuzz');
      expect(fizzBuzz([15, 30, 45])).toBe('FizzBuzz, FizzBuzz, FizzBuzz');
    });
    ```

  * üîë Now we need to write the code that will make these tests pass!

* Open `13-Ins_Pass-Tests/fizz.js` in your IDE and demonstrate the following:

  * Based on the code in `fizz.js`, `fizzBuzz` will map over an array of numbers provided as an argument and examine each of them individually, using the variable `singleNum`.

  * Next we check whether `singleNum` is divisible by three and five and set the Boolean result as the value of the variables `multipleOf3` and `multipleOf5`, as shown in the following example:

    ```js
    num.map((singleNum) => {
        const multipleOf3 = singleNum % 3 === 0;
        const multipleOf5 = singleNum % 5 === 0;
    ```

  * Then we see a string of `if` statements that use `multipleOf3` and `multipleOf5` as conditions.

  * üîë The first conditional checks whether the number is divisible by three and five. It will return `fizzBuzz` if the condition is truthy&mdash;passing the fourth test in `fizz.test.js`, as shown in the following example:

    ```js
    if (multipleOf3 && multipleOf5) {
      return 'FizzBuzz';
    }
    ```

  * üîë The second conditional checks whether the number is divisible by three. It will return `Fizz` if the condition is truthy&mdash;passing the second test in `fizz.test.js`, as shown in the following example:
  
    ```js
    if (multipleOf3) {
      return 'Fizz';
    }
    ```

  * üîë The third conditional checks whether the number is divisible by three. It will return `Buzz` if the condition is truthy&mdash;passing the third test in `fizz.test.js`, as shown in the following example:
  
    ```js
    if (multipleOf5) {
      return 'Buzz';
    }
    ```

  * üîë If none of the conditions are met, `singleNumber` is returned&mdash;passing the first test in `fizz.test.js`, as shown in the following example:
  
    ```js
    return singleNumber
    ```

  * üîë Remember, the tests expected the results to be returned as a string, but doesn't `map()` return a new array? That's where `join()` comes in, as shown in the following example:

    ```js
    const fizzBuzz = (num) =>

      num.map((singleNum) => {
        ...
        return singleNum;
      })
      .join(', ');
    ```

* Run `npm install` and  `npm run test` from the command line and note the following:

  * As expected, all of the tests are passing.

* Ask the class the following questions (‚òùÔ∏è) and call on students for the answers (üôã):

  * ‚òùÔ∏è How would we build this?

  * üôã Use the tests that we have written (or that are provided for us) to guide us as we write the code.

* Answer any questions before proceeding to the next activity.

* In preparation for the activity, ask TAs to start directing students to the activity instructions found in `14-Stu_Pass-Tests/README.md`

### 6. Student Do: Pass Tests (15 min)

* Direct students to the activity instructions found in `14-Stu_Pass-Tests/README.md`.

* Break your students into pairs that will work together on this activity.

  ```md
  # üèóÔ∏è Implement Code to Pass Tests

  Work with a partner to implement the following user story:

  * As a developer, I want to write code that will pass my tests.

  ## Acceptance Criteria

  * It's done when I have written code for the function in `algo.js`.

  * It's done when I can run `npm run test` in the command line before I move on, to verify that I correctly implemented each method.

  * It's done when the tests in `tests/algo.test.js` pass.

  ---

  ## üí° Hints

  What clues can we glean from `tests/algo.test.js` about how to write the function?

  ## üèÜ Bonus

  If you have completed this activity, work through the following challenge with your partner to further your knowledge:

  * How are ATDD and BDD similar to or different from TDD?

  Use [Google](https://www.google.com) or another search engine to research this.
  ```

* While breaking everyone into groups, be sure to remind students and the rest of the instructional staff that questions on Slack or otherwise are welcome and will be handled. It's a good way for your team to prioritize students who need extra help.

### 7. Instructor Review: Pass Tests (10 min)

* Ask the class the following questions (‚òùÔ∏è) and call on students for the answers (üôã):

  * ‚òùÔ∏è How comfortable do you feel with writing code to pass tests? (Poll via Fist to Five, Slack, or Zoom)

* Assure students that we will cover the solution to help solidify their understanding. If questions remain, remind them to use office hours to get extra help!

* Use the prompts and talking points (üîë) below to review the following key points:

  * ‚úîÔ∏è TDD cycle

  * ‚úîÔ∏è `algo.test.js`

  * ‚úîÔ∏è `npm run test`

* Open `14-Stu_Pass-Tests/Solved/test/algo.test.js` in your IDE and explain the following:

  * üîë We will follow the TDD cycle and review the tests to determine what we need to build.
  
  * üîë The first test in `algo.test.js` should look familiar. We need to build a function called `reverse()` that takes in a string as an argument, reverses it, and returns the reversed string, as follows:

    ```js
    describe("reverse", () => {
      it("should reverse a given string", () => {
        const str = "Hello World!";
        const reversed = "!dlroW olleH";
        const result = new Algo().reverse(str);
        expect(result).toEqual(reversed);
      });
    });
    ```

* Open `14-Stu_Pass-Tests/Solved/algo.js` in your IDE and explain the following:

  * Inside the `reverse()` function, we write code that returns `str` with a chain of functions attached. First we convert `str` into an array of substrings using `split("")`. Then we call `reverse()` to reverse the order of the array. Finally, we call `join("")` to convert the array back into a string&mdash;as shown in the following example:

    ```js
    Algo.prototype.reverse = function(str) {
      return str
        .split("")
        .reverse()
        .join("");
    };
    ```

* Run `npm run test` in the console and demonstrate the following:

  * üîë Success! When we run `npm run test`, `reverse()` passes the test, as shown in the following example:

    ```console
    Algo
      reverse
        ‚úì should reverse a given string (2ms)
    ```

* Open `14-Stu_Pass-Tests/Solved/test/algo.test.js` in your IDE and explain the following:

  * üîë  Let's repeat the TDD cycle with the second test. `isPalindrome()` includes two tests that we need to pass. The first verifies that it `"should return true if a string is a palindrome"` and the second verifies that it `"should return false if a string is not a palindrome"`. See the following code for an example:

    ```js
    describe("isPalindrome", () => {
      it("should return true if a string is a palindrome", () => {
        const str = "racecar";
        const result = new Algo().isPalindrome(str);
        expect(result).toEqual(true);
      });

      it("should return false if a string is not a palindrome", () => {
        const str = "neon";
        const result = new Algo().isPalindrome(str);
        expect(result).toEqual(false);
      });
    });
    ```

* Open `14-Stu_Pass-Tests/Solved/algo.js` in your IDE and explain the following:

  * Inside the `isPalindrome()` function, we use `reverse()` as a helper function to check whether `str` is the same when it is reversed&mdash;otherwise known as a palindrome&mdash;as shown in the following example:

    ```js
    Algo.prototype.isPalindrome = function(str) {
      return this.reverse(str) === str;
    };
    ```

* Run `npm run test` in the console and demonstrate the following:

  * üîë When we run `npm run test`, `isPalindrome()` passes both tests, as follows:

    ```console
    isPalindrome
      ‚úì should return true if a string is a palindrome
      ‚úì should return false if a string is not a palindrome
    ```

* Open `14-Stu_Pass-Tests/Solved/test/algo.test.js` in your IDE and explain the following:

  * üîë Let's repeat the TDD cycle one last time, with the third and final test. `capitalize()` includes one test that we need to pass, verifying that it `"should take a string and return a new string with the first letter of each word capitalized"`, as follows:

    ```js
    describe("capitalize", () => {
      it("should take a string and return a new string with the first letter of each word capitalized", () => {
        const str = "capitalize every first word of the string.";
        const capitalized = "Capitalize Every First Word Of The String.";
        const result = new Algo().capitalize(str);
      expect(result).toEqual(capitalized);
      });
    });
    ```

* Open `14-Stu_Pass-Tests/Solved/algo.js` in your IDE and explain the following:

  * Inside the `capitalize()` function, we convert the string to an array using `split()`, then we map over the array and capitalize the first letter of each word. Finally, we convert the array back into a string using `join()`, as follows:

    ```js
    Algo.prototype.capitalize = function(str) {
      return str.split(" ").map(word => {
      return word.substring(0, 1).toUpperCase() + word.substring(1);
      }).join(" ");
    };
    ```

* Run `npm run test` in the console and demonstrate the following:

  * üîë All of the tests now pass when we run `npm run test`, including `capitalize()`, as shown in the following example:

    ```console
    PASS  test/algo.test.js
      Algo
        reverse
          ‚úì should reverse a given string (2ms) isPalindrome
          ‚úì should return true if a string is a palindrome
          ‚úì should return false if a string is not a palindrome capitalize
          ‚úì should take a string and return a new string with the first letter of each word capitalized (1ms)

    Test Suites: 1 passed, 1 total
    Tests:       4 passed, 4 total
    Snapshots:   0 total
    Time:        1.362s
    Ran all test suites.
    ```

* Ask the class the following questions (‚òùÔ∏è) and call on students for the answers (üôã):

  * ‚òùÔ∏è What is the benefit of writing tests before we write any code?

  * üôã This approach helps us ensure that the code will work. It also helps us code more quickly because we do not have to manually test the code.

  * ‚òùÔ∏è What can we do if we don't completely understand this?

  * üôã We can refer to supplemental material, read the [Jest API documentation](https://jestjs.io/docs/en/getting-started), and stick around for office hours to ask for help.

* Answer any questions before proceeding to the next activity.

### 8. Instructor Demo: Organizing Tests (5 min)

* Open `15-Ins_Organizing-Tests/test/todo.test.js` in your IDE and demonstrate the following:

  * üîë When writing tests, it is helpful to refer to a specific structure for organizing tests and deciding what to test for.

  * üîë The Arrange, Act, Assert pattern shown in the following example provides a guide for organizing test code in a way that makes sense to us and others:

    ```js
    it("should create an object with a 'text' property set to the 'text' argument provided when called with the 'new' keyword", () => {
      // Arrange
      const text = "Pick up milk";

      // Act
      const obj = new Todo(text);

      // Assert
      expect(obj.text).toEqual(text);
    });
    ```

  * üîë The tests are split into the following three parts:

    * **Arrange:** Set up anything you need to run your test.

    * **Act:** Perform the action to be tested.

    * **Assert:** Perform the assertion.

* Open `15-Ins_Organizing-Tests/test/todoList.test.js` in your IDE and explain the following:

  * üîë Consider the following kinds of tests as you decide what to test for:
  
    * **Positive tests** check whether an application behaves as expected with correct inputs.

    * **Negative tests** check whether an application behaves as expected, with invalid or improper inputs, to ensure that the application can handle invalid data gracefully.

    * **Exception tests** check that the application behaves as expected when provided abnormal input.

  * üîë This file contains a few positive tests, which we run to ensure that things work as intended in likely situations, as shown in the following example:

    ```js
    it("should add a new 'Todo' object to its 'todos' array", () => {
      // Arrange
      const todoList = new TodoList();
      const todoText = "Mow Lawn";

      // Act
      todoList.addTodo(todoText);

      // Assert
      expect(todoList.todos.length).toEqual(1);
      expect(todoList.todos[0] instanceof Todo).toEqual(true);
      expect(todoList.todos[0].text).toEqual(todoText);
    });
    ```

  * üîë We run negative tests, as shown in the following example, to check that things work in edge cases or cases where the function should return a negative result:

    ```js
    it("should return undefined if there are no todos", () => {
      // Arrange
      const todoList = new TodoList();
      let nextTodo;

      // Act
      nextTodo = todoList.getNextTodo();

      // Assert
      expect(typeof nextTodo).toEqual("undefined");
    });
    ```

  * üîë We run exception tests, as follows, to ensure that the code throws errors when it should:

    ```js
    it("should throw an error if not provided text", () => {
      // Arrange
      const todoList = new TodoList();
      const err = new Error(
        "Expected parameter 'text' to be a non empty string"
      );
      const cb = () => todoList.addTodo();

      // Assert
      expect(cb).toThrowError(err);
    });
    ```

  * Not every function will have positive, negative, and exception tests, but considering all three types of test can help us decide what to test for.

* Ask the class the following questions (‚òùÔ∏è) and call on students for the answers (üôã):

  * ‚òùÔ∏è How would we build this?

  * üôã We can use the Arrange, Act, Assert pattern as a guide for organizing test code in a way that makes sense to us and others.

  * ‚òùÔ∏è How do we know what to test for?

  * üôã By considering positive, negative, and exception tests.

* Answer any questions before proceeding to the next activity.

* In preparation for the activity, ask TAs to start directing students to the activity instructions found in `16-Stu_Organizing-Tests/README.md`.

### 9. Student Do: Organizing Tests (15 min)

* Direct students to the activity instructions found in `16-Stu_Organizing-Tests/README.md`.

* Break your students into pairs that will work together on this activity.

  ```md
  # üìê Add Comments to Implementation of an Arrange, Act, Assert Pattern

  Work with a partner to add comments describing the functionality of the code found in [Unsolved/test](./Unsolved/test).

  ## üìù Notes

  Refer to the documentation:

  [Jest API documentation](https://jestjs.io/docs/en/getting-started)

  ---

  ## üèÜ Bonus

  If you have completed this activity, work through the following challenge with your partner to further your knowledge:

  * How can you write these tests to ensure that another developer testing your code can understand what the tests are checking? 

  Use [Google](https://www.google.com) or another search engine to research this.
  ```

* While breaking everyone into groups, be sure to remind students and the rest of the instructional staff that questions on Slack or otherwise are welcome and will be handled. It's a good way for your team to prioritize students who need extra help.

### 10. BREAK (15 min)

### 11. Instructor Review: Organizing Tests (10 min)

* Ask the class the following questions (‚òùÔ∏è) and call on students for the answers (üôã):

  * ‚òùÔ∏è How comfortable do you feel organizing tests? (Poll via Fist to Five, Slack, or Zoom)

* Assure students that we will cover the solution to help solidify their understanding. If questions remain, remind them to use office hours to get extra help!

* Use the prompts and talking points (üîë) below to review the following key points:

  * ‚úîÔ∏è Arrange, Act, Assert

  * ‚úîÔ∏è Positive, negative, and exception tests

  * ‚úîÔ∏è `it(should ...)`

* Open `16-Stu_Organizing-Tests/Solved/test/dayCare.test.js` in your IDE and explain the following:

  * üîë By using the Arrange, Act, Assert pattern, we can organize the tests into three straightforward parts, as follows:

    ```js
    it("should add a child to the 'children' array", () => {
      // arrange
      const child = new Child("Tammy", 1);
      const dayCare = new DayCare();

      // act
      dayCare.addChild(child);

      // assert
      expect(dayCare.children.length).toEqual(1);
      expect(dayCare.children[0]).toBe(child);
    });
    ```

  * üîë We check that an error was thrown using the `toThrowError()` or `toThrow()` matcher. We wrap the code that will throw the error in a callback function so that Jest will suppress the error, as shown in the following example:

    ```js
    it("should throw an error if not provided a Child object as an argument", () => {
      const err = new Error(
        "Expected parameter 'child' to be an instance of Child"
      );
      const cb = () => {
        const dayCare = new DayCare();
        dayCare.addChild();
      };

      expect(cb).toThrowError(err);
    });
    ```

  * üîë We use negative tests to ensure that things work as expected in edge cases, as shown in the following example:

    ```js
    it("should not add a child if already at capacity", () => {
      const dayCare = new DayCare();
      const child = new Child("Alice", 4);
      dayCare.children = [
        new Child("Tammy", 1),
        new Child("Mark", 2),
        new Child("Alvin", 1)
      ];

      dayCare.addChild(child);

      expect(dayCare.children.length).toEqual(3);
    });
    ```

* Ask the class the following questions (‚òùÔ∏è) and call on students for the answers (üôã):

  * ‚òùÔ∏è Why is it helpful for a function to intentionally throw an error?

  * üôã If we throw a helpful error message when a function is misused, the issue is easier to track down and resolve before it causes more errors elsewhere.

* Answer any questions before proceeding to the next activity.

### 12. Instructor Demo: Mocks (5 min)

* Open `17-Ins_Introduce_Mocks/logger.js` in your IDE and demonstrate the following:

* Run `node index.js` from the command line and demonstrate the following:

  * üîë When we run the index file, each line of the output displays a color.

  * To print different colors to the console, we have to include special codes for each color as a first argument to the `console.log()` method, as shown in the following example:

    ```js
    function Logger() {
      if (!this.init) {
        Logger.prototype.init = true;
        const colors = {
          black: "\x1b[30m",
          red: "\x1b[31m",
          green: "\x1b[32m",
          yellow: "\x1b[33m",
          blue: "\x1b[34m",
          magenta: "\x1b[35m",
          cyan: "\x1b[36m",
          white: "\x1b[37m"
        };
    ```

  * Rather than manually write a method for each color, we use a loop that only runs the first time that a `Logger` object is created with the constructor&mdash;this is called a **dynamic prototype pattern**. See the following code for an example:

    ```js
    for (let key in colors) {
      Logger.prototype[key] = function(...args) {
        console.log(colors[key], ...args);
      };
    }
    ```

* Open `17-Ins_Introduce-Mocks/index.js` to point out the following:

  * First we import a `Logger` constructor that creates an object capable of logging to the console in different colors. When we run the application in the command-line window, the dynamic output resembles the following example:

    ```js
    const Logger = require("./logger");

    const log = new Logger();

    log.red("We can write to the console in different colors!");

    log.blue("We just need to provide an additional argument to the console.log method!");

    log.magenta("The first argument console.log needs is an 'ANSI Escape Code'");

    log.green("You can look these up at https://en.wikipedia.org/wiki/ANSI_escape_code#Colors");

    log.yellow("But they're just codes that represent different colors");

    log.cyan("The second argument console.log should receive is the message to be printed");
    ```

* Open `17-Ins_Introduce-Mocks/test/logger.test.js` file in your IDE and explain the following:

  * üîë In this file, we use the `jest.spyOn()` method to mock and spy on the `console.log()` method. We also use the `mock.mockImplementation()` method to replace the functionality of `console.log()` with an empty function that does nothing, as follows:

    ```js
    it("should print in black", () => {
      const log = new Logger();
      const message = "Hello world!";
      const mock = jest.spyOn(console, "log");
      mock.mockImplementation(() => {});

      log.black(message);

      expect(mock).toBeCalledWith(colors.black, message);

      mock.mockRestore();
    });
    ```

  * üîë Because we are mocking the `console.log()` method, nothing will be printed to the console when the test is run, and we can spy on values provided to the `console.log()` method. When `log.black()` is called, we can verify that `console.log()` was also called with the expected message and color.

* Finally, run `npm install` and `npm run test` to show the console log output from the tests.

* Ask the class the following questions (‚òùÔ∏è) and call on students for the answers (üôã):
  
  * ‚òùÔ∏è Why might it be complicated to test something like a `fetch()` request being called?

  * üôã The results of a `fetch()` request rely on something outside of the code that we can't always control. Reading and writing to the file system can be complicated because the tests might make changes that could impact the results of future tests.

* Answer any questions before proceeding to the next activity.

* In preparation for the activity, ask TAs to start directing students to the activity instructions found in `18-Stu_First-Mock/README.md`.

### 13. Student Do: Mocks (15 min)

* Direct students to the activity instructions found in `18-Stu_First-Mock/README.md`.

* Break your students into pairs that will work together on this activity.

  ```md
  # üêõ Running npm run test Results in Errors

  Work with a partner to resolve the following issues:

  * As a developer, I would like to spy on the output of the `console.log()` method in `dayCare.test.js`.

  ## Expected Behavior

  * When we run `npm run test` in the console, we should not receive an error.

  * When we run `npm run test` in the console, the tests for `dayCare.test.js` should be passing.

  ## Actual Behavior

  * When we run `npm run test` in the console, we receive the following error: `"Cannot spyOn on a primitive value; undefined given"`.

  * When we run `npm run test` in the console, the tests for `dayCare.test.js` are not passing.

  ## Steps to Reproduce the Problem

  1. Navigate to the `Unsolved` folder in this activity.

  2. Run `npm install` in your console.

  3. Run `npm run test` in your console.

  ## Assets

  The following image demonstrates the web application's appearance and functionality:

  ![The console indicates that the test suites and tests have passed, with no messages or errors displayed.](./images/pass-test.png)

  ---

  ## üí° Hints

  What does the error tell you about what is missing, and how do we capture the value of `console.log`?

  ## üèÜ Bonus

  If you have completed this activity, work through the following challenge with your partner to further your knowledge:

  * What are two or three other methods that can be used in conjunction with `spyOn`?

  Use the [Jest API documentation on spyOn()](https://jestjs.io/docs/en/jest-object#jestspyonobject-methodname) to research this.
  ```

* While breaking everyone into groups, be sure to remind students and the rest of the instructional staff that questions on Slack or otherwise are welcome and will be handled. It's a good way for your team to prioritize students who need extra help.

### 14. Instructor Review: Mocks (10 min)

* Ask the class the following questions (‚òùÔ∏è) and call on students for the answers (üôã):

  * ‚òùÔ∏è How comfortable do you feel with using the `spyOn()` methods? (Poll via Fist to Five, Slack, or Zoom)

* Assure students that we will cover the solution to help solidify their understanding. If questions remain, remind them to use office hours to get extra help!

* Use the prompts and talking points (üîë) below to review the following key points:

  * ‚úîÔ∏è `jest.spyOn()`

  * ‚úîÔ∏è `mock.mockImplementation()`

* Open `18-Stu_First-Mock/Solved/test/dayCare.test.js` in your IDE and explain the following:

  * üîë Using `jest.spyOn()`, we pass in the arguments `console` and `"log"` to spy on the `console.log()` method.
  
  * üîë We pass in an empty function to `mock.mockImplementation()` to replace the functionality of the `console.log()` method.

  * Now we can use `expect(mock).toBeCalledWith()` to verify that it was called with the arguments that we expect, as shown in the following example:

    ```js
    const mock = jest.spyOn(console, "log");
    mock.mockImplementation(() => {});

    dayCare.addChild(child);

    expect(dayCare.children.length).toEqual(0);
    expect(mock).toBeCalledWith(
      "Unable to add child, they are over the age limit"
    );
    ```

  * We will clean up any mocks we run at the end of a test to ensure that the next test is not affected. We can "unmock" `console.log()` by using the `mock.mockRestore()` method, as shown in the following example:

    ```js
    mock.mockRestore();
    ```

* Ask the class the following questions (‚òùÔ∏è) and call on students for the answers (üôã):

  * ‚òùÔ∏è What can we use mocks for?

  * üôã We can use mocks to replace code with side effects, like printing to the console, making `fetch()` requests, and reading or writing to the file system&mdash;so that these things do not happen when tests are being run.

  * ‚òùÔ∏è What can we do if we don't completely understand this?

  * üôã We can refer to supplemental material, read the [Jest API documentation on spyOn()](https://jestjs.io/docs/en/jest-object#jestspyonobject-methodname), and stick around for office hours to ask for help.

* Answer any questions before proceeding to the next activity.

### 15. Instructor Demo: Mock fs (5 min)

* Open `19-Ins_Module-Mock-Demo/movieSearch.js` in your IDE and demonstrate the following:

  * üîë This file exports a `MovieSearch()` constructor that can create an object used for searching the OMDB (Open Movie Database) API, as follows:

    ```js
    const axios = require("axios");

    function MovieSearch() {}

    MovieSearch.prototype.buildUrl = function(movie) {
      return `https://www.omdbapi.com/?t=${movie}&apikey=trilogy`;
    };

    MovieSearch.prototype.search = function(movie) {
      return axios.get(this.buildUrl(movie));
    };
    ```

* Open `19-Ins_Module-Mock-Demo/test/movieSearch.test.js` in your IDE and demonstrate the following:

  * üîë We require `axios` and mock it because we want to prevent actual API requests from happening. This is one way to mock a Node.js module. See the following code for an example:

    ```js
    const axios = require("axios");
    const MovieSearch = require("../movieSearch");

    jest.mock("axios");
    ```

  * üîë We mock the return value of `axios.get` to be a new Promise object that resolves to an object containing a `data` property set to an empty object. We mock the return value to this, as shown in the following example, because it is similar to what we would get from the response from the OMDB API:

    ```js
    it("should search the OMDB API for a given movie", () => {
      const movie = new MovieSearch();
      const name = "Rocky";

      axios.get.mockReturnValue(
        new Promise(function(resolve) {
          resolve({ data: {} });
        })
      );

      expect(movie.search(name)).resolves.toEqual({ data: {} });
      expect(axios.get).lastCalledWith(movie.buildUrl(name));
    });
    ```

* Ask the class the following questions (‚òùÔ∏è) and call on students for the answers (üôã):

  * ‚òùÔ∏è How would we build this?

  * üôã We would first test the API call to OMDB in something like Insomnia to ensure that we understand what the mock should return and how to behave. Then we would import the package we need and wrap it using the `jest.mock()` method. Finally, we would mock the return value of a Promise by using `mockReturnValue()`.

* Answer any questions before proceeding to the next activity.

* In preparation for the activity, ask TAs to start directing students to the activity instructions found in `20-Stu_Mock-Fs/README.md`.

### 16. Student Do: Mock fs (15 min)

* Direct students to the activity instructions found in `20-Stu_Mock-Fs/README.md`.

* Break your students into pairs that will work together on this activity.

  ```md
  # üèóÔ∏è Mock and Spy on fs Module

  Work with a partner to implement the following user story:

  * As a developer, I want to be able to spy on the `fs` module methods and ensure that they are called with the correct arguments.

  ## Acceptance Criteria

  * It's done when I have added code to mock the `fs.readFileSync()` method in `Unsolved/tests/fileIO/test.js` to emulate reading the file system.

  * It's done when I have added code to mock the `fs.writeFileSync()` method in `Unsolved/tests/fileIO/test.js` to emulate writing to the file system.

  ---

  ## üí° Hints

  How can we use the previous demonstration to aid in mocking Node.js modules?

  ## üèÜ Bonus

  If you have completed this activity, work through the following challenge with your partner to further your knowledge:

  * How might we be able to mock the append functionality of the `fs` module?

  Use [Google](https://www.google.com) or another search engine to research this.
  ```

* While breaking everyone into groups, be sure to remind students and the rest of the instructional staff that questions on Slack or otherwise are welcome and will be handled. It's a good way for your team to prioritize students who need extra help.

### 17. Instructor Review: Mock fs (15 min)

* Ask the class the following questions (‚òùÔ∏è) and call on students for the answers (üôã):

  * ‚òùÔ∏è How comfortable do you feel with mocking and spying on modules? (Poll via Fist to Five, Slack, or Zoom)

* Assure students that we will cover the solution to help solidify their understanding. If questions remain, remind them to use office hours to get extra help!

* Use the prompts and talking points (üîë) below to review the following key points:

  * ‚úîÔ∏è Mocking Node.js modules

  * ‚úîÔ∏è Avoiding writes to the file system

* Open `20-Stu_Mock-Fs/Solved/test/fileIO.test.js` file in your editor and point out the following key points:

  * üîë We mock the `fs` module by requiring it and using the `jest.mock()` method at the top of the file, as follows:

    ```js
    const fs = require("fs");
    const FileIO = require("../fileIO");

    jest.mock("fs");
    ```

  * üîë Because `fileIO.read` returns the result of `fs.readFileSync`, we can mock its return value and verify that it was called with the expected arguments without actually making a trip to the file system, as shown in the following example:

    ```js
    it("should call fs.readFileSync with the passed in 'file' argument", () => {
      const fileIO = new FileIO();
      const file = "message.txt";
      let data;

      fs.readFileSync.mockReturnValue("Hello World!");
      data = fileIO.read(file);

      expect(data).toEqual("Hello World!");
      expect(fs.readFileSync).lastCalledWith(file, "utf8");
    });
    ```

  * üîë When testing the `fileIO.write` method, we just need to know that the `fs.writeFileSync` method was called with the correct arguments. We are not testing that the `fs` module works, only that it's being used as expected. See the following code for an example:

    ```js
    it("should call fs.writeFileSync with the passed in 'path' and 'data' arguments", () => {
      const fileIO = new FileIO();
      const path = "message.txt";
      const data = "Hello World!";
    
      fileIO.write(path, data);

      expect(fs.writeFileSync).lastCalledWith(path, data);
    });
    ```

* Ask the class the following questions (‚òùÔ∏è) and call on students for the answers (üôã):

  * ‚òùÔ∏è What sort of complications can we avoid by mocking the `fs` module?

  * üôã We can avoid requiring the tests to read and write to the file system. This would not only slow tests but also possibly influence how the next test runs.

  * ‚òùÔ∏è What can we do if we don't completely understand this?

  * üôã We can refer to supplemental material, read the [Jest API documentation on spyOn()](https://jestjs.io/docs/en/jest-object#jestspyonobject-methodname), and stick around for office hours to ask for help.

* Answer any questions before ending the class.

### 18. END (0 min)

How did today‚Äôs lesson go? Your feedback is important. Please take 5 minutes to complete this [anonymous survey](https://forms.gle/RfcVyXiMmZQut6aJ6).

---
¬© 2022 edX Boot Camps LLC. Confidential and Proprietary. All Rights Reserved.
