# 11.2 Part-Time Lesson Plan: POST Requests and Persistent Data

## Overview

In today's class, students will learn how to test their APIs using Insomnia. They will also create POST routes on the back end and corresponding `fetch()` requests on the front end. Students will learn how to use middleware to parse JSON in their applications and how to implement persistent storage for the back end.

## Instructor Notes

* In this lesson, students will complete activities `11-Ins_Insomnia` through `20-Stu_Data-Persistence`.

* At the beginning of class, post the link to the [Insomnia download page](https://insomnia.rest/download) in Slack. Instruct students to download and install Insomnia if they have not yet done so.

* Each activity will require spinning up a new Express.js server. Students might encounter a common error with the code `EADDRINUSE`, due to the port being used. They can easily fix this error by running one of the following commands based on their operating system:

  * Mac:

    ```bash
    killall node
    ```

  * Windows:

    ```bash
    taskkill /im node.exe
    ```

* Today's activities also cover persistent storage. Module 12 covers databases, so for now we will store data using the Node.js `fs` module and JSON files. To accomplish this, some activities include helper functions in a `/helpers` directory.

* Remind students to do a `git pull` of the class repo to have today's activities ready and open in VS Code.

* If you are comfortable doing so, live-code the solutions to the activities. If not, just use the solutions provided and follow the prompts and talking points for review.

* Let students know that the Bonus at the end of each activity is not meant to be extra coding practice, but instead is a self-study on topics beyond the scope of this module for those who want to further their knowledge.

## Learning Objectives

By the end of class, students will be able to:

* Perform HTTP requests using Insomnia.

* Configure an Express.js app to handle POST requests.

* Implement Express.js middleware to be able to read data from a POST request.

* Implement client-side POST requests to submit form data to a server.

* Read and write to a JSON text file.

## Time Tracker

| Start  | #   | Activity Name                       | Duration |
| ------ | --- | ----------------------------------- | -------- |
| 6:30PM | 1   | Instructor Do: Stoke Curiosity      | 0:10     |
| 6:40PM | 2   | Instructor Demo: Insomnia           | 0:05     |
| 6:45PM | 3   | Student Do: Insomnia                | 0:15     |
| 7:00PM | 4   | Instructor Review: Insomnia         | 0:10     |
| 7:10PM | 5   | Instructor Demo: POST Requests      | 0:05     |
| 7:15PM | 6   | Student Do: POST Requests           | 0:15     |
| 7:30PM | 7   | Instructor Review: POST Requests    | 0:10     |
| 7:40PM | 8   | Instructor Demo: Body Parsing       | 0:05     |
| 7:45PM | 9   | Student Do: Body Parsing            | 0:15     |
| 8:00PM | 10  | BREAK                               | 0:15     |
| 8:15PM | 11  | Instructor Review: Body Parsing     | 0:10     |
| 8:25PM | 12  | Instructor Demo: POST Fetch         | 0:05     |
| 8:30PM | 13  | Student Do: POST Fetch              | 0:15     |
| 8:45PM | 14  | Instructor Review: POST Fetch       | 0:10     |
| 8:55PM | 15  | Instructor Demo: Data Persistence   | 0:05     |
| 9:00PM | 16  | Student Do: Data Persistence        | 0:15     |
| 9:15PM | 17  | Instructor Review: Data Persistence | 0:15     |
| 9:30PM | 18  | END                                 | 0:00     |

> **Important**: If this lesson occurs on a Saturday, make sure to adjust the activities to accommodate for the extra hour of class time. Feel free to take your time as you go through the activities; for example, you can add 5 minutes to the `Student Do` and `Instructor Review` sections as you see fit. Remember to take a 40-minute break at noon!

---

## Class Instruction

### 1. Instructor Do: Stoke Curiosity (10 min)

* Welcome students to class.

* Today we will explore POST requests and routes. Using the prompts provided, discuss the importance of being able to update data on the server.

* Ask the class the following questions (☝️) and call on students for the answers (🙋):

  * ☝️ What kind of data might we need to update in a web application?

  * 🙋 We might need to update anything that lives in the database. Specific examples include updating a blog post, creating a review for a movie, submitting login information, and more.

  * ☝️ What applications do you use daily that make POST requests to function properly?

  * 🙋 Some applications, including Canvas, rely on POST requests for logging in and submitting Challenges.

  * ☝️ Why is data persistence important in full-stack applications?

  * 🙋 Data persistence prevents the application from losing user data when the user leaves the page. It also helps to reassure users that their work won't be lost.

  * ☝️ How will learning how to create POST routes and requests contribute to your success in this course and in your future career?

  * ☝️ POST routes and requests make up some of the core functionality of modern web applications. Knowing how to create POST routes and make POST requests will make you a more competitive job applicant!

### 2. Instructor Demo: Insomnia (5 min)

* Open `11-Ins_Insomnia/README.md` in your IDE to demonstrate the following:

  * This activity demonstrates using Insomnia to make a GET request to the GitHub API.

  * Open Insomnia on your machine or download it locally (if you haven't already) by visiting the [Insomnia download page](https://insomnia.rest/download).

  * Refer to the `11-Ins_Insomnia/README.md` file for instructions and talking points.

    ```md
    # Insomnia Demo

    * Open Insomnia and click the plus sign (+), then click New Request. You can also do this using the keyboard shortcut Command+N (Mac) or Ctrl+N (Windows).

    * In the Insomnia interface, change the HTTP method to GET and input the endpoint for GitHub: `https://api.github.com/repos/microsoft/vscode/pulls?state=open`

    * Let's review the different parts of this URI.

    * In this example, we are making a GET request to GitHub's API to access pull requests that are currently open.

      | Protocol |    base URL    | endpoint | :organization | :repository | :resource | query string |
      | :------- | :------------: | -------: | ------------: | ----------: | --------: | -----------: |
      | https    | api.github.com |    repos |     microsoft |      vscode |     pulls |   state=open |

      > **Note**: You might want to show students this [visual aid](./Images/00-endpoint.png) in the `Images` folder for this activity.

    * Click Send in the Insomnia interface. Note that the results appear on the left side of the app.

    * The response will contain an array of objects that we could map through, which would be handy if we wanted to create some HTML elements for each open pull request.

    * Change the word `pulls` to `issues` in the URI to demonstrate that we can access other resources with GitHub's API. Every possible resource is outlined in the [GitHub Docs on REST](https://docs.github.com/en/rest/reference).
    ```

* Ask the class the following questions (☝️) and call on students for the answers (🙋):

  * ☝️ What is the benefit of using something like Insomnia instead of a front end?

  * 🙋 In most cases, you will find yourself building your API before you have created the front end. Insomnia allows you to execute POST requests and provide a request body without using the Fetch API to do so.

* Answer any questions before proceeding to the next activity.

* In preparation for the activity, ask TAs to start directing students to the activity instructions found in `12-Stu_Insomnia/README.md`.

### 3. Student Do: Insomnia (15 min)

* Direct students to the activity instructions found in `12-Stu_Insomnia/README.md`.

* Break your students into pairs that will work together on this activity.

  ```md
  # 🏗️ Query Express.js App Using Insomnia

  Work with a partner to implement the following user story:

  * As a developer, I want to use Insomnia to test endpoints that I created using Express.js, to debug my API.

  ## Acceptance Criteria

  * It's done when I have required the `db.json` file in the server.js file.

  * It's done when I have created a variable called `app` in the server.js file that is an instance of the Express.js app.

  * It's done when I have created a `GET` route for `/api` that will return the content of our json file.

  * It's done when I have tested my endpoint by performing a `GET` request to `/api` using Insomnia.

  ---

  ## 💡 Hints

  Do we need to pass a request body to the server when we are using query parameters?

  How can the [GitHub Docs on pulls](https://docs.github.com/en/rest/reference/pulls) help us with usage?

  ## 🏆 Bonus

  If you have completed this activity, work through the following challenge with your partner to further your knowledge:

  * How can you save multiple request URLs in Insomnia?

  Use [Google](https://www.google.com) or another search engine to research this.
  ```

* While breaking everyone into groups, be sure to remind students and the rest of the instructional staff that questions on Slack or otherwise are welcome and will be handled. It's a good way for your team to prioritize students who need extra help.

### 4. Instructor Review: Insomnia (10 min)

* Ask the class the following questions (☝️) and call on students for the answers (🙋):

  * ☝️ How comfortable do you feel testing endpoints using Insomnia? (Poll via Fist to Five, Slack, or Zoom)

* Assure students that we will cover the solution to help solidify their understanding. If questions remain, remind them to use office hours to get extra help!

* Use the prompts and talking points (🔑) below to review the following key points:

  * ✔️ Insomnia

  * ✔️ Creating new requests

* Open `12-Stu_Insomnia/Solved/server.js` in your IDE and explain the following:

  * 🔑 This activity doesn't have a database, so first we need to import the JSON file that contains some data that we can use with the endpoint.

  * The JSON file contains sample data that you would receive from GitHub's API:

    ```js
    const pulls = require('./db/repos.json');
    ```

  * 🔑 Next we need to create an app variable set to the value of the Express.js function:

    ```js
    const app = express();
    ```

  * For this activity, we need to create a GET route that will send back the entire contents from the JSON file. To do this, we use `app.get()` and `res.json()`:

    ```js
    app.get('/api', (req, res) => res.json(pulls));
    ```

  * Finally, we need to set up the Express.js server to listen for requests. To do this, we use `app.listen()`:

    ```js
    app.listen(3001, () => console.log('Express Server on port 3001!'));
    ```

  * Now that we have the Express.js server code ready, let's start the server and make a request using Insomnia.

* Navigate to `12-Stu_Insomnia/Solved/server.js` in your command line and run `npm install` and `npm start`.

  * In Insomnia, create a new GET request by selecting it from the list of HTTP methods, and enter `http://localhost:3001/api`.

  * Ensure that we receive a response from the server and note the status code at the top of the response pane.

* Open the [MDN Web Docs on HTTP response status codes](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status) in your browser to demonstrate the following:

  * We received a 200 response code in Insomnia. These status codes correspond to the HTTP response codes outlined in the HTTP protocol.

  * Successful responses usually fall between 200 and 299.

* Ask the class the following questions (☝️) and call on students for the answers (🙋):

  * ☝️ How can Insomnia help us debug routes?

  * 🙋 When we create the back end for an application, Insomnia allows us to make repeated requests to the server to ensure that the code works.

  * ☝️ What can we do if we don't completely understand this?

  * 🙋 We can refer to supplemental material, read the [Insomnia documentation on getting started](https://support.insomnia.rest/article/11-getting-started), and stay for office hours to ask for help.

* Answer any questions before proceeding to the next activity.

### 5. Instructor Demo: POST Requests (5 min)

* Navigate to `13-Ins_POST-Requests/server.js` in your command line and run `npm install` and `npm start`.

* Open Insomnia, create a new POST request to `http://localhost:3001/api/reviews`, and demonstrate the following:

  * 🔑 This demo shows how we can set up POST routes for the Express.js server. To begin, let's open Insomnia and create a new POST request to the endpoint `http://localhost:3001/api/reviews`.

  * 🔑 After making a request to the endpoint, we receive a simple response that the request was received.

* Open `13-Ins_POST-Requests/server.js` in your IDE to demonstrate the following:

  * Let's look at the server file and examine the POST route.

  * The POST route begins with the `app.post()` method.

  * Much like GET requests, the first argument is the endpoint that we want to create, and the second is the route handler function:

    ```js
    app.post('/api/reviews', (req, res) => {
    ```

  * Inside the body of the handler, the client is sent a message using the `res.json()` method.

  * The `req` object is also being used to dynamically slot in the method attribute that is provided by Express.js.

  * A few console logs will also provide us with additional information about the client in the terminal. We are using the `req` object again to access another property called `rawHeaders`.

  * `rawHeaders` contains the headers that are automatically generated by Insomnia and sent with each request:

    ```js
    console.info(req.rawHeaders);

    console.info(`${req.method} request received`);
    ```

  * 🔑 Remember when creating POST routes that requests will also need to be concluded -- preventing the client requests from timing out and letting them know that the server is done processing their request:

    ```js
    res.json(`${req.method} request received`);
    ```

* Ask the class the following questions (☝️) and call on students for the answers (🙋):

  * ☝️ How would we build this?

  * 🙋 We can start by creating a POST route in the Express.js server using the `app.post()` method, then we use the `req` object to get additional information about the request and client.

* Answer any questions before proceeding to the next activity.

* In preparation for the activity, ask TAs to start directing students to the activity instructions found in `14-Stu_POST-Requests/README.md`.

### 6. Student Do: POST Requests (15 min)

* Direct students to the activity instructions found in `14-Stu_POST-Requests/README.md`.

* Break your students into pairs that will work together on this activity.

  ```md
  # 🏗️ Implement Logging for GET and POST Requests

  Work with a partner to implement the following user story:

  * As a developer, I want to ensure that my requests are handled based on their HTTP method so that future create, read, update, and delete (CRUD) operations work as intended.

  ## Acceptance Criteria

  * It's done when I have created a route that logs when a user has made a GET request.

  * It's done when I have created a route that logs when a user has made a POST request.

  * It's done when, if I test my route using Insomnia, GET and POST requests are logged.

  ---

  ## 💡 Hints

  How can we enable the same endpoint to handle both GET and POST requests?

  ## 🏆 Bonus

  If you have completed this activity, work through the following challenge with your partner to further your knowledge:

  * When would you use a GET request vs. a POST request?

  Use [Google](https://www.google.com) or another search engine to research this.
  ```

* While breaking everyone into groups, be sure to remind students and the rest of the instructional staff that questions on Slack or otherwise are welcome and will be handled. It's a good way for your team to prioritize students who need extra help.

### 7. Instructor Review: POST Requests (10 min)

* Ask the class the following questions (☝️) and call on students for the answers (🙋):

  * ☝️ How comfortable do you feel creating POST requests? (Poll via Fist to Five, Slack, or Zoom)

* Assure students that we will cover the solution to help solidify their understanding. If questions remain, remind them to use office hours to get extra help!

* Use the prompts and talking points (🔑) below to review the following key points:

  * ✔️ GET vs. POST

  * ✔️ One endpoint for two kinds of requests

* Open `14-Stu_POST-Requests/server.js` in your IDE and explain the following:

  * When we open the `server.js` file, we first import Express.js and set a variable for the port:

    ```js
    const express = require('express');
    const port = 3001;
    ```

  * We also have an `app` variable that is set to the value of the `express()` function:

    ```js
    const app = express();
    ```

  * The routes for both `/api/reviews` and `/api/upvotes` have already been started, so let's finish them.

  * 🔑 In the `/api/reviews` route handler, the first thing we want to do is tell the client that we received their request. We do this by invoking `res.json()` and passing in a message:

    ```js
    res.json(`${req.method} request received to get reviews`);
    ```

  * 🔑 Invoking the `res.json()` method will conclude the request-response cycle, but as far as the server is concerned, we can still run the rest of the code in the code block.

  * We use the `console.info()` method to print a message to the console that a request was received. We construct the output string using the `req.method()` object and string interpolation:

    ```js
    console.info(`${req.method} request received to get reviews`);
    ```

  * While this logic is fresh in your mind, you can finish the `/api/upvotes` GET route:

    ```js
    app.get('/api/upvotes', (req, res) => {
      res.json(`${req.method} request received to retrieve upvote count`);

      console.info(`${req.method} request received to retrieve upvote count`);
    });
    ```

  * Next, we create POST routes for both of these endpoints. Using Express.js, it is possible to create two entirely different routes with the same endpoint.

  * The POST route for `/reviews` and `/upvotes` are functionally identical to the GET routes, except that we use `app.post()` instead of `app.get()`:

    ```js
    app.post('/api/reviews', (req, res) => {
      res.json(`${req.method} request received to add a review`);

      console.info(`${req.method} request received to add a review`);
    });
    ```

  * The POST route for `api/upvotes` looks nearly identical, because the goal is to log the request and the HTTP method:

    ```js
    app.post('/api/upvotes', (req, res) => {
      res.json(`${req.method} request received to upvote`);

      console.info(`${req.method} request received to upvote`);
    });
    ```

  * 🔑 If you want to, when creating routes in Express.js, you can perform some logic to update a resource inside of a GET route handler. The different methods on the `app` object are designed to aid organization and readability rather than dictate exactly how APIs should be implemented. However, for the API to be considered RESTful, we should keep the POST logic to POST routes and GET logic to GET routes.

* Ask the class the following questions (☝️) and call on students for the answers (🙋):

  * ☝️ Which HTTP methods can we handle using Express.js?

  * 🙋 Express.js has methods for GET, POST, patch, PUT, DELETE, connect, options, and trace.

  * ☝️ What can we do if we don't completely understand this?

  * 🙋 We can refer to supplemental material, read the [Express.js documentation on basic routing](https://expressjs.com/en/starter/basic-routing.html), and stay for office hours to ask for help.

* Answer any questions before proceeding to the next activity.

### 8. Instructor Demo: Body Parsing (5 min)

* Open `15-Ins_Body-Parsing/server.js` in your browser and demonstrate the following:

* Run `npm install && npm start` from the command line and demonstrate the following:

  * When we run the server, we find that it is listening on port `http://localhost:3001/`.

  * Inside the `server.js` file, there are two routes for `/api/reviews` -- one to handle GET requests and another to handle POST requests.

  * 🔑 In a lot of cases, POST requests will be designed to accept a request body from the client. However, to use the data that we get from the client, we need to intercept that request first and parse the data into JSON.

  * 🔑 Middleware acts as a sort of net that captures the client request before it reaches the route logic.

  * Middleware in Express.js can access both the request and response object and optionally modify the data before passing it along.

  * First we add the middleware to the server and set it up to handle JSON and URL-encoded form data:

    ```js
    app.use(express.json());
    app.use(express.urlencoded({ extended: true }));
    ```

  * The GET route in this demo is set up to return all the reviews from the database:

    ```js
    app.get('/api/reviews', (req, res) => {
      console.info(`${req.method} request received to get reviews`);

      return res.json(reviews);
    });
    ```

  * Next we have a POST route with a handler that will check whether the request object exists and has a property called `product`. If so, we prepare a response and then send it off to the client.

  * If we don't have a proper request object or the require property, `product`, we send a message to the client that they are missing some information in the request body:

    ```js
    app.post('/api/reviews', (req, res) => {
      console.info(`${req.method} request received to add a review`);

      let response;

      if (req.body && req.body.product) {
        response = {
          status: 'success',
          data: req.body,
        };
        res.json(`Review for ${response.data.product} has been added!`);
      } else {
        res.json('Request body must at least contain a product name');
      }

      console.log(req.body);
    });
    ```

* Open Insomnia on your local machine and demonstrate the following:

  * Create a new POST request to `http://localhost:3001/api/reviews` and select the Body tab. From the Body drop-down menu, choose JSON.

  * Copy the following request object and click Send:

    ```json
    {
      "product": "Corsair K100",
      "username": "1337gamer",
      "review": "This keyboard has a nice response time!",
      "id": 5
    }
    ```

  * 🔑 Notice that the POST request was successful because we provided a request body and the necessary `product` property in the object.

* Ask the class the following questions (☝️) and call on students for the answers (🙋):

  * ☝️ What other use cases for `req.body` can you think of when building your applications?

  * 🙋 We can use the `req.body` object to capture a large amount of data from the client, like a blog post, comments, image captions, and so on.

* Answer any questions before proceeding to the next activity.

* In preparation for the activity, ask TAs to start directing students to the activity instructions found in `16-Stu_Body-Parsing/README.md`.

### 9. Student Do: Body Parsing (15 min)

* Direct students to the activity instructions found in `16-Stu_Body-Parsing/README.md`.

* Break your students into pairs that will work together on this activity.

  ```md
  # 📖 Implement Body Parsing for Post Requests

  Work with a partner to implement the following user story:

  * As a developer, I want my application to be backward compatible with URL-encoded data in addition to JSON.

  ## Acceptance Criteria

  * It's done when I implement Express.js middleware to parse JSON in my server.

  * It's done when I implement Express.js middleware to parse URL-encoded data in my server.

  * It's done when I use Insomnia to make a POST request to `api/upvotes/:review_id`, using JSON to upvote a given post.

  * It's done when I use Insomnia to make a POST request to `api/upvotes/:review_id`, using URL-encoded data to upvote a given post.

  * It's done when I verify that both POST requests return a response that contains the updated vote count.

  ## 📝 Notes

  Refer to the documentation:

  [Express.js documentation on req.body](http://expressjs.com/en/api.html#req.body)

  ---

  ## 💡 Hints

  How do we use Insomnia to pass data inside a `req.body` object when making a POST request to the server?

  ## 🏆 Bonus

  If you have completed this activity, work through the following challenge with your partner to further your knowledge:

  * What is URL encoding?

  Use [Google](https://www.google.com) or another search engine to research this.
  ```

* While breaking everyone into groups, be sure to remind students and the rest of the instructional staff that questions on Slack or otherwise are welcome and will be handled. It's a good way for your team to prioritize students who need extra help.

### 10. BREAK (15 min)

### 11. Instructor Review: Body Parsing (10 min)

* Ask the class the following questions (☝️) and call on students for the answers (🙋):

  * ☝️ How comfortable do you feel parsing data from the request body? (Poll via Fist to Five, Slack, or Zoom)

* Assure students that we will cover the solution to help solidify their understanding. If questions remain, remind them to use office hours to get extra help!

* Use the prompts and talking points (🔑) below to review the following key points:

  * ✔️ Middleware

  * ✔️ `app.use()`

  * ✔️ URL-encoded data

* Open `16-Stu_Body-Parsing/Solved/server.js` in your IDE and explain the following:

  * When we open the server file, we first need to mount the middleware functions.

  * To mount the middleware functions, we use the `app.use()` method provided by Express.js. The `use()` method mounts a specific middleware to the server.

  * To make the endpoints accept both JSON, we first add middleware for parsing JSON:

    ```js
    const express = require('express');

    const port = 3001;
    const reviews = require('./db/reviews.js');

    const app = express();

    app.use(express.json());
    ```

  * Next, we add another middleware function for the parsing of URL-encoded data. This is a method on the `express` object, called `express.urlencoded()`.

  * We also pass an additional options object to `express.urlencoded()`. The `extended` option allows us to choose whether we want to parse strings with the included `qs` library:

    ```js
    app.use(express.urlencoded({ extended: true }));
    ```

    **Note**: `qs` is a library that parses and stringifies queries and provides additional security.

  * URL-encoded data represents another way to submit a request body to the server besides JSON, which we are used to.

  * For example, if we had an HTML form with an `upvote` field, the URL-encoded data would look something like this:

    ```sh
    "upvote=true"
    ```

  * Parsing this data would allow us to access these key-value pairs in an object:

    ```json
    {
      "upvote": true,
    }
    ```

  * We want this to be an accepted way of submitting a request to the server.

  * Now that we have the middleware functions mounted, let's open Insomnia and make some requests to test the server.

* Navigate to `16-Stu_Body-Parsing/Solved` in your command line and run `npm install` and `npm start`.

* Open Insomnia to demonstrate the following:

  * Create a GET request to `/api/reviews` and copy the id of one of the reviews.

  * Create a new POST request to `/api/upvotes/:review_id`, substituting `review_id` for the id that you copied from the GET request.

  * In the Insomnia interface, choose the body type as **Form URL encoded**, and enter `upvote` as the key, with a value of `true`.

  * Click Send, and you should receive the updated vote count as a response from the server:

    ```json
    "New upvote count is: 21"
    ```

  * Now let's test whether we can submit regular JSON with the same data. Create a new POST request with a URL of `/api/upvotes/:review_id`, substituting the `review_id` with the one we used in the previous request.

  * From the drop-down, choose JSON as the request body type, and provide the following object:

    ```json
      {
        "upvote": true
      }
    ```

  * Click Submit, and verify that your response includes the updated vote count:

    ```json
    "New upvote count is: 22"
    ```

* Ask the class the following questions (☝️) and call on students for the answers (🙋):

  * ☝️ Why is it important to allow different types of request bodies to the endpoints?

  * 🙋 Accepting different types of requests makes the server more resilient and provides front-end developers with more options when they use the API.

  * ☝️ What can we do if we don't completely understand this?

  * 🙋 We can refer to supplemental material, read the [Express.js documentation on req.body](http://expressjs.com/en/api.html#req.body), and stay for office hours to ask for help.

* Answer any questions before proceeding to the next activity.

### 12. Instructor Demo: POST Fetch (5 min)

* Navigate to `17-Ins_POST-Fetch/server.js` in your command line and run `npm install` and `npm start`.

* Open `http://localhost:3001` in your browser to demonstrate the following:

  * 🔑 When we run this application, we find that the server starts on port 3001. We also encounter a message to visit `http://localhost:3001/` in the browser.

  * 🔑 When we visit this page in the browser, a form prompts us to submit a review.

  * There are input fields for each item on the page as well as a Submit button.

  * This exercise adds front-end functionality to make a POST request to the server, using the Fetch API that is built into modern browsers.

  * After the form has been submitted, we get its status and a new ID for the review that was submitted.

* Open `17-Ins_POST-Fetch/public/scripts/index.js` in your IDE to demonstrate the following:

  * To capture the data entered by the user, we need to first create variables for the input fields on the page:

    ```js
    const userNameInput = document.getElementById('username');
    const productInput = document.getElementById('product');
    const reviewInput = document.getElementById('review');
    ```

  * We will create a new `review` object using the `.value` from these elements. Then we will save a new review, using the Fetch API to send that object to the endpoint.

  * Once we have the new `review` object, we can perform the logic inside the event handler for the form itself:

    ```js
    const reviewForm = document.getElementById('review-form');

    reviewForm.addEventListener('submit', (e) => { /* Fetch Request Logic */ }
    ```

  * In the next activity, we will add comments to the functionality of this app.

* Ask the class the following questions (☝️) and call on students for the answers (🙋):

  * ☝️ How would we build this?

  * 🙋 We would first examine the server-side route handler for posting a new review and use that information to form the POST `fetch()` request on the front end.

* Answer any questions before proceeding to the next activity.

* In preparation for the activity, ask TAs to start directing students to the activity instructions found in `18-Stu_POST-Fetch/README.md`.

### 13. Student Do: POST Fetch (15 min)

* Direct students to the activity instructions found in `18-Stu_POST-Fetch/README.md`.

* Break your students into pairs that will work together on this activity.

  ```md
  # 📐 Add Comments to Implementation of Client-Side POST Requests

  Work with a partner to add comments describing the functionality of the code found in [server.js](./Unsolved/server.js) and [index.js](./Unsolved/public/scripts/index.js).

  ## 📝 Notes

  Where does the information that we want to send to the server reside when we create the `fetch()` request?

  Refer to the documentation:

  [MDN Web Docs on using Fetch](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch)

  ---

  ## 🏆 Bonus

  If you have completed this activity, work through the following challenge with your partner to further your knowledge:

  * What other content types could you set when sending a request?

  Use [Google](https://www.google.com) or another search engine to research this.
  ```

* While breaking everyone into groups, be sure to remind students and the rest of the instructional staff that questions on Slack or otherwise are welcome and will be handled. It's a good way for your team to prioritize students who need extra help.

### 14. Instructor Review: POST Fetch (10 min)

* Ask the class the following questions (☝️) and call on students for the answers (🙋):

  * ☝️ How comfortable do you feel making POST requests with the Fetch API? (Poll via Fist to Five, Slack, or Zoom)

* Assure students that we will cover the solution to help solidify their understanding. If questions remain, remind them to use office hours to get extra help!

* Use the prompts and talking points (🔑) below to review the following key points:

  * ✔️ Fetch API

  * ✔️ Headers

  * ✔️ `body` property

* Navigate to `18-Stu_POST-Fetch/` in your command line and run `npm install` and `npm start`.

* Open `http://localhost:3001` in your browser to demonstrate the following:

  * 🔑 When we run this app from the command line and open `http://localhost:3001/`, we are presented with a form to submit a review.

  * 🔑 Note also that the form accepts a username or email address, a product, and finally a review for that product.

  * After submitting the form, we are presented with a status message and the ID for the review that we just submitted.

* Open `18-Stu_POST-Fetch/server.js` in your IDE to demonstrate the following:

  * In the `server.js` file, we require the necessary dependencies, set a port for the server, and initialize the middleware to parse JSON and URL-encoded data:

    ```js
    const express = require('express');
    const path = require('path');
    const uuid = require('./helpers/uuid');

    const port = 3001;

    const app = express();

    app.use(express.json());
    app.use(express.urlencoded({ extended: true }));

    app.use(express.static('public'));
    ```

  * 🔑 We know that the front end will use the Fetch API to make a POST request to the server, so let's examine the route for handling POST requests to `/api/reviews`:

  * First we use destructuring assignment to extract the request body into `product`, `review`, and `username` variables:

    ```js
    app.post('/api/reviews', (req, res) => {
      console.info(`${req.method} request received to add a review`);

      const { product, review, username } = req.body;
    ```

  * If all three of these variables exist, we create a new `review` object and a `response` object:

    ```js
    if (product && review && username) {
      const newReview = {
        product,
        review,
        username,
        upvotes: Math.floor(Math.random() * 100),
        review_id: uuid(),
      };

      const response = {
        status: 'success',
        body: newReview,
      };
    ```

  * 🔑 In this demo, we are not writing to the actual file system, so at the end of the route handler, we simply return the `response` object, which contains a `status` and the `newReview` that we created:

    ```js
    app.post('/api/reviews', (req, res) => {
      console.info(`${req.method} request received to add a review`);

      const { product, review, username } = req.body;

      if (product && review && username) {
        const newReview = {
          product,
          review,
          username,
          upvotes: Math.floor(Math.random() * 100),
          review_id: uuid(),
        };

        const response = {
          status: 'success',
          body: newReview,
        };

        console.log(response);
        res.status(201).json(response);
      } else {
        res.status(500).json('Error in posting review');
      }
    })
    ```

  * Let's examine the front end and study the corresponding `fetch()` POST request.

* Open `18-Stu_POST-Fetch/public/scripts/index.js` in your IDE to demonstrate the following:

  * The front-end code contains some variables that select various elements in the DOM:

      ```js
      const userNameInput = document.getElementById('username');
      const productInput = document.getElementById('product');
      const reviewInput = document.getElementById('review');
      const reviewForm = document.getElementById('review-form');
      ```

  * We use the `reviewForm` variable to attach the event listener.

  * 🔑 In the event handler, we prevent the default behavior of the browser by using `e.preventDefault()`, and then we create a `newReview` object from the data that the user enters.

  * Notice that the `newReview` object is very similar to the new `review` object that we created in the back-end route handler:

    ```js
    reviewForm.addEventListener('submit', (e) => {
      e.preventDefault();

      const newReview = {
        username: userNameInput.value.trim(),
        product: productInput.value.trim(),
        review: reviewInput.value.trim(),
      };

      ...
    }
    ```

  * At the end of the event handler, we invoke another helper function, called `postReview()`. This method accepts `newReview` to post, then takes the response data and shows the user an alert:

    ```js
    postReview(newReview)
      .then((data) => alert(`Review added! Review ID: ${data.body.review_id}`))
      .catch((err) => console.error(err));
    ```

  * 🔑 Inside the `postReview()` helper function, we use the Fetch API to make a POST request to the server.

  * Remember that POST requests accept a path or endpoint, and an `options` object. The `options` object has `method`, `headers`, and `body` properties.

  * 🔑 Before we send the `review` object to the server, we coerce the object into a string, using the `JSON.stringify()` method.

  * If the response was successful, we log out the successful response and return the data that was used to create the alert for the client.

  * If an error occurs, we log out that error to the console using `console.error()`:

    ```js
    const postReview = (review) =>
      fetch('/api/reviews', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(review),
      })
        .then((res) => res.json())
        .then((data) => {
          console.log('Successful POST request:', data);
          return data;
        })
        .catch((error) => {
          console.error('Error in POST request:', error);
        });
    ```

* Ask the class the following questions (☝️) and call on students for the answers (🙋):

  * ☝️ Why is it important to stringify an object before sending it to the server?

  * 🙋 The route handler attempts to parse the string it receives from the client into JSON; it will throw an error if the object hasn't been converted before sending the POST request.

  * ☝️ What can we do if we don't completely understand this?

  * 🙋 We can refer to supplemental material, read the [MDN Web Docs on using Fetch](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch), and stay for office hours to ask for help.

* Answer any questions before proceeding to the next activity.

### 15. Instructor Demo: Data Persistence (5 min)

* Navigate to `19-Ins_Data-Persistence` in your command line and run `npm install` and `npm start`.

* Open `http://localhost:3001` in your browser to demonstrate the following:

  * 🔑 When we run this app, we are presented with the same review form as last time. If we enter the required information and click Submit, we get a message that includes the review ID.

  * 🔑 There is a feature that has been added to this application that will create a new JSON file for each product that gets reviewed.

  * Let's find out where these files are being saved to the file system.

* Open `19-Ins_Data-Persistence` in your IDE to demonstrate the following:

  * Note that in the file tree we have a new folder called `/db`. A new file has been created with the same name for the product that we reviewed in the front end.

* Open `19-Ins_Data-Persistence/server.js` in your IDE to demonstrate the following:

  * Let's review the server-side logic for the `/api/reviews` POST route handler.

  * First we set up the POST route, using `app.post()`, with the path `/api/reviews`:

    ```js
    app.post('/api/reviews', (req, res) => { }
    ```

  * We also use destructuring assignment to get the values of `product`, `review`, and `username`.

  * We check whether those exist, then make a new `review` object:

    ```js
    if (product && review && username) {
      const newReview = {
        product,
        review,
        username,
        upvotes: Math.floor(Math.random() * 100),
        review_id: uuid(),
      };
    ```

  * Before we can write the data to a file using the `fs` module, we need to convert the `review` object to a string using the `JSON.stringify()` method:

    ```js
    const reviewString = JSON.stringify(newReview);
    ```

  * With the stringified version of the review, called `reviewString`, we can now write to the file system.

  * First we invoke the `fs.writeFile()` method, which accepts the arguments `path` and `data`.

  * For `path`, we use string interpolation to create the file name, using the `newReview.product` property.

  * The second argument, `data`, will be the stringified version of the review that we created earlier.

  * The callback function will log if there is an error in saving the file. Otherwise, we will log to the terminal that the save was successful:

    ```js
    fs.writeFile(`./db/${newReview.product}.json`, reviewString, (err) =>
      err
        ? console.error(err)
        : console.log(
            `Review for ${newReview.product} has been written to JSON file`
          )
    );
    ```

  * Even though we created the logic to write to the file system, it is still necessary to conclude the route handler by sending something to the client using `res.json()`:

    ```js
    res.status(201).json(response);
    ```

  * Also, we handle any errors that may occur by sending a response with the `res.status(500)` method.

    ```js
    res.status(500).json("Error in posting review");
    ```

  * 🔑 Remember that status codes in the 200 range indicate success and status codes in the 500 range indicate an error.

* Ask the class the following questions (☝️) and call on students for the answers (🙋):

  * ☝️ What do we have to import into the server file to save data to the file system?

  * 🙋 At the top of the server file, we need to require the built-in Node.js `fs` module.

* Answer any questions before proceeding to the next activity.

* In preparation for the activity, ask TAs to start directing students to the activity instructions found in `20-Stu_Data-Persistence/README.md`.

### 16. Student Do: Data Persistence (15 min)

* Direct students to the activity instructions found in `20-Stu_Data-Persistence/README.md`.

* Break your students into pairs that will work together on this activity.

  ```md
  # 🐛 Adding a Review Overwrites Existing JSON

  Work with a partner to resolve the following issues:

  * As a user, I want to be able to append my review to the list of existing reviews so that existing reviews don't get overwritten.

  ## Expected Behavior

  When a user adds a review, the review should append to the list of reviews in the JSON file.

  ## Actual Behavior

  When a user adds a review, the entire JSON file gets overwritten with the new review, and the existing reviews get replaced.

  ## Steps to Reproduce the Problem

  1. Run the back-end server by running `npm install` and `npm start`.

  2. Click the link in the terminal to visit `http://localhost:3001/`.

  3. Fill out the necessary fields to add a review.

  4. Check the content of `db/reviews.json` and note that the old entries have been replaced.

  ---

  ## 💡 Hints

  How can the built-in `fs` module accomplish appending data to a JSON file?

  ## 🏆 Bonus

  If you have completed this activity, work through the following challenge with your partner to further your knowledge:

  * Without having a database, what other tools can you use to persist data on the server?

  Use [Google](https://www.google.com) or another search engine to research this.
  ```

* While breaking everyone into groups, be sure to remind students and the rest of the instructional staff that questions on Slack or otherwise are welcome and will be handled. It's a good way for your team to prioritize students who need extra help.

### 17. Instructor Review: Data Persistence (15 min)

* Ask the class the following questions (☝️) and call on students for the answers (🙋):

  * ☝️ How comfortable do you feel making POST requests using the Fetch API? (Poll via Fist to Five, Slack, or Zoom)

* Assure students that we will cover the solution to help solidify their understanding. If questions remain, remind them to use office hours to get extra help!

* Use the prompts and talking points (🔑) below to review the following key points:

  * ✔️ `fs.writeFile()`

  * ✔️ Reading from the file system

  * ✔️ Appending to the file system

* Open `20-Stu_Data-Persistence/Solved/db/reviews.json` in your IDE to demonstrate the following:

  * Notice that a few of the reviews are stored in the JSON file, along with the relevant `review`, `product`, `username`, and `review_id`:

      ```json
      [
        {
          "product": "Happy Hacking Keyboard Professional 2",
          "username": "kbdfan05",
          "review": "It rules!",
          "review_id": "c763"
        },
        {
          "product": "Das Keyboard",
          "review": "I love it, but the keyboard is too big for my desk.",
          "username": "coolperson12",
          "review_id": "121d"
        }
      ]
      ```

* Navigate to `20-Stu_Data-Persistence/Solved/` in your command line and run `npm install` and `npm start`.

* Open `http://localhost:3001/` in your browser to demonstrate the following:

  * 🔑 On the page, enter a username, product, and a review to use as an example, then click Submit.

* Open `20-Stu_Data-Persistence/Solved/db/reviews.json` in your IDE to demonstrate the following:

  * Note that each review is getting appended to the list of already existing reviews.

  * 🔑 To observe how the reviews are appended rather than overwritten, let's refer to the `app.post()` route for `/api/reviews`.

* Open `20-Stu_Data-Persistence/Solved/server.js` in your IDE to demonstrate the following:

  * In the route handler for posting new reviews, we have logic that checks whether the required properties are present in the `req.body` object:

      ```js
      app.post('/api/reviews', (req, res) => {
        console.info(`${req.method} request received to add a review`);

        const { product, review, username } = req.body;

        if (product && review && username) {
          const newReview = {
            product,
            review,
            username,
            review_id: uuid(),
          };
      ```

  * 🔑 The key to resolving this bug is to first read the content of the `reviews` file so that we can add to it. After that, we will be able to write the new list of reviews in the JSON file.

  * 🔑 To read the content of the `reviews.json` file, we use the native `fs.readFile()` method from Node.js. We specify the path for the file that we want to read, the file's encoding, and a callback function.

  * The callback function will accept an `err` argument, used for error handling, and also a `data` argument, which will contain the content of the `reviews.json` file:

    ```js
    fs.readFile('./db/reviews.json', 'utf8', (err, data) => { }
    ```

  * Inside the callback function for `fs.readFile()`, we start by handling any errors that might have occurred when the file was read:

    ```js
    if (err) {
      console.error(err);
    } else {
    ```

  * If no error exists, we move on to the next step. We parse the content of the file that we just read.

  * We can assume that the data we get back will contain the existing reviews, so we store them in a variable called `parsedReviews`:

    ```js
    const parsedReviews = JSON.parse(data);
    ```

  * The next step we take is to add the new review to the list of existing reviews. To do this, we use the `push()` method because the `parsedReviews` variable is an array of objects:

    ```js
    parsedReviews.push(newReview);
    ```

  * We now have the `newReview` object included in the `parsedReviews` array, so it is time to write the file back to the file system.

  * To save the `parsedReviews` array, we invoke `fs.writeFile()`, which takes a path, the data we want to save, and a callback.

  * In this case, the path is the relative path to the `reviews.json` file. The data is the `parsedReviews` array, and the callback will simply log out any errors or success messages from the write attempt:

    ```js
    fs.writeFile(
      './db/reviews.json',
      JSON.stringify(parsedReviews, null, 4),
      (writeErr) =>
        writeErr
          ? console.error(writeErr)
          : console.info('Successfully updated reviews!')
    );
    ```

      **Note**: The second and third arguments provided by the `JSON.stringify()` method are optional arguments that help with formatting. The first is a `replacer()` function, which we set to null, and the third is the `space` argument that adds indentation, whitespace, and line break characters to make it easier to read.

  * Once we have successfully written to `reviews.json`, we can send the client a response that contains the updated review:

    ```js
      const response = {
        status: 'success',
        body: newReview,
      };

      res.status(201).json(response);
    } else {
      res.status(500).json('Error in posting review');
    }
    ```

* Ask the class the following questions (☝️) and call on students for the answers (🙋):

  * ☝️ What do we need to do with the data we get back from `fs.readFile()` to add some content to that data?

  * 🙋 The data we get back from the `fs.readFile()` call has to be parsed, using `JSON.parse()` to convert it to an array, before we can push something to it.

  * ☝️ What can we do if we don't completely understand this?

  * 🙋 We can refer to supplemental material, read the [Node.js documentation on fs](https://nodejs.org/api/fs.html), and stay for office hours to ask for help.

* Answer any questions before ending the class.

### 18. END (0 min)

How did today’s lesson go? Your feedback is important. Please take 5 minutes to complete this [anonymous survey](https://forms.gle/RfcVyXiMmZQut6aJ6).

---
© 2022 edX Boot Camps LLC. Confidential and Proprietary. All Rights Reserved.
