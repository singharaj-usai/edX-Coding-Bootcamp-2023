# 11.3 Part-Time Lesson Plan: Modular Routing, Custom Middleware, and Deployment

## Overview

In today's module, students will learn how to create modular routes for better organization. Additionally, students will learn how to write custom middleware and use it for their server-side applications. They will deploy applications to Heroku using the Heroku CLI and also explore some lesser-known Git commands in this week's Git Guide on Git History.

## Instructor Notes

* In this lesson, students will complete activities `21-Ins_Modular-Routing` through `28-Stu_Mini-Project`.

* Remind students to do a `git pull` of the class repo to have today's activities ready and open in VS Code.

* If you are comfortable doing so, live-code the solutions to the activities. If not, just use the solutions provided and follow the prompts and talking points for review.

* Let students know that the Bonus at the end of each activity is not meant to be extra coding practice, but instead is a self-study on topics beyond the scope of this module for those who want to further their knowledge.

* If the students struggle with the `Everyone Do: Git` activity, walk through it with the students using the talking points provided. Otherwise, support the students as they do the activity and do a brief review at the end.

## Learning Objectives

By the end of class, students will be able to:

* Implement separation of concerns for routing.

* Write a custom middleware function for Express.js.

* Deploy a Node.js app to Heroku.

* Navigate Git History inside a large open source application.

## Time Tracker

| Start   | #   | Activity Name                        | Duration |
| ------- | --- | ------------------------------------ | -------- |
| 10:00AM | 1   | Instructor Do: Stoke Curiosity       | 0:10     |
| 10:10AM | 2   | Instructor Demo: Modular Routing     | 0:05     |
| 10:15AM | 3   | Student Do: Modular Routing          | 0:15     |
| 10:30AM | 4   | Instructor Review: Modular Routing   | 0:10     |
| 10:40AM | 5   | Instructor Demo: Custom Middleware   | 0:05     |
| 10:45AM | 6   | Student Do: Custom Middleware        | 0:15     |
| 11:00AM | 7   | Instructor Review: Custom Middleware | 0:10     |
| 11:10AM | 8   | Instructor Demo: Heroku              | 0:05     |
| 11:15AM | 9   | Student Do: Heroku                   | 0:15     |
| 11:30AM | 10  | Instructor Review: Heroku            | 0:10     |
| 11:40AM | 11  | Everyone Do: Git History             | 0:20     |
| 12:00PM | 12  | BREAK                                | 0:40     |
| 12:40PM | 13  | Instructor Demo: Mini-Project        | 0:05     |
| 12:45PM | 14  | Student Do: Mini-Project             | 0:60     |
| 1:45PM  | 15  | Instructor Review: Mini-Project      | 0:10     |
| 1:55PM  | 16  | Introduce Challenge                  | 0:05     |
| 2:00PM  | 17  | END                                  | 0:00     |

> **Important**: If this lesson occurs on a weekday, you'll follow a different schedule to accommodate for the shorter class time. The `Stoke Curiosity` section is shortened by 5 minutes, the break by 25 minutes, and the `Student Do: Mini-Project` by 10 minutes, and the `Everyone Do: Git` activity is omitted completely.

<details>
  <summary>Click to show the adjusted time tracker</summary>

| Start  | #   | Activity Name                        | Duration |
| ------ | --- | ------------------------------------ | -------- |
| 6:30PM | 1   | Instructor Do: Stoke Curiosity       | **0:05** |
| 6:35PM | 2   | Instructor Demo: Modular Routing     | 0:05     |
| 6:40PM | 3   | Student Do: Modular Routing          | 0:15     |
| 6:55PM | 4   | Instructor Review: Modular Routing   | 0:10     |
| 7:05PM | 5   | Instructor Demo: Custom Middleware   | 0:05     |
| 7:10PM | 6   | Student Do: Custom Middleware        | 0:15     |
| 7:25PM | 7   | Instructor Review: Custom Middleware | 0:10     |
| 7:35PM | 8   | Instructor Demo: Heroku              | 0:05     |
| 7:40PM | 9   | Student Do: Heroku                   | 0:15     |
| 7:55PM | 10  | BREAK                                | **0:15** |
| 8:10PM | 11  | Instructor Review: Heroku            | 0:10     |
| 8:20PM | 12  | Instructor Demo: Mini-project        | 0:05     |
| 8:25PM | 13  | Student Do: Mini-project             | **0:50** |
| 9:15PM | 14  | Instructor Review: Mini-project      | 0:10     |
| 9:25PM | 15  | Introduce Challenge                  | 0:05     |
| 9:30PM | 16  | END                                  | 0:00     |
</details>

---

## Class Instruction

### 1. Instructor Do: Stoke Curiosity (10 min)

* Welcome students to class.

* Ask the class the following questions (‚òùÔ∏è) and call on students for the answers (üôã):

  * ‚òùÔ∏è How would you describe middleware to a friend?

  * üôã Middleware is an intermediary between two different applications, services, or programs. It can be thought of as a kind of translator that gathers information from the first application or service, distills it into something that can be understood by the second program or service, and then delivers that information.

  * ‚òùÔ∏è What is middleware in the context of Express.js?

  * üôã **Middleware** is a function that has access to the `request` object, the `response` object, and the next middleware in the request cycle if there is one. An example of Express.js middleware would be a function that checks whether a user is authenticated before they are routed to the desired destination.

  * ‚òùÔ∏è What changes can middleware make to the data before it is passed along to the next middleware in the stack?

  * üôã Middleware can execute code, make changes to the `request` and `response` object, completely end the request cycle, and call the next middleware in the stack.

  * ‚òùÔ∏è What kinds of middleware can we use?

  * üôã We can use middleware for authentication to check whether a user is authenticated when attempting to visit specific routes. We can also use it for logging and error handling. Finally, we can use middleware as a way to add features to an application -- like body parsers for JSON and URL-encoded data.

* Explain that today we will create custom middleware for logging and will also deploy an application with custom middleware to Heroku.

* Answer any questions before proceeding to the next activity.

### 2. Instructor Demo: Modular Routing (5 min)

* Navigate to `21-Ins_Modular-Routing/server.js` in your command line and run `npm install` and `npm start`.

* Open `http://localhost:3001` in your browser to demonstrate the following:

  * üîë The page displays a list of UI/UX tips in addition to a form to add a new tip.

  * üîë When we add a new tip and click Submit, a message indicates that the tip has been added.

* Open `21-Ins_Modular-Routing/server.js` in your IDE to demonstrate the following:

  * Note that the server file contains routes that have different paths:

    ```js
    app.get('/api/tips', (req, res) => {
      console.info(`${req.method} request received for tips`);
      readFromFile('./db/tips.json').then((data) => res.json(JSON.parse(data)));
    });

    app.get('/api/feedback', (req, res) => {
      console.info(`${req.method} request received for feedback`);

      readFromFile('./db/feedback.json').then((data) => res.json(JSON.parse(data)));
    });
    ```

* This demo contains all routes inside the same file. There are many ways to create your server, but creating modular routes is ideal for readability and organization.

* We could clean up this application by creating a `routes` folder that contains all the modular routes, divided into three files -- one named `tips.js` that contains all the route logic for the endpoint `/api/tips`, one for feedback called `feedback.js` that contains all the route logic for the endpoint `/api/feedback`, and an `index.js` file that will require all the other routes in that folder.

* For the next activity, we will need to read the Express.js documentation to learn how to create modular routes. Let's get started!

* Ask the class the following questions (‚òùÔ∏è) and call on students for the answers (üôã):

  * ‚òùÔ∏è What are the benefits of modularizing routes in your application?

  * üôã Modularizing routes allows for the separation of concerns and makes the code easier to read and easier to maintain.

  * ‚òùÔ∏è What is the first step to create modular routes for this application?

  * üôã We could begin by creating a `routes` folder that will contain all the routes. Then we could require all of those routes in a central `index.js` file. Finally, we can refer to the Express.js documentation to learn how to create modular routes.

* Answer any questions before proceeding to the next activity.

* In preparation for the activity, ask TAs to start directing students to the activity instructions found in `22-Stu_Modular-Routing/README.md`.

### 3. Student Do: Modular Routing (15 min)

* Direct students to the activity instructions found in `22-Stu_Modular-Routing/README.md`.

* Break your students into pairs that will work together on this activity.

  ```md
  # üìñ Implement Modular Routes

  Work with a partner to implement the following user story:

  * As a developer, I want to modularize my route logic from the rest of my server so that I can separate concerns appropriately.

  ## Acceptance Criteria

  * It's done when the routes in `server.js` are broken into modules based on different endpoints.

  * It's done when I have created a `routes` directory to hold my route files.

  * It's done when I have created a `tipsRouter.js` file that uses `express.Router()`.

  * It's done when I have created a `feedbackRouter.js` file that also uses `express.Router()`.

  * It's done when I have created an `index.js` file that imports all my router files.

  * It's done when I have required my `routes.js` file inside my `server.js` file.

  ## üìù Notes

  Refer to the documentation:

  [Express.js documentation on express.Router()](http://expressjs.com/en/guide/routing.html#express-router)

  ---

  ## üí° Hints

  How does the separation of concerns help other developers who might work with your code in the future?

  ## üèÜ Bonus

  If you have completed this activity, work through the following challenge with your partner to further your knowledge:

  * What are some best practices for naming your routes?

  Use [Google](https://www.google.com) or another search engine to research this.
  ```

* While breaking everyone into groups, be sure to remind students and the rest of the instructional staff that questions on Slack or otherwise are welcome and will be handled. It's a good way for your team to prioritize students who need extra help.

### 4. Instructor Review: Modular Routing (10 min)

* Ask the class the following questions (‚òùÔ∏è) and call on students for the answers (üôã):

  * ‚òùÔ∏è How comfortable do you feel creating modular routes? (Poll via Fist to Five, Slack, or Zoom)

* Assure students that we will cover the solution to help solidify their understanding. If questions remain, remind them to use office hours to get extra help!

* Use the prompts and talking points (üîë) below to review the following key points:

  * ‚úîÔ∏è `express.Router()`

  * ‚úîÔ∏è `module.exports`

  * ‚úîÔ∏è `app.use()`

* Open `22-Stu_Modular-Routing/Solved/server.js` in your IDE and explain the following:

  * When we open the `server.js` file, we notice that the file is much cleaner and easier to read after the refactor.

  * Modular routes drastically reduce the lines of code in a single file and allow for separation of concerns:

    ```js
    const express = require('express');
    const path = require('path');
    const api = require('./routes/index.js');

    const PORT = 3001;

    const app = express();

    app.use(express.json());
    app.use(express.urlencoded({ extended: true }));
    app.use('/api', api);

    app.use(express.static('public'));

    app.get('/', (req, res) =>
      res.sendFile(path.join(__dirname, '/public/index.html'))
    );

    app.get('/feedback', (req, res) =>
      res.sendFile(path.join(__dirname, '/public/pages/feedback.html'))
    );

    app.listen(PORT, () =>
      console.log(`App listening at http://localhost:${PORT} üöÄ`)
    );
    ```

  * To create the modular routes, we isolate similar paths and group them together in a single file. Let's start with the `/feedback` routes.

* Open `22-Stu_Modular-Routing/Solved/routes/feedback.js` in your IDE to demonstrate the following:

  * First we create a routes folder and then a `feedback.js` file to contain the feedback router.

  * At the top of the file, we require the `express.Router()` and set it to variable `fb`:

    ```js
    const fb = require('express').Router();
    ```

  * Next, we export the `fb` variable at the bottom of the file so that we don't forget:

    ```js
    module.exports = fb;
    ```

  * We also require any dependencies used inside the route handlers:

    ```js
    const { readAndAppend } = require('../helpers/fsUtils');
    const uuid = require('../helpers/uuid');
    ```

  * Now that we have the Express.js `fb` router, we move the routes related to the `/feedback` endpoint into this file.

  * üîë Notice that instead of using `app.get('/api/feedback')`, we are now referring to the `fb` router to create routes.

  * üîë Additionally, we no longer need to specify `/api` or `/feedback`, as those will be appended to the full path later in this example:

    ```js
    // GET all feedback -- `api/feedback`
    fb.get('/', (req, res) => {
      console.info(`${req.method} request received for feedback`);

      readFromFile('./db/feedback.json').then((data) => res.json(JSON.parse(data)));
    });

    // POST new feedback -- `api/feedback`
    fb.post('/', (req, res) => {
      console.info(`${req.method} request received to submit feedback`);

      const { email, feedbackType, feedback } = req.body;

      if (email && feedbackType && feedback) {
        const newFeedback = {
          email,
          feedbackType,
          feedback,
          feedback_id: uuid(),
        };

        readAndAppend(newFeedback, './db/feedback.json');

        const response = {
          status: 'success',
          body: newFeedback,
        };

        res.json(response);
      } else {
        res.json('Error in posting feedback');
      }
    });
    ```

* Open `22-Stu_Modular-Routing/Solved/routes/tips.js` in your IDE to demonstrate the following:

  * We move all the routes relevant to `/api/tips` to its module.

  * Much like the feedback module, we import any necessary dependencies, import `express.Router()`, and export the `router` variable at the end of the file:

    ```js
    const tips = require('express').Router();
    const { readFromFile, readAndAppend } = require('../helpers/fsUtils');
    const uuid = require('../helpers/uuid');

    tips.get('/', (req, res) => {
      console.info(`${req.method} request received for tips`);
      readFromFile('./db/tips.json').then((data) => res.json(JSON.parse(data)));
    });

    tips.post('/', (req, res) => {
      console.info(`${req.method} request received to add a tip`);
      console.log(req.body);

      const { username, topic, tip } = req.body;

      if (req.body) {
        const newTip = {
          username,
          tip,
          topic,
          tip_id: uuid(),
        };

        readAndAppend(newTip, './db/tips.json');
        res.json(`Tip added successfully üöÄ`);
      } else {
        res.error('Error in adding tip');
      }
    });

    module.exports = tips;
    ```

  * Now that we have the routes isolated into modules, we require them in a central `index.js` file that we can use in the server.

* Open `22-Stu_Modular-Routing/Solved/routes/index.js` in your IDE to demonstrate the following:

  * In the routes folder, we create a new file called `index.js` and require `express`:

    ```js
    const express = require('express');
    ```

  * Next, we require the modular routes inside the `index.js` file:

    ```js
    const tipsRouter = require('./tips');
    const feedbackRouter = require('./feedback');
    ```

  * We then create the `app` variable and give it a value of `express()`:

    ```js
    const app = express();
    ```

  * Next, we mount the modules using the `app.use()` method, assigning a path or endpoint to each router:

    ```js
    app.use('/tips', tipsRouter);
    app.use('/feedback', feedbackRouter);
    ```

* Open `22-Stu_Modular-Routing/Solved/server.js` in your IDE to demonstrate the following:

  * Finally, we use the same `app.use()` method to mount the `index.js` file with a path of `/api`. This endpoint is the entry point for the other modular routes.

    ```js
    app.use('/api', api);
    ```

* Open `22-Stu_Modular-Routing/Solved/routes/index.js` in your IDE to demonstrate the following:

  * üîë When we check the `index.js` file in the `routes` directory for comparison, we find that we have used the endpoint from the `server.js` file to form the `api/tips` endpoint. Note that both use the `use()` method:

    ```js
    app.use('/tips', tipsRouter);
    ```

* Open `22-Stu_Modular-Routing/Unsolved/server.js` in your IDE to demonstrate the following:

  * Note that the refactored code is easier to read -- making it easier to debug and maintain:

    ```js
    app.get('/api/tips', (req, res) => {
      console.info(`${req.method} request received for tips`);
      readFromFile('./db/tips.json').then((data) => res.json(JSON.parse(data)));
    });
    ```

  * When we run the `server.js` file, the functionality of the application is unchanged, but now it is much easier to read and understand.

* Ask the class the following questions (‚òùÔ∏è) and call on students for the answers (üôã):

  * ‚òùÔ∏è What do we need to require in each modular Express.js route file?

  * üôã We need to require the `express.Router()` method, assign it to a variable, and remember to export it at the end of the file.

  * ‚òùÔ∏è What can we do if we don't completely understand this?

  * üôã We can refer to supplemental material, read the [Express.js documentation on express.Router()](http://expressjs.com/en/guide/routing.html#express-router), and stay for office hours to ask for help.

* Answer any questions before proceeding to the next activity.

### 5. Instructor Demo: Custom Middleware (5 min)

* Navigate to `23-Ins_Custom-Middleware/server.js` in your command line and run `npm install` and `npm start`.

* Open Insomnia and make a GET request to `http://localhost:3001/`.

  * üîë When running the application, we find that the server is listening on port 3001.

  * üîë Also, after we request `http://localhost:3001/`, the server logs the request type to the console:

    ```sh
    Listening for requests on port 3001! üèéÔ∏è
    GET request to /
    GET request to /api
    GET request to /test
    GET request to /reviews
    ```

  * The server is making use of custom middleware functions to log out requests to the console.

  * We have worked with middleware to parse JSON and URL-encoded requests, but now we get to create the middleware function using Express.js to add functionality to the app.

  * Let's examine the code to learn how to implement custom middleware in an application!

* Open `23-Ins_Custom-Middleware/server.js` in your IDE to demonstrate the following:

  * Middleware functions have access to the request object (`req`), the response object (`res`), the `next()` function, and the application‚Äôs request-response cycle.

  * The `next()` function invokes the next middleware function and also relinquishes control of the data:

    ```js
    const middleware = (req, res, next) => { ... }
    ```

  * We create a function titled `middleware` that logs out the request type and request path to the console. It also uses ANSI escape codes to print the output in yellow to differentiate it from the rest of the output:

    ```js
    const middleware = (req, res, next) => {
      const yellow = '\x1b[33m%s\x1b[0m';

      console.log(yellow, `${req.method} request to ${req.path}`);

      next();
    };
    ```

    **Note**: ANSI escape codes are sequences that control the location, color, and font style of text inside the terminal window.

  * Next, we mount the `middleware` function using the Express.js `use()` method, passing in the middleware function:

    ```js
    app.use(middleware);
    ```

  * The routes in this example are minimal but will be sufficient for causing the middleware to run and log requests to the console:

    ```js
    app.get('/', (req, res) => res.json(`GET route`));
    app.post('/', (req, res) => res.json(`POST route`));
    app.put('/:id', (req, res) => res.json(`PUT route`));
    app.delete('/:id', (req, res) => res.json(`DELETE route`));
    app.patch('/:id', (req, res) => res.json(`PATCH route`));
    ```

* Ask the class the following questions (‚òùÔ∏è) and call on students for the answers (üôã):

  * ‚òùÔ∏è What actions can middleware execute on the data?

  * üôã Custom middleware functions can manipulate the request or response data, end the request-response cycle, or run any code inside the middleware function.

* Answer any questions before proceeding to the next activity.

* In preparation for the activity, ask TAs to start directing students to the activity instructions found in `24-Stu_Custom-Middleware/README.md`.

### 6. Student Do: Custom Middleware (15 min)

* Direct students to the activity instructions found in `24-Stu_Custom-Middleware/README.md`.

* Break your students into pairs that will work together on this activity.

  ````md
  # üêõ Middleware Logging Not Working

  Work with a partner to resolve the following issues:

  * As a developer, I want to use logging middleware in my application so that I can know when a specific endpoint has been used.

  ## Expected Behavior

  When a user makes a request to an endpoint, the middleware will intercept the request, log out information about the request (GET, POST), and log it to the console.

  ## Actual Behavior

  When a user makes a request to endpoints in the application, we can tell that something was written to the file system, but custom middleware does not log any information.

  ## Steps to Reproduce the Problem

  1. Navigate to `24-Stu_Custom-Middleware/Unsolved` and run `npm install` and `npm start`.

  2. Using Insomnia, make a POST request to `http://localhost:3001/api/tips` with the following request body:

      ```json
      {
      "username": "Sarah",
      "topic": "UI",
      "tip": "Make your application accessible by adding alt properties "
      }
      ```

  3. In the terminal where your Express.js server is running, note that the logging middleware failed to log that the request was received.

  ---

  ## üí° Hints

  How can checking where the middleware is defined help you troubleshoot this bug?

  ## üèÜ Bonus

  If you have completed this activity, work through the following challenge with your partner to further your knowledge:

  * What is a **wildcard rule** when defining route paths?

  Use [Google](https://www.google.com) or another search engine to research this.
  ````

* While breaking everyone into groups, be sure to remind students and the rest of the instructional staff that questions on Slack or otherwise are welcome and will be handled. It's a good way for your team to prioritize students who need extra help.

### 7. Instructor Review: Custom Middleware (10 min)

* Ask the class the following questions (‚òùÔ∏è) and call on students for the answers (üôã):

  * ‚òùÔ∏è How comfortable do you feel with custom middleware? (Poll via Fist to Five, Slack, or Zoom)

* Assure students that we will cover the solution to help solidify their understanding. If questions remain, remind them to use office hours to get extra help!

* Use the prompts and talking points (üîë) below to review the following key points:

  * ‚úîÔ∏è Mounting custom middleware

  * ‚úîÔ∏è Order of imports

  * ‚úîÔ∏è `app.use()`

* Open `24-Stu_Custom-Middleware/Solved/middleware/clog.js` in your IDE to demonstrate the following:

  * üîë Note that the middleware function accepts the `req` object, the `res` object, and the `next()` method as arguments:

    ```js
    const clog = (req, res, next) => { ... };
    ```

  * Requests are intercepted by the middleware function and then enter a `switch` statement. The `switch` statement will run some code depending on the type of request method.

  * We can also see a variable, `fgCyan`, that contains an ANSI escape sequence to output strings in color to the console:

  * We have the option of using `res.end()` or `res.redirect()` to end the request-response cycle inside the middleware function, but for this example we want the cycle to continue. For that reason, we invoke the `next()` method at the end of the function:

    ```js
    const clog = (req, res, next) => {
      const fgCyan = '\x1b[36m';
      switch (req.method) {
        case 'GET': {
          console.info(`üìó ${fgCyan}${req.method} request to ${req.path}`);
          break;
        }
        case 'POST': {
          console.info(`üìò ${fgCyan}${req.method} request to ${req.path}`);
          break;
        }
        default:
          console.log(`üìô${fgCyan}${req.method} request to ${req.path}`);
      }

      next();
    };
    ```

  * To use custom middleware in the server, we have to ensure that it is being exported for use in other files.

  * Inside the `clog.js` file, the custom middleware function is being exported with the name `clog`:

    ```js
    exports.clog = clog;
    ```

* Open `24-Stu_Custom-Middleware/Solved/server.js` in your IDE to demonstrate the following:

  * To resolve the bug associated with this activity, first we require the middleware function `clog`:

    ```js
    const { clog } = require('./middleware/clog');
    ```

  * Next, we mount the middleware function using the `app.use()` method provided by Express.js:

    ```js
    app.use(clog);
    ```

* Open Insomnia and submit a new POST request to `http://localhost:3001/` to demonstrate the following:

  * After we require the middleware function in the server and mount it in the correct order inside the file, the request is logged in the terminal, like in the following example:

    ```bash
    Express server listening on port 3001! Visit http://localhost:3001/ in your browser
    üìó GET request to /
    üìó GET request to /styles/index.css
    üìó GET request to /scripts/index.js
    üìó GET request to /api/tips
    ```

  * Move the `app.use(clog)` method just above the `app.listen()` method and run the POST request again:

    ```bash
    Express server listening on port 3001! Visit http://localhost:3001/ in your browser
    ```

  * Note that the requests are no longer logged to the console.

  * üîë Order is important, as the file gets parsed from top to bottom. We want to make sure that the custom middleware mounts at the top of the `server.js` file.

* Ask the class the following questions (‚òùÔ∏è) and call on students for the answers (üôã):

  * ‚òùÔ∏è How could we end a request using custom middleware?

  * üôã We can use `res.end()` or `res.redirect()` to end the request-response cycle in custom middleware functions.

  * ‚òùÔ∏è What can we do if we don't completely understand this?

  * üôã We can refer to supplemental material, read the [Express.js documentation on writing middleware](https://expressjs.com/en/guide/writing-middleware.html), and stay for office hours to ask for help.

* Answer any questions before proceeding to the next activity.

### 8. Instructor Demo: Heroku (5 min)

* Navigate to `25-Ins_Heroku` in your command line and run `npm install` and `npm start`.

* Open `http://localhost:3001` in your browser to demonstrate the following:

  * üîë We have a single static webpage that is being served by Express.js in this demo.

  * üîë To share work with other people and host web apps, we will use a service called Heroku.

  * Let's work through these steps together to prepare for the next activity.

  * In your terminal, press Ctrl+C (Windows) or Command+C (macOS) to end the local web server and free up your terminal for the next step.

  * First make sure that you have already installed the Heroku CLI, by running the command `heroku --version` in your terminal.

    **Note**: For anyone who receives a `command not found` error, share the link to the [Heroku CLI download page](https://devcenter.heroku.com/articles/heroku-cli#download-and-install).

  * Next, using a dedicated secondary CLI, we will log into the Heroku CLI:

    ```sh
    heroku auth:login
    ```

    > **Note**: This will open a new browser window. Once you are logged in, it will ask you to close the browser and return to the terminal. If you encounter an issue and the prompt hangs after logging in, you can exit by pressing Ctrl+C (Windows) or Command+C (macOS). Then confirm by inputting `Y`. As an alternative, you can also try the legacy login method by using `heroku login -i`.

  * We will create a Git repository out of this demo and make a commit with all the files:

    ```sh
    git init
    git add -A
    git commit -m "Initial commit"
    ```

  * Heroku provides preconfigured environment variables for available ports. Let's make sure the server is configured to use them.

* Open `25-Ins_Heroku/server.js` in your IDE to demonstrate the following:

  * In the server file, double-check that the port variable is set to `process.env.PORT || 3001`.

  * Now that we have logged in, initialized a Git repo, and checked the port variable, we create a new app on Heroku using the following command -- which will also add the remote to the repository:

    ```sh
    heroku create
    ```

  * Then we check whether the remote URL for Heroku was added to the repository:

    ```sh
    git remote -v
    ```

  * Then we just push to Heroku:

    ```sh
    git push heroku main
    ```

  * This might take a moment, but once it completes, run `heroku open` to view the webpage!

* Ask the class the following questions (‚òùÔ∏è) and call on students for the answers (üôã):

  * ‚òùÔ∏è What does `process.env.PORT` refer to in the server file?

  * üôã `process.env.PORT` refers to an environment variable that is specified by Heroku.

* Answer any questions before proceeding to the next activity.

* In preparation for the activity, ask TAs to start directing students to the activity instructions found in `26-Stu_Heroku/README.md`.

### 9. Student Do: Heroku (15 min)

* Direct students to the activity instructions found in `26-Stu_Heroku/README.md`.

* Break your students into pairs that will work together on this activity.

  ```md
  # üìñ Deploy an Express.js App to Heroku

  Work with a partner to implement the following user story:

  * As a web developer, I want to deploy my application to services like Heroku so that I can share my app with the world.

  ## Acceptance Criteria

  * It's done when I have initialized a Git repository by running `git init` at the root of my existing project.

  * It's done when I have modified the `PORT` variable in `server.js` according to the Heroku documentation.

  * It's done when I have created a new Heroku app using the Heroku CLI.

  * It's done when I have verified that the Heroku remote URL was added using the appropriate Git command.

  * It's done when I have added and committed all my files and pushed to Heroku.

  * It's done after I have confirmed that the application was deployed successfully by running `heroku open`.

  ## üìù Notes

  Refer to the [Full-Stack Blog on installing the Heroku CLI](https://coding-boot-camp.github.io/full-stack/heroku/how-to-install-the-heroku-cli).

  Refer to the documentation:

  [Heroku documentation on getting started with Node.js](https://devcenter.heroku.com/articles/getting-started-with-nodejs?singlepage=true)

  [Heroku documentation on creating a Heroku remote](https://devcenter.heroku.com/articles/git#creating-a-heroku-remote)

  ---

  ## üí° Hints

  How can you use the command `heroku logs --tail` to troubleshoot deployment errors?

  ## üèÜ Bonus

  If you have completed this activity, work through the following challenge with your partner to further your knowledge:

  * When you created your Heroku account, you might have seen the [Heroku dashboard](https://dashboard.heroku.com/). What useful information can you learn about your application from this page?

  Use [Google](https://www.google.com) or another search engine to research this.
  ```

* While breaking everyone into groups, be sure to remind students and the rest of the instructional staff that questions on Slack or otherwise are welcome and will be handled. It's a good way for your team to prioritize students who need extra help.

### 10. Instructor Review: Heroku (10 min)

* Ask the class the following questions (‚òùÔ∏è) and call on students for the answers (üôã):

  * ‚òùÔ∏è How comfortable do you feel deploying applications to Heroku? (Poll via Fist to Five, Slack, or Zoom)

* Assure students that we will cover the solution to help solidify their understanding. If questions remain, remind them to use office hours to get extra help!

* Use the prompts and talking points (üîë) below to review the following key points:

  * ‚úîÔ∏è Heroku CLI

  * ‚úîÔ∏è `process.env.PORT`

  * ‚úîÔ∏è `heroku create`

* Open `26-Stu_Heroku/Unsolved/server.js` in your IDE and explain the following:

  * üîë The first step to deploying this application is to modify the `PORT` variable inside the `server.js` file:

    ```js
    const PORT = process.env.PORT || 3001;
    ```

  * üîë Next, we create a Git repository inside the folder that contains the code we want to deploy.

  * We also add and commit the files so that we have something to push to Heroku:

    ```sh
    git init
    git add -A
    git commit -m "Initial commit"
    ```

  * We need to create a new Heroku app for the UI/UX tips tracker:

    ```sh
    heroku create
    ```

  * Then we check whether the remote URL for Heroku was added to the repository:

    ```sh
    git remote -v
    ```

  * With the Git repository created, the code committed, and the Heroku app ready to deploy, we can now push directly to Heroku to run the build:

    ```sh
    git push heroku main
    ```

  * A successful build will output something like the following example:

    ```bash
    remote: -----> Build succeeded!
    remote: -----> Discovering process types
    remote:        Procfile declares types     -> (none)
    remote:        Default types for buildpack -> web
    remote:
    remote: -----> Compressing...
    remote:        Done: 33.8M
    remote: -----> Launching...
    remote:        Released v3
    remote:        https://vast-cliffs-60302.herokuapp.com/ deployed to Heroku
    remote:
    remote: Verifying deploy... done.
    To https://git.heroku.com/vast-cliffs-60302.git
    ```

  * We have pushed and built the Heroku app, so the next step is to verify that it works. We will open the app directly in the browser:

    ```sh
    heroku open
    ```

* Open a new integrated terminal window in your IDE to demonstrate the following:

  * We can view the output of the middleware function by checking the Heroku logs:

    ```sh
    heroku logs --tail
    ```

  * Note that we can see any requests made to the remote server, thanks to the custom middleware function.

* Ask the class the following questions (‚òùÔ∏è) and call on students for the answers (üôã):

  * ‚òùÔ∏è How does deploying your projects help you with your career goals?

  * üôã Having an application deployed helps show employers your work and demonstrate that you can learn a new cloud platform with relative ease.

  * ‚òùÔ∏è What can we do if we don't completely understand this?

  * üôã We can refer to supplemental material, read the [Heroku deployment guide on The Full-Stack Blog](https://coding-boot-camp.github.io/full-stack/heroku/heroku-deployment-guide), and stay for office hours to ask for help.

* Answer any questions before proceeding to the next activity.

* In preparation for the activity, ask TAs to start directing students to the activity instructions found in `27-Evr_Git-History/README.md`.

### 11. Everyone Do: Git History (20 min)

* Open the [Git documentation on git log](https://www.git-scm.com/docs/git-log) in your browser and explain the following:

  * The command `git log` provides a list of commits that have been made to a given repository. You can use it to query specific folders, authors, date ranges, and keywords, to get specific information about the history of your repository.

  * In this Git Guide, we explore the history of an open source project to learn how to use some lesser-known Git commands.

* Direct students to the activity instructions found in `27-Evr_Git-History/README.md`.

* While everyone is working on the activity, be sure to remind students and the rest of the instructional staff that questions on Slack or otherwise are welcome and will be handled. It's a good way for your team to prioritize students who need extra help.

* Open your command line and demonstrate the following:

  * When we run `git log`, we get an output to the command line that contains a list of previous commits. We can filter this information further to get exactly what we are looking for.

  * In preparation for the activity, visit the [GitHub repository for Inquirer.js](https://github.com/SBoudrias/Inquirer.js) and clone the repository to your local machine:

    ```bash
    git clone git@github.com:SBoudrias/Inquirer.js.git
    cd Inquirer.js
    ```

  * üîë This Git Guide also covers some additional commands, including `git blame`. For more information, refer to the [Git documentation on git blame](https://www.git-scm.com/docs/git-blame).

* Answer any questions before students go on break.

### 12. BREAK (40 min)

---

### 13. Instructor Demo: Mini-Project (5 min)

* Navigate to `28-Stu_Mini-Project/Main` in your command line and run `npm install` and `npm start`.

* Open `http://localhost:3001` in your browser to demonstrate the following:

  * üîë For the mini-project today, we will add two new routes to the UI/UX tips application.

  * üîë We will implement a wildcard route to direct users to a 404 page, as well as a diagnostics route to log information whenever a user submits a failed form submission.

* Open `http://localhost:3001/test` in your browser to demonstrate the following:

  * Note that when we visit a route that doesn't exist, the application directs us to a 404 page.

  * The 404 page contains a graphic and a button to return to the previous page.

* Open `http://localhost:3001/` in your browser to visit the main page once again:

  * We will input information that will cause the form validation to fail.

  * Enter a tip that is shorter than 15 characters and a username that is no longer than 4 characters:

    ```sh
    tip: short message
    username: test
    ```

  * These are the two conditions that we check for when validation fails.

  * üîë Note that we get an error message that the tip is invalid if it does not meet the length requirement.

  * The front end then makes a request to the `api/diagnostics` route, which logs the failed submission to the database -- or in this case, a `diagnostics.json` file.

* Open `28-Stu_Mini-Project/Main/db/diagnostics.json` in your IDE to demonstrate the following:

  * Note that the failed submission has been logged to the JSON file and given a unique identifier:

    ```json
    {
        "time": 1617228788871,
        "error_id": "11f8ee6f-a3c7-4b86-97d6-ae0eb763fc72",
        "errors": {
            "username": "Invalid username!",
            "tip": "Tip must be at least 15 characters",
            "topic": ""
        }
    }
    ```

  * Let's start adding these features to the UI/UX tips app!

* Ask the class the following questions (‚òùÔ∏è) and call on students for the answers (üôã):

  * ‚òùÔ∏è How would we build this?

  * üôã We can start by researching how to create a wildcard route in Express.js, to redirect users to a 404 HTML file. Additionally, we can create a POST route for `api/diagnostics`, to log the failed submissions. Finally, we create the `fetch()` request that will send the POST request to the diagnostics endpoint.

* Answer any questions before allowing students to start the mini-project.

### 14. Student Do: Mini Project (60 min)

* Direct students to the activity instructions found in `28-Stu_Mini-Project/README.md`.

* Break your students into groups that will work together on this activity.

  ```md
  # üèóÔ∏è Module 11 Mini-Project: Add Routes to Existing Application

  In this mini-project, you will work with a group to add routes to an existing application. You will create one wildcard route for serving up a 404 page, as well as a diagnostics route for logging failed form validation.

  * As a developer, I want to be able to add routes to an existing application.

  * As a developer, I want to serve up a custom 404 page when the requested resource doesn't exist.

  * As a developer, I want to log usage statistics from users of my site.

  * As a developer, I want to be able to deploy my apps to Heroku.

  ## Acceptance Criteria

  * It's done when I have created a wildcard route in `server.js` that will send the users to a 404 page.

  * It's done when I have created a custom `404.html` page for my wildcard route to serve.

  * It's done when I have created a POST route for `/api/diagnostics` that will store information about the invalid form submissions.

  * It's done when I have created a GET route for `/api/diagnostics` that will return the content of `db/diagnostics/json`.

  * It's done when I have created a `fetch()` request on the front end that will send a POST request to `/api/diagnostics` every time a user attempts to submit an invalid form.

  * It's done when I have tested my `/api/diagnostics` endpoint using Insomnia.

  * It's done when I have tested the wildcard route by visiting any non-existent path, like `http://localhost/test`.

  * It's done when I have deployed the finished application to Heroku.

  ---

  ## üí° Hints

  How can we declare a wildcard route in Express.js?

  How will `fs.writeFile()` help us log usage stats?

  ## üèÜ Bonus

  If you have completed this activity, work through the following challenge with your partner to further your knowledge:

  * How else could we implement statistics logging without making a request from the front end?

  Use [Google](https://www.google.com) or another search engine to research this.
  ```

* While breaking everyone into groups, be sure to remind students and the rest of the instructional staff that questions on Slack or otherwise are welcome and will be handled. It's a good way for your team to prioritize students who need extra help.

### 15. Instructor Review: Mini Project  (10 min)

* Ask the class the following questions (‚òùÔ∏è) and call on students for the answers (üôã):

  * ‚òùÔ∏è How comfortable do you feel with this mini-project? (Poll via Fist to Five, Slack, or Zoom)

* Assure students that we will cover the solution to help solidify their understanding. If questions remain, remind them to use office hours to get extra help!

* Use the prompts and talking points (üîë) below to review the following key points:

  * ‚úîÔ∏è Wildcard routes

  * ‚úîÔ∏è `fs.writeFile()`

  * ‚úîÔ∏è Modular routes

* Open `28-Stu_Mini-Project/Main/server.js` in your IDE and explain the following:

  * In `server.js`, we have a few routes for the root and some static HTML files. Let's begin by creating a wildcard route.

  * First we invoke `app.get()` -- but instead of providing a full path, we use an asterisk (`*`)to denote a wildcard route.

  * A **wildcard route** handles all paths that are not defined by one of the other route files. Much like any other route handler, it accepts a `res` and `req` object.

  * In the wildcard route, we use the `res.sendFile()` method to send a static `404.html` page located in the public directory:

    ```js
    app.get('*', (req, res) =>
      res.sendFile(path.join(__dirname, 'public/pages/404.html'))
    );
    ```

  * In the `server.js` file, we also want to make sure that we are allowing static files like images to be served from the public directory:

    ```js
    app.use(express.static('public'));
    ```

  * Now that we have the wildcard route and the static middleware, the next step is to create the static HTML file for this page.

* Open `28-Stu_Mini-Project/Main/public/pages/404.html` in your IDE to demonstrate the following:

  * The 404 page is a simple HTML file that contains an image and links to a JavaScript file:

    ```html
    ...
      <main class="text-center">
        <h1>The page you are looking for is in another castle.</h1>
        <img src="./images/notfound.jpg" />
        <section class="big-button">
          <button class="btn" id="back">Get me out of here!</button>
        </section>
      </main>
    <script src="./scripts/404.js"></script>
    ...
    ```

* Open `28-Stu_Mini-Project/Main/public/scripts/404.js` in your IDE to demonstrate the following:

  * In the front-end JavaScript for the 404 page, we need a selector for the go-back button, and a function to direct the user back to the page they were previously on:

    ```js
    const goBackBtn = document.getElementById('back');

    const goBack = (e) => {
      e.preventDefault();

      history.back();
    };

    goBackBtn.addEventListener('click', goBack);
    ```

    **Note**: The built-in browser API `history` allows us to manipulate the user's browsing history.

  * Next, we need to create the `api/diagnostics` route for logging failed form submissions.

* Open `28-Stu_Mini-Project/Main/routes/diagnostics.js` in your IDE to demonstrate the following:

  * First we create a new file called `diagnostics.js` in the routes directory. This file will contain all the routes that use the `/diagnostics` path.

  * We require `express.Router()` and assign it to a variable called `diagnostics`. We also import an npm package called `uuid` that will help generate UUIDs.

  * If we receive any failed submission data, we want to write that data to a `diagnostics.json` file. To do so, we also require some helper functions to read and write to the file:

    ```js
    const diagnostics = require('express').Router();
    const { v4: uuidv4 } = require('uuid');
    const { readAndAppend, readFromFile } = require('../helpers/fsUtils');
    ```

  * Then we create the POST route so that we can receive information from the front end when a user makes a form submission that doesn't validate:

    ```js
    diagnostics.post('/', (req, res) => { ... }
    ```

  * In this implementation, we expect a request body from the front end that contains an `isValid` property and an `errors` object. With this information, we create a `payload` object with a few extra properties, including `time` and `error_id`:

    ```js
    const { isValid, errors } = req.body;

    const payload = {
      time: Date.now(),
      error_id: uuidv4(),
      errors,
    };
    ```

  * Inside the route handler, we first check that the information we got from the front end is invalid. If so, we write that payload to the `diagnostics.json` file.

  * If the front end sent us a valid submission, we send back a message that the submission is unsuitable for logging because there was nothing wrong with it:

    ```js
    if (!isValid) {
      readAndAppend(payload, './db/diagnostics.json');
      res.json(`Diagnostic information added üîß`);
    } else {
      res.json({
        message: 'Object is valid, not logging. Check front end implementation',
        error_id: payload.error_id,
      });
    }
    ```

  * Finally, we export the diagnostics router for use in the main router file:

    ```js
    module.exports = diagnostics;
    ```

* Open `28-Stu_Mini-Project/Main/routes/index.js` in your IDE to demonstrate the following:

  * In the `index.js` route file, we import the diagnostics router and assign it to a variable called `diagnosticsRouter`:

    ```js
    const express = require('express');

    const tipsRouter = require('./tips');
    const feedbackRouter = require('./feedback');
    const diagnosticsRouter = require('./diagnostics');

    const app = express();

    app.use('/tips', tipsRouter);
    app.use('/feedback', feedbackRouter);
    app.use('/diagnostics', diagnosticsRouter);

    module.exports = app;
    ```

  * Now that we have the diagnostics route, we can create the `fetch()` request for the front end.

* Open `28-Stu_Mini-Project/Main/public/scripts/index.js` in your IDE to demonstrate the following:

  * In the `index.js` file for the front end, we create a POST request using a function called `submitDiagnostics()`.

  * This function accepts a submission object and gets invoked when the user-submitted data is invalid.

  * In the `options` object, we specify that we are making a POST request. Additionally, we convert the JSON object to a string using the `JSON.stringify()` function:

    ```js
    const submitDiagnostics = (submissionObj) => {
      fetch('/api/diagnostics', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(submissionObj),
      })
        .then((response) => response.json())
        .then(() => showErrors(submissionObj.errors))
        .catch((error) => {
          console.error('Error:', error);
        });
    };
    ```

* Ask the class the following questions (‚òùÔ∏è) and call on students for the answers (üôã):

  * ‚òùÔ∏è What other use cases can you envision for creating Express.js APIs?

  * üôã We can add back-end APIs to future projects and implement endpoints for databases.

  * ‚òùÔ∏è What can we do if we don't completely understand this?

  * üôã We can refer to supplemental material, read the [Express.js documentation on express()](https://expressjs.com/en/4x/api.html), and stay for office hours to ask for help.

* Answer any questions before proceeding to the next activity.

### 16. Instructor Demo: Introduce Challenge (5 min)

* Navigate to `02-Challenge/Main/` in your command line and run `npm install` and `npm start`.

* Open `http://localhost:3001` in your browser to demonstrate the following:

  * We are going to build a note-taking application using Express.js!

  * When this application is complete, we will be able to create notes, save notes to the file system, and retrieve notes from the back end.

  * The application features a useful interface for you to work with.

  * You will create HTML routes for `/api/notes` that will serve up a `notes.html` file.

  * You will implement a wildcard route that will serve up the `index.html` file.

  * Also, you will create some API endpoints for `api/notes` to GET and POST new notes.

  * You will implement some form of UUID management for each note.

  * As a bonus, you can optionally implement a DELETE route for a specific note.

  * Finally, you will deploy your application using Heroku!

* Ask the class the following questions (‚òùÔ∏è) and call on students for the answers (üôã):

  * ‚òùÔ∏è What are we learning?

  * üôã We are learning how to create a full-stack application using Express.js, with data persistent storage that allows for creating, reading, and optionally updating data.

  * ‚òùÔ∏è How does this project build off or extend previously learned material?

  * üôã This activity help you expand your skill set to the back end -- by combining your existing front-end knowledge with a new understanding of Express.js, to create a full-stack application.

  * ‚òùÔ∏è How does this project relate to your career goals?

  * üôã This project will help you become employer-ready by providing a new project that you can add to your portfolio. You will also demonstrate to future employers that you can deploy the apps that you create.

* Ask TAs to direct students to the Challenge Requirements found in `02-Challenge/README.md`.

* Advise students that the next module will have them working with MySQL and databases. Remind students that they will need to install MySQL Server on their machine before the beginning of the next module. Provide students with the [MySQL installation guide on The Full-Stack Blog](https://coding-boot-camp.github.io/full-stack/mysql/mysql-installation-guide) for installation instructions.

* Answer any questions before ending the class.

### 17. END (0 min)

How did today‚Äôs lesson go? Your feedback is important. Please take 5 minutes to complete this [anonymous survey](https://forms.gle/RfcVyXiMmZQut6aJ6).

---
¬© 2022 edX Boot Camps LLC. Confidential and Proprietary. All Rights Reserved.
