# 13.2 Part-Time Lesson Plan: Authentication

## Overview

As they continue to learn Sequelize in today's class, students will also be formally introduced to RESTful API paradigms. Along with `async` and `await`, they will use `try...catch` to properly catch errors and return them to the user. Students will incorporate validators and constraints to prevent bad data from being saved into the database. Also, they will learn about password hashing with `bcrypt`, incorporating Hooks, and creating a secure login route for users. They will create a custom method that corresponds to a custom route.

## Instructor Notes

* In this lesson, students will complete activities `11-Ins_RESTful-Routes` through `20-Stu_Instance-Method`.

* Google data breaches this year to find a list of businesses that have been recently affected by security issues. You can refer to this list during the Stoke Curiosity section of the lesson.

* Be sure to prepare and read over the activities before your class begins. Try to anticipate any questions that students might have.

* You will use MySQL for today's activities, so be sure to have your MySQL server up and running. You can create the database `user_db` ahead of time or demonstrate it live in class.

* Instead of relying on a front end, all of the activities will use Insomnia to test the routes. Be sure to have it installed and set up for class.

* Remind students to do a `git pull` of the class repo to have today's activities ready and open in VS Code.

* If you are comfortable doing so, live-code the solutions to the activities. If not, just use the solutions provided and follow the prompts and talking points for review.

* Let students know that the Bonus at the end of each activity is not meant to be extra coding practice, but instead is a self-study on topics beyond the scope of this module for those who want to further their knowledge.

## Learning Objectives

By the end of class, students will be able to:

* Catch errors with `try...catch`.

* Ensure that HTTP requests respond with the correct status code.

* Perform checks on a Sequelize model with validation tools.

* Encrypt a password with `bcrypt`.

* Automate functionality using Sequelize Hooks.

* Create and run a custom method on a Sequelize instance.

## Time Tracker

| Start  | #   | Activity Name                       | Duration |
| ------ | --- | ----------------------------------- | -------- |
| 6:30PM | 1   | Instructor Do: Stoke Curiosity      | 0:10     |
| 6:40PM | 2   | Instructor Demo: RESTful Routes     | 0:05     |
| 6:45PM | 3   | Student Do: RESTful Routes          | 0:15     |
| 7:00PM | 4   | Instructor Review: RESTful Routes   | 0:10     |
| 7:10PM | 5   | Instructor Demo: Validation         | 0:05     |
| 7:15PM | 6   | Student Do: Validation              | 0:15     |
| 7:30PM | 7   | Instructor Review: Validation       | 0:10     |
| 7:40PM | 8   | Instructor Demo: Password Hashing   | 0:05     |
| 7:45PM | 9   | Student Do: Password Hashing        | 0:15     |
| 8:00PM | 10  | BREAK                               | 0:15     |
| 8:15PM | 11  | Instructor Review: Password Hashing | 0:10     |
| 8:25PM | 12  | Instructor Demo: Hooks              | 0:05     |
| 8:30PM | 13  | Student Do: Hooks                   | 0:15     |
| 8:45PM | 14  | Instructor Review: Hooks            | 0:10     |
| 8:55PM | 15  | Instructor Demo: Instance Method    | 0:05     |
| 9:00PM | 16  | Student Do: Instance Method         | 0:15     |
| 9:15PM | 17  | Instructor Review: Instance Method  | 0:15     |
| 9:30PM | 18  | END                                 | 0:00     |

---

> **Important**: If this lesson occurs on a Saturday, make sure to adjust the activities to accommodate for the extra hour of class time. Feel free to take your time as you go through the activities; for example, you can add 5 minutes to the `Student Do` and `Instructor Review` sections as you see fit. Remember to take a 40-minute break at noon!

---

## Class Instruction

### 1. Instructor Do: Stoke Curiosity (10 min)

* Welcome students to class.

* The topic of today's lesson is authentication. Using the prompts provided, have a discussion about the importance of securing data.

* Ask the class the following questions (☝️) and call on students for the answers (🙋):

  * ☝️ What kind of sensitive data should we protect online?

  * 🙋 Answers might include banking information, social security number, tax information, credit card information, and more.

  * ☝️ What can happen if your password is compromised online?

  * 🙋 If your password is compromised, your online accounts can be hacked, exposing your sensitive data and even possibly leading to identity theft.

  * ☝️ Can you recall any high-profile data breaches that you heard about on the news, or a time when your account was hacked?

  * 🙋 Answers will vary. Refer back to the results of your Google search on data breaches (per the Instructor Notes) and share any highlights with students.

  * ☝️ As web developers, how can we help prevent data breaches?

  * 🙋 The ideal authentication platform should use both **password hashing** (scrambling user passwords so that they look different when we save them in the database) and **salting** (adding random data to the hashed password to make it truly unique). We will learn how to implement both of those security measures in this lesson, using a Node.js package called `bcrypt`!
  
* Answer any questions before proceeding to the next activity.

### 2. Instructor Demo: RESTful Routes (5 min)

* Open `11-Ins_RESTful-Routes` and run `npm install`. Be sure to change the `.env.EXAMPLE` file into your own `.env` file with your credentials. Then explain the following:

  * RESTful routes help us map between HTTP verbs and CRUD operations, to make requests more meaningful and reusable.

  * GET requests will read (or "get") a specific resource.

  * POST requests will create a new resource.

  * PUT requests will update an existing resource.

  * DELETE requests will delete an existing resource.

  * We use HTTP status codes for the responses that are returned to us.

* Run `npm start` from the command line and demonstrate the following in Insomnia:

  * 🔑 Before we look at the code, let's create a user in the database. We can do that by making a POST request to `localhost:3001/api/users/` and providing the following JSON data as the body of the request in Insomnia:

    ```json
    {
      "username": "user1",
      "email": "user1@email.com",
      "password": "Password123"
    }
    ```

  * 🔑 We check whether the data was saved correctly by making a GET request to that same URL (`localhost:3001/api/users/`). We should see the following response, as well as a `200 OK` status code:

    ```json
    [
      {
        "id": 1,
        "username": "user1",
        "email": "user1@email.com",
        "password": "Password123"
      }
    ]
    ```

* Open `11-Ins_RESTful-Routes/routes/api/userRoutes.js` in your IDE and explain the following:

  * As you can see, both routes use `async` and `await` and are fully functional. However, the POST route uses a `catch` block to catch all errors that might happen in the `try` block, as shown in the following example:

    ```js
    // the route will 'try' to do this action first
    try {
      const userData = await User.create(req.body);
      res.status(200).json(userData);

    // if there are any errors, it will 'catch' all of them here:
    } catch (err) {
      res.status(400).json(err);
      }
    ```

  * `try...catch` not only makes the code easier to read but also helps us catch all of the errors in one place.

  * Because we use `async` and `await` to avoid callbacks, it doesn't make sense to use the `.catch()` callback to catch errors like in the GET route. Refer to the following example:

    ```js
    router.get('/', async (req, res) => {
      const userData = await User.findAll().catch((err) => {
        res.json(err);
      });
      res.json(userData);
    });
    ```

  * Also, in the POST route, we incorporated proper HTTP status codes to know exactly what kind of error happened with the server. We use the `.status(xxx)` syntax to return the status code along with the error in JSON format, as follows:

    ```js
    catch (err) {
      // 400 status code means the server could not understand the request
      res.status(400).json(err);
    }
    ```

* Ask the class the following questions (☝️) and call on students for the answers (🙋):

  * ☝️ How would we build this?

  * 🙋 We would need to use `try...catch` to catch the errors and return the proper status codes along with the JSON response.

* Answer any questions before proceeding to the next activity.

* In preparation for the activity, ask TAs to start directing students to the activity instructions found in `12-Stu_RESTful-Routes/README.md`.

### 3. Student Do: RESTful Routes (15 min)

* Direct students to the activity instructions found in `12-Stu_RESTful-Routes/README.md`.

* Break your students into pairs that will work together on this activity.

  ```md
  # 🐛 Routes Return 200 Status Code Every Time

  Work with a partner to resolve the following issues:

  * As a developer, I want to see proper HTTP status codes returned so that I can be aware of any errors.

  * As a developer, I want to use `try...catch` to properly catch errors when using `async` and `await`.

  ## Expected Behavior

  * When there is no error with the request, the 200 status code is returned.

  * When there is an internal server error, the 500 status code is returned.

  * When a user does not exist in the database, the 404 status code is returned along with the following message:

    {
      "message": "No user with this id!"
    }

  ## Actual Behavior

  * Whether there is an error with the request or if the user does not exist in the database, the 200 status code is returned.

  ## Steps to Reproduce the Problem

  1. Run `npm start` in your command line to start the server.

  2. Open Insomnia and make a GET request to `api/users/10`.

  3. The 200 status code is returned.

  ---

  ## 💡 Hints

  How do we return HTTP status codes?

  ## 🏆 Bonus

  If you have completed this activity, work through the following challenge with your partner to further your knowledge:

  * What are some other common HTTP status codes?

  Use [Google](https://www.google.com) or another search engine to research this.
  ```

* While breaking everyone into groups, be sure to remind students and the rest of the instructional staff that questions on Slack or otherwise are welcome and will be handled. It's a good way for your team to prioritize students that need extra help.

### 4. Instructor Review: RESTful Routes (10 min)

* Ask the class the following questions (☝️) and call on students for the answers (🙋):

  * ☝️ How comfortable do you feel with `try...catch` and HTTP status codes? (Poll via Fist to Five, Slack, or Zoom)

* Assure students that we will cover the solution to help solidify their understanding. If questions remain, remind them to use office hours to get extra help!

* Use the prompts and talking points below to review the following key (🔑) points:

  * ✔️ `try...catch`

  * ✔️ 200 status code

  * ✔️ 500 status code

  * ✔️ 404 status code

* Open `12-Stu_RESTful-Routes/Solved/routes/api/userRoutes.js` in your IDE and explain the following:

  * Here we see a GET route to retrieve one user by their id, a PUT route to update a user, and a DELETE route to delete a user.

  * 🔑 Remember that we incorporated `try...catch` into all three routes to catch all of the errors that might happen in the `try` block.

  * 🔑 First, if there is no error with the request, the `200 OK` status code is returned, as follows:

    ```js
    res.status(200).json(userData);
    ```

  * 🔑 If there is an internal server error, the `500 Internal Server Error` status code is returned, as follows:

    ```js
    catch (err) {
      res.status(500).json(err);
    }
    ```
  
  * 🔑 If the user does not exist in the database, the `404 Not Found` status code is returned. But first we need to use an `if` statement to check whether the user exists in the database, like in the following example:

    ```js
    // GET a user
    router.get('/:id', async (req, res) => {
      try {
        const userData = await User.findByPk(req.params.id);
        if (!userData) {
          res.status(404).json({ message: 'No user with this id!' });
          return;
        }
        res.status(200).json(userData);
      } catch (err) {
        res.status(500).json(err);
      }
    });
    ```

* Ask the class the following questions (☝️) and call on students for the answers (🙋):

  * ☝️ Why should we use `try...catch` to catch errors when using `async` and `await`?

  * 🙋 Because `async` and `await` don't necessitate `then()` or `catch()` callbacks, we can use `try...catch` to handle any errors that the asynchronous function might return.

  * ☝️ How can we use status codes to enhance the user experience on the front end?

  * 🙋 A 400 status code can indicate to users that they caused the error, whereas a 500 status code can indicate that the error stemmed from a server problem.

  * ☝️ What can we do if we don't completely understand this?

  * 🙋 We can refer to supplemental material, read the [Wikipedia page on REST](https://en.wikipedia.org/wiki/Representational_state_transfer#Applied_to_web_services) and the [MDN Web Docs on HTTP response status codes](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status), and stick around for office hours to ask for help.

* Answer any questions before proceeding to the next activity.

### 5. Instructor Demo: Validation (5 min)

* Navigate to `13-Ins_Validation` and run `npm start` from the command line. Be sure to change the `.env.EXAMPLE` file into your own `.env` file with your credentials. Then demonstrate the following in Insomnia:

  * When securing and ensuring the quality of user data, it is important to prevent any bad data from being saved in the database. For example, what if a user's password is too short or not secure enough? Or what if someone tries to sign up with the same email address twice?

  * 🔑 Let's try to create a new user with the email address in the wrong email format. Make a POST request to `localhost:3001/api/users/` and provide the following JSON data as the body of the request in Insomnia:

    ```json
    {
      "username": "test1",
      "email": "test1",
      "password": "Password123"
    }
    ```

  * 🔑 We will get a `400 Bad Request` status code returned with an error, as follows:

    ```json
    {
      "name": "SequelizeValidationError",
      "errors": [
        {
          "message": "Validation isEmail on email failed",
          "type": "Validation error",
        }
      ]
      }
    ```

  * 🔑 This time we will create a new user with a correct email address, as shown in the following example:

    ```json
    {
      "username": "test1",
      "email": "test1@email.com",
      "password": "Password123"
    }
    ```

  * 🔑 That worked! But let's try to create another user with that same email address, as follows:

    ```json
    {
      "username": "test2",
      "email": "test1@email.com",
      "password": "Password123"
    }
    ```

  * 🔑 We get another `400 Bad Request` status code returned with a new error, as follows:

    ```json
    {
      "name": "SequelizeUniqueConstraintError",
      "errors": [
        {
          "message": "user.email must be unique",
          "type": "unique violation",
        }
      ]
    }
    ```

  * In this way, we can use validators and constraints on a Sequelize model to prevent bad data from entering the database.

* Open `13-Ins_Validation/models/User.js` in your IDE and explain the following:

  * We see a `User` model containing id, username, email, and password data. In the `email` attribute, we see the constraint `unique` set to `true`, as follows:

    ```js
    email: {
      type: DataTypes.STRING,
      unique: true,
    }
    ```

    This will prevent duplicate email addresses from being saved in the database.

  * **Constraints** are rules defined at the SQL level. If a constraint check fails, an error will be thrown by the database, and Sequelize will forward this error to JavaScript.

  * Next, we use a model validator to check that the email is in the correct email format, as follows:

    ```js
    email: {
      type: DataTypes.STRING,
      unique: true,
      validate: {
        isEmail:true,
      }
    }
    ```

  * **Validations** are checks performed at the Sequelize level, in pure JavaScript. Validations are automatically run on `create`, `update` and `save`.

* Ask the class the following questions (☝️) and call on students for the answers (🙋):

  * ☝️ How would we build this?

  * 🙋 We would need to add validators and constraints to the `User` model to prevent any bad data from being saved in the database.

* Answer any questions before proceeding to the next activity.

* In preparation for the activity, ask TAs to start directing students to the activity instructions found in `14-Stu_Validation/README.md`.

### 6. Student Do: Validation (15 min)

* Direct students to the activity instructions found in `14-Stu_Validation/README.md`.

* This activity uses **unit tests** to guide the students in creating the right validators and constraints.

* If needed, explain what the `npm run test` script does and demonstrate how to use it to run the unit tests.

* Break your students into pairs that will work together on this activity.

  ```md
  # 📖 Add Validations and Constraints to the User Model

  Work with a partner to implement the following user story:

  * As a developer, I want to add validations and constraints to the `User` model to prevent bad data from being saved in the database.

  ## Acceptance Criteria

  * It's done when it prevents `null` values from being entered for the username, email, and password fields.

  * It's done when it prevents the password from being shorter than eight characters.

  * It's done when it prevents the username from having any characters other than letters and numbers. 

  ## 📝 Notes

  Refer to the documentation: 

  [Sequelize documentation on validations and constraints](https://sequelize.org/master/manual/validations-and-constraints.html)

  ---

  ## 💡 Hints

  * Can you use the `npm run test` script in your command line for guidance?

  * What built-in validators can you use?

  ## 🏆 Bonus

  If you have completed this activity, work through the following challenge with your partner to further your knowledge:

  * What are **regular expressions**?

  Use [Google](https://www.google.com) or another search engine to research this.
  ```

* While breaking everyone into groups, be sure to remind students and the rest of the instructional staff that questions on Slack or otherwise are welcome and will be handled. It's a good way for your team to prioritize students that need extra help.

### 7. Instructor Review: Validation (10 min)

* Ask the class the following questions (☝️) and call on students for the answers (🙋):

  * ☝️ How comfortable do you feel with validations and constraints for your models in Sequelize? (Poll via Fist to Five, Slack, or Zoom)

* Assure students that we will cover the solution to help solidify their understanding. If questions remain, remind them to use office hours to get extra help!

* Use the prompts and talking points below to review the following key (🔑 ) points:

  * ✔️ `allowNull`

  * ✔️ `isAlphanumeric`

  * ✔️ `len`

* Open `14-Stu_Validation/Solved/models/User.js` in your IDE and explain the following:

  * 🔑 First, we want to prevent `null` values from being entered for all fields. To do that, we use the `allowNull` constraint and set it to `false`, as follows:

    ```js
    username: {
      type: DataTypes.STRING,
      // prevents null values
      allowNull: false,
    },
    email: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    password: {
      type: DataTypes.STRING,
      allowNull: false,
    },
      ```

  * 🔑 Next, we want to ensure that the password is longer than eight characters. So we use a built-in validator called `len` and specify the character count, as shown in the following example:

    ```js
    password: {
      type: DataTypes.STRING,
      allowNull: false,
      // must be longer than 8 characters
      validate: {
        len: [8],
      },
    },
    ```

  * 🔑 Finally, for the username, we only want to allow letters and numbers&mdash;no symbols or other characters. For that, we use another built-in validator called `isAlphanumeric` and set it to `true`, as shown in the following example:

    ```js
    username: {
      type: DataTypes.STRING,
      allowNull: false,
      // will only allow alphanumeric characters
      validate: {
        isAlphanumeric: true,
      },
    },
    ```

* Ask the class the following questions (☝️) and call on students for the answers (🙋):

  * ☝️ How can we write the `isAlphanumeric` validator using regular JavaScript?

  * 🙋 We can break it down by saying that we will only allow letters between A and Z as well as numbers 0 to 9. **Regex** (regular expression) operations use that kind of logic when finding patterns in text.

  * ☝️ What can we do if we don't completely understand this?

  * 🙋 We can refer to supplemental material, read the [Sequelize documentation on validations and constraints](https://sequelize.org/master/manual/validations-and-constraints.html), and stick around for office hours to ask for help.

* Answer any questions before proceeding to the next activity.

### 8. Instructor Demo: Password Hashing (5 min)

* Navigate to `15-Ins_Password-Hashing` and be sure to change the `.env.EXAMPLE` file into your own `.env` file with your credentials.

* Open `15-Ins_Password-Hashing/routes/api/userRoutes.js` in your IDE and demonstrate the following:

  * Like we discussed earlier, password hashing is a crucial step in securing user data in the database. An application's first interaction with a user password occurs as soon as that user creates an account.
  
  * In that first interaction, we must intervene and hash the plaintext password before it is stored in the database. To do this, we use a Node.js package called `bcrypt`.

  * 🔑 First we import `bcrypt` into the `userRoutes.js` file by adding the `require` expression at the top of the file, as shown in the following code:

    ```js
    const bcrypt = require('bcrypt');
    ```

  * 🔑 In the POST route to create a new user, we take the data for a new user from `req.body` and assign it to `newUser`, as shown in the following code:

    ```js
    router.post('/', async (req, res) => {
      try {
        const newUser = req.body;
    ```

  * 🔑 Then, in the `bcrypt` hash function, we pass in the `req.body.password`, which is the plaintext password created by the user. We also pass in a `saltRound` value of `10`. The resulting hashed password is then saved as the `newUser.password`, as follows:

    ```js
    router.post('/', async (req, res) => {
      try {
        const newUser = req.body;
        newUser.password = await bcrypt.hash(req.body.password, 10);
    ```

  * Next we create a new user using the `newUser` data with the hashed password, and we save it in the database, as follows:

    ```js
    router.post('/', async (req, res) => {
      try {
        const newUser = req.body;
        newUser.password = await bcrypt.hash(req.body.password, 10);
        const userData = await User.create(newUser);
    ```

* Run `npm start` in your command line and demonstrate the following in Insomnia:

  * We will make a POST request to `localhost:3001/api/users/` to create a new user. Notice that the password is `Password123` in plaintext, as shown in the following example:

    ```json
    {
      "username": "test2",
      "email": "test2@email.com",
      "password": "Password123"
    }
    ```

  * When we see the returned data, we see that the password saved in the database is hashed and salted&mdash;as shown in the following example:

    ```json
    {
      "id": 4,
      "username": "test2",
      "email": "test2@email.com",
      "password": "$2b$10$pQgQagcm85YW1b/0j5MrU.iH2iSCsne.FAMjcxp6izuXEJH.lgiqS"
    }
    ```

* Ask the class the following questions (☝️) and call on students for the answers (🙋):

  * ☝️ How would we build this?

  * 🙋 We would need to use `bcrypt` to hash the password before saving a new user in the database.

* Answer any questions before proceeding to the next activity.

* In preparation for the activity, ask TAs to start directing students to the activity instructions found in `16-Stu_Password-Hashing/README.md`.

### 9. Student Do: Password Hashing (15 min)

* Direct students to the activity instructions found in `16-Stu_Password-Hashing/README.md`.

* Break your students into pairs that will work together on this activity.

  ```md
  # 📐 Add Comments to Implementation of the Login Route

  Work with a partner to add comments describing the functionality of the code found in [Unsolved](./Unsolved/routes/api/user-routes.js).

  ## 📝 Notes

  Refer to the documentation: 

  [npm documentation on bcrypt](https://www.npmjs.com/package/bcrypt)

  ---

  ## 🏆 Bonus

  If you have completed this activity, work through the following challenge with your partner to further your knowledge:

  * How can we persist a login state?

  Use [Google](https://www.google.com) or another search engine to research this.
  ```

* While breaking everyone into groups, be sure to remind students and the rest of the instructional staff that questions on Slack or otherwise are welcome and will be handled. It's a good way for your team to prioritize students that need extra help.

### 10. BREAK (15 min)

### 11. Instructor Review: Password Hashing (10 min)

* Ask the class the following questions (☝️) and call on students for the answers (🙋):

  * ☝️ How comfortable do you feel with password hashing using `bcrypt`? (Poll via Fist to Five, Slack, or Zoom)

* Assure students that we will cover the solution to help solidify their understanding. If questions remain, remind them to use office hours to get extra help!

* Use the prompts and talking points below to review the following key (🔑) points:

  * ✔️ `findOne()`

  * ✔️ `res.status(404)`

  * ✔️ `bcrypt.compare()`

  * ✔️ `res.status(400)`

* Open `16-Stu_Password-Hashing/Solved/routes/api/userRoutes.js` in your IDE and explain the following:

  * For this reverse-engineering activity, we had to add comments describing the `/login` route.

  * 🔑 First, we need to search the database for a user with the provided email that the user used to login. We do that by using `.findOne()`, as follows:

    ```js
    router.post('/login', async (req, res) => {
      try {
        const userData = await User.findOne({ where: { email: req.body.email } });
    ```

  * 🔑 If we cannot find any user in the database with that email address, we need to return a 404 status code with an error message.
  
  * However, be careful not to specify which part of the login attempt failed. Revealing that information could help hackers figure out whether they need to use a different email address or password, making it easier to access sensitive data! Refer to the following message for an example of an error message:

    ```js
    if (!userData) {
      res.status(404).json({ message: 'Login failed. Please try again!' });
      return;
    }
    ```

  * 🔑 If the user is found in the database, then we use `bcrypt.compare()` to compare the user password with the hashed password saved in the database, as follows:

    ```js
    const validPassword = await bcrypt.compare(
      req.body.password,
      userData.password
    );
    ```

  * 🔑 If the password does not match, then we need to return a 400 status code with an error message. Again, we should avoid specifying what was wrong with the login info provided. See the following message for an example:

    ```js
    if (!validPassword) {
      res.status(400).json({ message: 'Login failed. Please try again!' });
      return;
    }
    ```

  * If everything goes well, we return a 200 status code with a success message, as follows:

    ```js
    res.status(200).json({ message: 'You are now logged in!' });
    ```

* Ask the class the following questions (☝️) and call on students for the answers (🙋):

  * ☝️ Rather than doing this in the routes, where is a better place to handle password hashing?

  * 🙋 In the `User` model! Because the password is directly related to the `User` model, it is better to handle the password hashing using Hooks in the model file.

  * ☝️ What can we do if we don't completely understand this?

  * 🙋 We can refer to supplemental material, read the [npm documentation on bcrypt](https://www.npmjs.com/package/bcrypt), and stick around for office hours to ask for help.

* Answer any questions before proceeding to the next activity.

### 12. Instructor Demo: Hooks (5 min)

* Navigate to `17-Ins_Hooks` and be sure to change the `.env.EXAMPLE` file into your own `.env` file with your credentials.

* Open `17-Ins_Hooks/models/User.js` in your IDE and demonstrate the following:
  
  * As we've seen so far, Sequelize offers many tools that make it easier for us to communicate with the database. For example, **Hooks** can help us perform actions before and after calls in Sequelize are executed.

  * 🔑 There are many Hooks available to us through Sequelize, but for now we will only touch on `beforeCreate()` and `beforeUpdate()`.

  * 🔑 We can declare Hooks in a few ways. For this activity, we will declare a Hook via the `init()` method in the `User` model.

  * 🔑 When including Hooks via the `init()` method, we add them between where the model attributes are defined and where the connection instance is passed, as follows:

    ```js
    User.init(
      {
        //model attributes
      },
      {
        hooks: {
          // hooks
        },
        ///connection instance
      }
    );
    ```

  * We are passing `newUserData` into both the `beforeCreate()` and the `beforeUpdate()` Hooks, so that whenever a user instance is created or updated, these Hooks have access to the user data.

  * 🔑 The `beforeCreate()` method accepts `newUserData`, uses `toLowerCase()` to set the email address to lowercase, and then returns `newUserData` with the newly formatted email address&mdash;as shown in the following example:

    ```js
    beforeCreate: async (newUserData) {
      newUserData.email = await newUserData.email.toLowerCase();
      return newUserData;
    },
    ```

  * 🔑 The `beforeUpdate()` method is identical to `beforeCreate()` in the `User` model, as follows:

    ```js
    beforeUpdate: async (newUserData) {
      newUserData.email = await newUserData.email.toLowerCase();
      return newUserData;
    },
    ```

    However, there is one small difference regarding the `beforeUpdate()` Hook, located in `userRoutes.js`. We will discuss this difference next.

* Open `17-Ins_Hooks/routes/api/userRoutes.js` and scroll down to the PUT route, then demonstrate the following:

  * We add the option `individualHooks: true` because the `update()` method could potentially match more than one entry, and we want the Hook to run on each match. Refer to the following code for an example:

    ```js
    router.put('/:id', async (req, res) => {
      try {
        const userData = await User.update(req.body, {
          where: {
            id: req.params.id,
          },
          individualHooks: true
        });
    ```

* To test the Hooks, run `npm start` from the command line and demonstrate the following in Insomnia:

  * 🔑 We will make a POST request to `http://localhost:3001/api/users` to create a new user. Notice that the email address is capitalized in the body of the request, as follows:

    ```json
    {
      "username": "test",
      "email": "TEST@email.com",
      "password": "Password123"
    }
    ```

  * 🔑 When the data is returned, we should see that the email address has been saved in lowercase, as follows:

    ```json
    {
      "username": "test",
      "email": "test@email.com",
      "password": "Password123"
    }
    ```

  * 🔑 We will make a PUT request to `http://localhost:3001/api/users/1` to update the user we just created, as shown in the following example:

    ```json
    {
      "username": "test",
      "email": "TEST1234@email.com",
      "password": "Password123"
    }
    ```

  * 🔑 When the data is returned, we should see that the email address has been updated and stored in lowercase, as shown in the following example:

    ```json
    {
      "username": "test",
      "email": "test1234@email.com",
      "password": "Password123"
    }
    ```

* Ask the class the following questions (☝️) and call on students for the answers (🙋):

  * ☝️ How can we use Hooks to automate `bcrypt` password hashing for users?

  * 🙋 We can add Hooks to the `User` model to hash passwords for user instances before they are created or updated.

* Answer any questions before proceeding to the next activity.

* In preparation for the activity, ask TAs to start directing students to the activity instructions found in `18-Stu_Hooks/README.md`.

### 13. Student Do: Hooks (15 min)

* Direct students to the activity instructions found in `18-Stu_Hooks/README.md`.

* Break your students into pairs that will work together on this activity.

  ```md
  # 🏗️ Use Hooks to Hash a Password

  Work with a partner to implement the following user story:

  * As a user, I want to be able to log in with my password.

  * As a user, I want to be able to change my password.

  * As a user, I want to know that my password is being stored securely.

  ## Acceptance Criteria

  * It's done when `User.init()` includes Hooks to hash the user's password before it is created.

  * It's done when `User.init()` includes Hooks to hash the user's password before it is updated, only if a password is provided in the paylod.

  ## 💡 Hints

  * What have you learned about hashing a password, `async` and `await`, and `try...catch`? 

  * What are three methods for adding Hooks to your code? How is adding a Hook via `init()` different from the other options?

  ## 🏆 Bonus

  If you have completed this activity, work through the following challenge with your partner to further your knowledge:

  * Hooks are considered **middleware** in programming terms. What are some other examples of middleware used in Node applications?

  Use [Google](https://www.google.com) or another search engine to research this.
  ```

* While breaking everyone into groups, be sure to remind students and the rest of the instructional staff that questions on Slack or otherwise are welcome and will be handled. It's a good way for your team to prioritize students that need extra help.

### 14. Instructor Review: Hooks (10 min)

* Ask the class the following questions (☝️) and call on students for the answers (🙋):

  * ☝️ How comfortable do you feel using Hooks in Sequelize? (Poll via Fist to Five, Slack, or Zoom)

* Assure students that we will cover the solution to help solidify their understanding. If questions remain, remind them to use office hours to get extra help!

* Use the prompts and talking points below to review the following key (🔑) points:

  * ✔️ `beforeCreate()`

  * ✔️ `beforeUpdate()`

  * ✔️ Hashing passwords inside Hooks with `bcrpyt`

* Open `18-Stu_Hooks/Solved/models/User.js` in your IDE and explain the following:

  * 🔑 We create a `beforeCreate()` Hook in the `User.js` file to make sure that a user can create a profile and that their password will be stored securely with `bcrypt` before the record is stored, as shown in the following example:

    ```js
    beforeCreate: async (newUserData) => {
      newUserData.password = await bcrypt.hash(newUserData.password, 10);
      return newUserData;
    }  
    ```

  * 🔑 The user's password is set as equal to a hashed password, using `bcrypt`. Then `newUserData` is returned, as follows:

    ```js
    beforeCreate: async (newUserData) => {
      newUserData.password = await bcrypt.hash(newUserData.password, 10);
      return newUserData;
    }   
    ```

  * `async` and `await` are included in the method, to write cleaner code that enables Promise-based behavior, as follows:

    ```js
    beforeCreate: async (newUserData) => {
      newUserData.password = await bcrypt.hash(newUserData.password, 10);
      return newUserData;
    }  
    ```
  
  * 🔑 We can repeat the preceding steps to create the `beforeUpdate()` method. However, we add a conditional statement that will only hash a user's password if it is included in the payload. Without this conditional statement, the user's information could become corrupted and they would not be able to login. We accomplish this as follows:

    ```js
    beforeUpdate: async (updatedUserData) => {
      if (updatedUserData.password) {
        updatedUserData.password = await bcrypt.hash(updatedUserData.password, 10);
        }
      return updatedUserData;
    },
    ```

* Ask the class the following questions (☝️) and call on students for the answers (🙋):

  * ☝️ What other commonly used Hooks are available to us?

  * 🙋 We could also use the `afterCreate`, `afterUpdate`, `beforeDestroy`, and `afterDestroy` Hooks, among others.

  * ☝️ What can we do if we don't completely understand this?

  * 🙋 We can refer to supplemental material, read the [Sequelize documentation on Hooks](https://sequelize.org/master/manual/hooks.html), and stick around for office hours to ask for help.

* Answer any questions before proceeding to the next activity.

### 15. Instructor Demo: Instance Methods (5 min)

* Navigate to `19-Ins_Instance-Method` and be sure to change the `.env.EXAMPLE` file into your own `.env` file with your credentials.

* Open `19-Ins_Instance-Method/models/User.js` in your IDE and demonstrate the following:

  * 🔑 Sometimes we want to access only a specific data point rather than ALL of the data associated with a user. For example, maybe we want to know if a user in a pet adoption database currently has any pets. Instead of using GET to return all of that user's information, we can use **instance methods** to find the specific data we want&mdash;whether that user has pets or not.

  * 🔑 Sequelize allows us to write instance methods within models (in this example, the `User` model) to access specific data that we can then return to users.
  
  * Let's look at `User.js`. In the following example, to create a user instance for the pet adoption database, we must include the number of pets that a user currently has:

    ```js
    User.init(
      {
        // previous model attributes above...
        
        numberOfPets: {
          type: DataTypes.INTEGER,
        },
      },
    )
    ```

* Run `npm start` from the command line and demonstrate the following in Insomnia:

  * 🔑 We will make a POST request to `http://localhost:3001/api/users` to create a new user. We've set `numberOfPets` equal to `2`, as follows, because the user has two pets:

    ```json
    {
      "username": "test",
      "email": "test@email.com",
      "password": "Password123",
      "numberOfPets": 2
    }
    ```

  * 🔑 When the data is returned, we should see that the user's pets have been stored in the record, as follows:

    ```json
    {
      "username": "test",
      "email": "test@email.com",
      "password": "Password123",
      "numberOfPets": 2
    }
    ```

  * Many users in this pet adoption database might not have pets yet, so let's create another user to reflect that. See the following code for an example:

    ```json
    {
      "username": "test2",
      "email": "test2@email.com",
      "password": "Password890",
      "numberOfPets": 0
    }
    ```

  * When the data is returned, we should see that this user's pets have been stored in the record as `"numberOfPets": 0`. Refer to the following code for an example:

    ```json
    {
      "username": "test2",
      "email": "test2@email.com",
      "password": "Password890",
      "numberOfPets": 0
    }
    ```

  * We have created the users; now we want to check whether a user has pets or not&mdash;without returning ALL of their information&mdash;by creating an instance method.

  * 🔑 Let's look at the `User` model in `User.js`. Note the simple instance method called `hasPets` at the top.
  
  * Inside the instance method, we use a conditional statement to check whether `this.numberOfPets` (where `this` represents one particular user) is greater than 0. If the number is greater than 0, it returns `true`. Otherwise, it returns `false`. Refer to the following statement for an example:

    ```js
    class User extends Model {
      // This instance method uses a conditional statement to check if a user has pets
      hasPets() {
      if (this.numberOfPets > 0) {
          return true;
        } else {
        return false;
        }
      }
    }
    ```

  * The instance method checks whether a user has any pets, but now we need to make sure that this method is actually usable. To do that, we need to write a custom route.

* 🔑 Open `19-Ins_Instance_Method/routes/api/userRoutes.js` in your IDE and demonstrate the following:

  * 🔑 We have included a new route specifically for the instance method `hasPets`, as follows:

    ```js
    router.get('/:id/hasPets', async (req, res) => {

    }
    ```
  
  * First we find a user by their primary key (provided by params). If `userData` evaluates as `false` (no user exists with that primary key), then we will send an error message&mdash;as shown in the following example:

    ```js
    try {
      const userData = await User.findByPk(req.params.id);
      if (!userData) {
        res.status(404).json({ message: 'No user with this id!' });
        return;
      }
    ```
  
  * If a user does exist at the primary key, we get to use the instance method that we wrote in `User.js` to see if that user has pets, as follows:

    ```js
    const petData = userData.hasPets();
    ```
  
  * If `petData` evaluates as `false` (the user has no pets), then the user will receive the message `"This person has no pets."` See the following code for an example:
  
    ```js
    if (!petData) {
      res.status(400).json({ message: 'This person has no pets.' });
      return;
    }
    ```

  * Otherwise, the user will see the message `"This person has pets!"` The code here should look something like the following example:

    ```js
    res.json({ message: 'This person has pets!' });
    ```
  
* If you have time, run `npm start` from the command line and demonstrate the following in Insomnia:

  * 🔑 We will make a GET request to `http://localhost:3001/api/users/1/hasPets` to check the route and instance method.

  * 🔑 When the data is returned, we should see the following message, because the first user we created did have pets:

    ```json
    {
      "message": "This person has pets!"
    }
    ```

  * 🔑 Now let's check the second user. We will make a GET request to `http://localhost:3001/api/users/2/hasPets`.

  * 🔑 When the data is returned, we should see the following message, because the second user we created had no pets:

    ```json
    {
      "message": "This person has no pets."
    }
    ```

* Ask the class the following questions (☝️) and call on students for the answers (🙋):

  * ☝️ How would we return specific data about one instance?

  * 🙋 We would add an instance method inside the model to return specific data about that one instance.

* Answer any questions before proceeding to the next activity.

* In preparation for the activity, ask TAs to start directing students to the activity instructions found in `20-Stu_Instance-Method/README.md`.

### 16. Student Do: Instance Methods (15 min)

* Direct students to the activity instructions found in `20-Stu_Instance-Method/README.md`.

* Break your students into pairs that will work together on this activity.

  ```md
  # 🏗️ Create a Custom Instance Method

  Work with a partner to implement the following user story:

  * As a user, I want to log in to my account with my password.

  * As a developer, I want to allow a user to log in to their account securely so that their password information isn't compromised. 

  ## Acceptance Criteria

  * It's done when the model includes an instance method.

  * It's done when the instance method compares the user's input with the user's hashed password.

  ## 💡 Hints

  What tools does `bcrypt` offer to help us compare user input to a hashed password?

  ## 🏆 Bonus

  If you have completed this activity, work through the following challenge with your partner to further your knowledge:

  * How can we DRY up the code using Sequelize's static model methods?

  Use [Google](https://www.google.com) or another search engine to research this.
  ```

* While breaking everyone into groups, be sure to remind students and the rest of the instructional staff that questions on Slack or otherwise are welcome and will be handled. It's a good way for your team to prioritize students that need extra help.

### 17. Instructor Review: Instance Methods (15 min)

* Ask the class the following questions (☝️) and call on students for the answers (🙋):

  * ☝️ How comfortable do you feel adding instance methods to your models? (Poll via Fist to Five, Slack, or Zoom)

* Assure students that we will cover the solution to help solidify their understanding. If questions remain, remind them to use office hours to get extra help!

* Use the prompts and talking points below to review the following key (🔑) points:
  
  * ✔️ `checkPassword()`

  * ✔️ `bcrypt.compareSync()`

* Open `20-Stu_Instance-Methods/Solved/routes/api/userRoutes.js` in your IDE and explain the following:

  * The `checkPassword()` instance method is used in the `/login` route. Understanding how `checkPassword()` is being used in the `/login` route can give us clues to what the instance method needs to accomplish.

  * We can tell from the `/login` route that the instance method will need to take in the user's password (from `req.body`) as an argument and then determine whether it matches the password stored in that user's record&dash;as shown in the following example:

    ```js
    router.post('/login', async (req, res) => {
      
      const validPassword = await userData.checkPassword(req.body.password);
      if (!validPassword) {
        res
          .status(400)
          .json({ message: 'Incorrect email or password, please try again' });
        return;
      }
      res.json({ user: userData, message: 'You are now logged in!' });
      };
    ```

* Open `20-Stu_Instance-Methods/Solved/models/User.js` in your IDE and explain the following:

  * 🔑 First, we want to write the instance method `checkPassword()` inside the `User` model in `User.js`, as follows:

    ```js
    class User extends Model {
      checkPassword(loginPw) {
        
        }
    }
    ```

  * 🔑 `bcrypt` offers a method called `compareSync()` that allows us to easily check a password. As shown in the following example, it takes two arguments&mdash;`loginPw` (the password sent in the body of the POST request) and `this.password` (the password stored in this particular user record):

    ```js
    class User extends Model {
      checkPassword(loginPw) {
        bcrypt.compareSync(loginPw, this.password);
        }
    }
    ```

  * Remember, the `/login` route expects `checkPassword()` to evaluate as either `true` or `false`. `compareSync` returns a Boolean&mdash;so all we need to do is return it in the instance method, as follows:

    ```js
    class User extends Model {
      checkPassword(loginPw) {
        return bcrypt.compareSync(loginPw, this.password);
      }
    }
    ```
  
* If you have time, run `npm start` from the command line and demonstrate the following in Insomnia:

  * We will make a POST request to `http://localhost:3001/api/users` to create a new user, as shown in the following example:

    ```json
    {
      "username": "test",
      "email": "test@email.com",
      "password": "Password123"
    }
    ```

  * When the data is returned, the password is hashed because `User.js` includes a `beforeCreate` Hook that uses `bcrypt` to hash the user's password, as follows:

    ```json
    {
      "id": 1,
      "username": "test",
      "email": "test@email.com",
      "password": "$2b$10$ItAeYIqhuEzADqxHsMe6Mu.r3lzZ.Ewb0gnWw0md3OkRsqPnFKbbG"
    }
    ```

  * Now we will make a POST request to `http://localhost:3001/api/users/login` to log in, as shown in the following example:

    ```json
    {
      "email": "test@email.com",
      "password": "Password123"
    }
    ```

  * If the code is working, we should see the following message when the data is returned:  

    ```json
    {
      "user": {
        "id": 1,
        "username": "test",
        "email": "test@email.com",
        "password": "$2b$10$ItAeYIqhuEzADqxHsMe6Mu.r3lzZ.Ewb0gnWw0md3OkRsqPnFKbbG"
      },
      "message": "You are now logged in!"
    }
    ```

* Ask the class the following questions (☝️) and call on students for the answers (🙋):

  * ☝️ When do you need to incorporate an instance method into your model?

  * 🙋 When you need to get data or do something related to one specific instance of a model.

  * ☝️ What can we do if we don't completely understand this?

  * 🙋 We can refer to supplemental material, read the [Sequelize documentation on model instances](https://sequelize.org/master/manual/model-instances.html), and stick around for office hours to ask for help.

* Answer any questions before ending the class.

### 18. END (0 min)

How did today’s lesson go? Your feedback is important. Please take 5 minutes to complete this [anonymous survey](https://forms.gle/RfcVyXiMmZQut6aJ6).

---
© 2022 edX Boot Camps LLC. Confidential and Proprietary. All Rights Reserved.
