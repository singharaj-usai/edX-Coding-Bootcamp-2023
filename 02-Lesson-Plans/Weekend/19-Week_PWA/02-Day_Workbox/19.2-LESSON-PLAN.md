# 19.2 Part-Time Lesson Plan: Introduction to Workbox, Caching, and Service Workers

## Overview

In this class, students will learn about webpack's Hot Module Reloading and gain familiarity with both the client-server model and the use of the npm package concurrently. Students will also learn how to use the workbox library to generate a service worker and cache assets.

## Instructor Notes

* In this lesson, students will complete activities `11-Ins_Webpack-HMR` through `20-InjectManifest`.

* This module features activities that will require students to save and refresh the browser in order to see changes. The very nature of PWAs means that, by design, students will likely run into issues with cached assets interfering while debugging and testing.

  > **Important**: If you are having issues with cached assets, please use a private or incognito window to view the application. For Chrome users, you can open an incognito window by clicking the three dots in the top-right corner of the browser. From there, click the "New Incognito Window" button. You can also use hot keys to open an incognito window: on macOS, press Command + Shift + N; on Windows, press Control + Shift + N.

* In addition to using an incognito window, students can troubleshoot caching issues further by completely unregistering the service worker. This will allow the browser to cache the assets again. Details on how to do this will vary among browsers, but generally you can find the option to do this in the browser's developer tools.

* To avoid caching issues when demonstrating the activities using an Express server, another strategy is to simply change the port used in the `server.js` file to a port you have not used for a previous activity such as `3009`. This will avoid the need to constantly refresh to see the latest build.

* During Stoking Curiosity, you will play the following short video in YouTube: ["One Last Thing" by Steve Jobs at Worldwide Developer Conference 07'](https://youtu.be/ZlE7dzoD6GA). If time allows, please review the 3-minute video prior to class so that you can respond to any student questions.

* Remind students to do a `git pull` of the class repo and to have today's activities ready and open in VS Code.

* If you are comfortable doing so, live code the solutions to the activities. If not, just use the solutions provided and follow the prompts and talking points for review.

* Let students know that the Bonus at the end of each activity is not meant to be extra coding practice, but instead is a self-study on topics beyond the scope of this module for those who want to further their knowledge.

## Learning Objectives

By the end of class, students will be able to:

* Incorporate Hot Module Reloading to a webpack app to improve the development experience.

* Identify the client-server model.

* Explain the use case npm package concurrently in the development environment.

* Implement service workers to a web application using workbox.

* Leverage caching strategies to optimize performance.

## Time Tracker

| Start  | #   | Activity Name                                     | Duration |
| ------ | --- | ------------------------------------------------- | -------- |
| 6:30PM | 1   | Instructor Do: Stoke Curiosity                    | 0:10     |
| 6:40PM | 2   | Instructor Demo: Hot Module Replacement           | 0:05     |
| 6:45PM | 3   | Student Do: Hot Module Replacement                | 0:15     |
| 7:00PM | 4   | Instructor Review: Hot Module Replacement         | 0:10     |
| 7:10PM | 5   | Instructor Demo: Client-Server Model              | 0:05     |
| 7:15PM | 6   | Student Do: Client-Server Model                   | 0:15     |
| 7:30PM | 7   | Instructor Review: Client-Server Model            | 0:10     |
| 7:40PM | 8   | Instructor Demo: Workbox Service Workers          | 0:05     |
| 7:45PM | 9   | Student Do: Workbox Service Workers               | 0:15     |
| 8:00PM | 10  | BREAK                                             | 0:15     |
| 8:15PM | 11  | Instructor Review: Workbox Service Workers        | 0:10     |
| 8:25PM | 12  | Instructor Demo: Caching Images                   | 0:05     |
| 8:30PM | 13  | Student Do: Caching Images                        | 0:15     |
| 8:45PM | 14  | Instructor Review: Caching Images                 | 0:10     |
| 8:55PM | 15  | Instructor Demo: InjectManifest                   | 0:05     |
| 9:00PM | 16  | Student Do: InjectManifest                        | 0:15     |
| 9:15PM | 17  | Instructor Review: InjectManifest                 | 0:15     |
| 9:30PM | 18  | END                                               | 0:00     |

> **Important**: If this lesson occurs on a Saturday, make sure to adjust the activities to accommodate for the extra hour of class time. Feel free to take your time as you go through the activities; for example, you can add 5 minutes to the `Student Do` and `Instructor Review` sections as you see fit. Remember to take a 40-minute break at noon!

---

## Class Instruction

### 1. Instructor Do: Stoke Curiosity (10 min)

* Welcome students to class.

* Progressive Web Apps and service workers first appeared in the browser in 2015. However, the concept was first discussed by Steve Jobs in 2007 just 18 days before the first iPhone shipped. At the time, Steve Jobs envisioned a way to create web applications that look and behave like native apps. The idea was to leverage the browser's native APIs to create a web application that could run on any device. We now know that history played out differently with the advent of the app store, but the concept remains relevant today.

* Let's get a glimpse of this moment in history by watching the following video: ["One Last Thing" by Steve Jobs at Worldwide Developer Conference 07'](https://youtu.be/ZlE7dzoD6GA)

* It wasn't until 2015 that Google took that concept and gave it some life. The first Progressive Web App (PWA) specification was introduced at the Chrome Dev summit in 2015. Shortly after, developers started to use the specification to create web applications. Some of the most notable examples of PWAs are Twitter, Uber, and Google Maps, which all tout reduced data consumption of about 70% or more.

* Today, creating a PWA is a lot easier than it was back then, and is usually a lot more cost-effective than developing a mobile application. Google has created an amazing set of tools, called workbox, to help developers create a service worker with minimal effort.

* In today's class, we will learn about the client-server model and focus on one of the key components of PWAs: service workers!

* First, though, we will learn about Hot Module Replacement, an easy-to-use webpack tool that works with webpack's dev server to help speed up development.

### 2. Instructor Demo: Hot Module Replacement (5 min)

* In the terminal, navigate to `11-Ins_Webpack-HMR` and run `npm install` and `npm run dev`. This will install the dependencies, run the development server, and open the `index.html` in the browser.

  * 🔑 Previously when working with webpack, we ran `npm run build` to output our files to a `dist` file and manually opened the `index.html` using Live Server. When we run this application, however, the build is sent directly to the browser! This is because we are using a powerful development tool available with webpack: Hot Module Replacement.

  * 🔑 Hot Module Replacement or HMR is used during development to allow modules to be updated at runtime without the need for a full refresh. This saves development time because we can see our changes as we make them.

  * When we look at the opened app in the browser, we currently see content is being loaded by `module 1` and `module 2`.

* Open `11-Ins_Webpack-HMR/src/js/module1.js` in your IDE to demonstrate the following:

  * 🔑 The `module1.js` file is providing the content to our live page. To test hot reloading is working, let's update the appended HTML so that inside the span element, the text reads: `"THIS IS NEW CONTENT"`.

    ```js
    <div class="article-container">
      <div class="row">
        <div class="col s12">
          <div class="card darken-1">
            <div class="card-content dark-text">
                <span class="card-title">THIS IS NEW CONTENT</span>
            </div>
          </div>
        </div>
      </div>
    </div>
    ```

  * We can then save the `module1.js` file and navigate back to our opened browser page to see the content changed. Sometimes, working with HMR can be tricky, so if this doesn't work for you right away, try refreshing or opening your app in an incognito window to see the new content appear.

* Open `11-Ins_Webpack-HMR/package.json` in your IDE to demonstrate the following:

  * 🔑 To install `webpack-dev-server` as a dev dependency, we use `npm install webpack-dev-server --save-dev`. Once installed, `webpack-dev-server` will appear in the `devDependencies` section of the `package.json` file, as seen below:

    ```js
    "devDependencies": {
      "css-loader": "^6.2.0",
      "html-webpack-plugin": "^5.3.2",
      "style-loader": "^3.2.1",
      "webpack": "^5.53.0",
      "webpack-cli": "^4.8.0",
      "webpack-dev-server": "^4.1.1"
    },
    ```

  * To add Hot Module Reloading to our own webpack app, we need to make sure that the script has been added to our package.json file to start our dev server and open up our app in the browser. We add the `--open` tag so that our app will open up in our browser automatically.

    ```js
    "dev": "webpack-dev-server --open"
    ```

  * Under the hood, in a development environment webpack calls the `webpack-dev-server` dependency when it parses the `devServer` object in the `webpack.config.js` file.

* Open `11-Ins_Webpack-HMR/webpack.config.js` in your IDE to demonstrate the following:

  * Next, in the `config` file we set the mode to `development`. webpack has three modes: `development`, `production` or `none`. By setting the mode, we enable webpack's built-in optimizations that correspond to each environment.

    ```js
    module.exports = {
      mode: 'development',
      entry: {
        index: './src/index.js',
      }
    ```

  * We also add a `devServer` option to our configuration. In our `devServer` object, we have added an attribute of `hot` and set it to `only`. This will reload the module without reloading the entire page.

    ```js
    devServer: {
       hot: 'only',
    },
    ```

* Open `11-Ins_Webpack-HMR/src/index.js` in your IDE to demonstrate the following:

  * 🔑 To accept and react to module updates, we add logic in our `index.js` to check if Hot Module Replacement is enabled and if it is accept and react to the changes. We also add error messaging which will fire if the HMR cannot update.

    ```js
    if (module.hot) {
      module.hot.accept((err) => {
        if (err) {
          console.error('Cannot apply HMR update.', err);
        }
      });
    }
    ```

* Ask the class the following questions (☝️) and call on students for the answers (🙋):

  * ☝️ How would we build this?

  * 🙋 We make sure that `webpack-dev-server` is set up to use Hot Module Replacement by adding a `devServer` object to our webpack config and updating our JavaScript to Webpack to accept and react to the updated module.

* Answer any questions before proceeding to the next activity.

* In preparation for the activity, ask TAs to start directing students to the activity instructions found in `12-Stu_Webpack-HMR/README.md`.

### 3. Student Do: Hot Module Replacement (15 min)

* Direct students to the activity instructions found in `12-Stu_Webpack-HMR/README.md`, which are also shown below.

* Break your students into pairs that will work together on this activity.

  ```md
  # 🏗️ Add Webpack Development Server to a Project Using Hot Module Replacement (HMR)

  Work with a partner to implement the following user story:

  * As a developer, I want to add a `webpack-dev-server` to my project so that I can use Hot Module Replacement (HMR) to update the page without a full page refresh.

  * As a developer, I want to learn how to configure `webpack-dev-server` so that it can test my project in a way that allows my work to continue without much downtime.

  ## Acceptance Criteria

  * It is done when I have installed `webpack-dev-server` as a `devDependency`.

  * It is done when I have a `webpack.config.js` file in my project that includes the `devServer` property.

  * It is done when I have added a `hot` property to the `devServer` object in `webpack.config.js` and set its value to `only`.

  * It is done when I have added a `dev` command to `package.json` that runs `webpack-dev-server --open`.

  * It is done when I have opened `Unsolved/src/js/index.js` and added logic to accept Hot Module Replacement (HMR), as shown in the documentation.

  * It is done when I have opened `Unsolved/src/js/header.js` and updated the code so that the header changes to `orange` instead of `blue` on the button click.

  ## 📝 Notes

  * If you encounter any issues with loading your most recent changes, refresh the page or try again in a private/incognito window. You may have to refresh a few times!

  ## 💡 Hints

  * What other options are available for the `devServer` property?

  ## 🏆 Bonus

  If you have completed this activity, work through the following challenge with your partner to further your knowledge:

  * What is another way to run `webpack-dev-server` without needing to add it to our `package.json` file?

  Use [Google](https://www.google.com) or another search engine to research this.
  ```

* While breaking everyone into groups, be sure to remind students and the rest of the instructional staff that questions on Slack or otherwise are welcome and will be handled. It's a good way for your team to prioritize students who need extra help.

### 4. Instructor Review: Hot Module Replacement (10 min)

* Ask the class the following questions (☝️) and call on students for the answers (🙋):

  * ☝️ How comfortable do you feel with Hot Module Replacement and how it can help us during development? (Poll via Fist to Five, Slack, or Zoom)

* Assure students that we will cover the solution to help solidify their understanding. If questions remain, remind them to use Office Hours to get extra help.

* Use the prompts and talking points (🔑) below to review the following key points:

  * ✔️ `webpack-dev-server`

  * ✔️ `hot: 'only'`

  * ✔️ `module.hot.accept()`

* Open `12-Stu_Webpack-HMR/Solved/package.json` in your IDE and explain the following:

  * To use Hot Module Replacement, we first have to install `webpack-dev-server` as a development dependency. Once installed, it will appear as part of the `devDependencies` object. This object contains all of the dependencies that we need to run our development server.

    ```json
    "devDependencies": {
      "@babel/core": "^7.16.0",
      "@babel/preset-env": "^7.16.4",
      "babel-loader": "^8.2.3",
      "css-loader": "^6.5.1",
      "html-webpack-plugin": "^5.5.0",
      "mini-css-extract-plugin": "^2.4.5",
      "style-loader": "^3.3.1",
      "webpack": "^5.64.4",
      "webpack-cli": "^4.9.1",
      "webpack-dev-server": "^4.7.2"
    }
    ```

  * 🔑 In our scripts, we've also added a `dev` command to run `webpack-dev-server --open`. This command will run the `webpack-dev-server` and open the project in the browser. Optionally, if you don't want this behavior, you can use `--no-open` to prevent the browser from opening automatically.

    ```json
     "scripts": {
       "test": "echo \"Error: no test specified\" && exit 1",
       "build": "webpack",
       "dev": "webpack-dev-server --open"
    },
    ```

* Open `12-Stu_Webpack-HMR/Solved/webpack.config.js` in your IDE to demonstrate the following:

  * Now that we have our script to start the server and have installed the `webpack-dev-server` package, we add a `devServer` object to our `webpack.config.js` file. This object contains all of the configuration options for our development server, which gets invoked by the `dev` command.

  * 🔑 We add a `hot` property to the `devServer` object in `webpack.config.js` and set its value to `only` so that we can use HMR without a full page refresh, as shown below:

    ```js
    devServer: {
      hot: 'only',
    },
    ```

* Open `12-Stu_Webpack-HMR/Solved/src/index.js` in your IDE to demonstrate the following:

  * 🔑 Even though we have set up HMR, it is by default an opt-in feature. In order to take advantage of it, we need to update the `index.js` file to accept and react to the hot modules.

  * This code is added at the bottom of the `index.js` file, but it can be added anywhere in the file. We first check to see if `module.hot` property is defined. If it is, we accept hot modules by calling `module.hot.accept()` method, as shown in the following `index.js` snippet:

    ```js
    if (module.hot) {
      module.hot.accept((err) => {
        if (err) {
          console.error('Cannot apply HMR update.', err);
        }
      });
    }
    ```

  * We don't need to accept hot modules in every file. All the files that are imported into `index.js` will bubble up and be hot reloaded.

* Navigate to `12-Stu_Webpack-HMR/Solved` in your terminal and run `npm install` and `npm run dev` and demonstrate the following:

  * With the development server running, the page automatically opens in the browser.

* Open `12-Stu_Webpack-HMR/Solved/src/js/header.js` in your IDE to demonstrate the following;

  * In the `header.js` module, we can change the header's color attribute from `blue` to `orange` to see if we can view the changes without having to rebuild the entire app.

    ```js
    export const headerClick = () => {
      const header = document.getElementById('header');
      if (header.style.color === 'orange') {
        header.style.color = 'black';
      } else {
        header.style.color = 'orange';
      }
    };
    ```

  * When we navigate back to the opened app in the browser, we can see the header now changes from black to orange. If it doesn't work, try refreshing the page a few times or testing your app in an incognito window!

* Ask the class the following questions (☝️) and call on students for the answers (🙋):

  * ☝️ Why is knowing how to use Hot Module Replacement helpful when creating a webpack project?

  * 🙋 Using HMR prevents us from having to rebuild the entire project every time we make a change. It also allows us to make changes to the code without having to restart the server.

  * ☝️ What can we do if we don't completely understand this?

  * 🙋 We can refer to supplemental material, read the [Webpack docs on Hot Module Replacement](https://webpack.js.org/guides/hot-module-replacement/#enabling-hmr), and attend Office Hours to ask for help.

* Answer any questions before proceeding to the next activity.

### 5. Instructor Demo: Client-Server Model (5 min)

* Navigate to `13-Ins_Client-Server` in your terminal and run `npm install` and `npm run` to demonstrate the following:

  * When we enter `npm run` we can see a list of all the run scripts including `npm run start:dev`. This script uses an npm module called `concurrently` to start the client and server directories at the same time.

    ```json
    "start:dev": "concurrently \"cd client && npm run build\" \"cd server && npm run server\" "
    ```

  * The concurrently npm package is a great tool that will allow us to easily spin up our own Express.js server and serve up our bundled files in the `dist` folder.

* Navigate to `13-Ins_Client-Server` in your terminal and run `npm run start:dev` to demonstrate the following:

  * When we execute the `npm run start:dev` script, concurrently runs the client app's build script to create a `dist` directory that contains an `index.html`.  Concurrently also starts an Express.js server to serve up our `index.html` and the assets found in the `dist` directory at the same time.

* Open to `localhost:3001/` in your browser to explain the following:

  * Our app is now available at the main route `/` at `localhost:3001`, the route and port assigned by our Express.js server.

  * Using concurrently, instead of manually opening the `index.html` in the dist directory with Live Server like we did in earlier activities or relying on webpack's dev server to serve our build directly to the browser, we can use our own Express server to serve up the bundled app on the `localhost:3001` or whatever port we assign in our `server.js` file.

  * For concurrently to work, however, we have to make some changes to how we organize our app. We will be dividing our app into separate client and server directories, known as the client-server model.

* Open `13-Ins_Client-Server` in your IDE to demonstrate the following:

  * 🔑 When we take a look inside the `13-Ins_Client-Server`, we see that there are two main directories: a client directory and a server directory.

  * The client directory contains the front-end files. In addition, when a `dist` file is generated during a build, it will also be located inside the client directory. Since we have been working with a front-end app, all of our current app files will be located in the client directory.

  * The server directory contains all the files needed to run a simple Express.js server with a route to serve up our bundled app's files in the client's `dist` folder.

  * Both the client directory and server directory are actually separate apps that function together thanks to the package.json in the root folder. This package.json contains our `npm run start:dev` script and the concurrently development dependency that allows the client and server to be spun up at the same time.

  * 🔑 Using the client-server model allows us to separate our front-end code from our back-end code in these two directories. This creates a more modular and reusable codebase and is especially important to understand when we start working with React or other front-end frameworks that use bundlers like webpack!

  * During the next activity, you will check out the client and server directories more on your own.

* Ask the class the following questions (☝️) and call on students for the answers (🙋):

  * ☝️ How would we use the client-server model to modularize our app?

  * 🙋 We would start by modularizing our front-end and back-end into two directories, the client and server folders. Since our app is a front-end app, all of our existing files will go in the client directory. The server directory contains a server and HTML route that allows the `dist/index.html` to be served up easily. Finally, we can start both our client and server apps at the same time using an npm module called `concurrently`.

  * ☝️ Why is it important to understand the client-server model?

  * 🙋 The client-server model is a common way for developers to modularize their app into reusable components. Understanding the client-server model will also give us a head start at understanding React and other front-end frameworks that use bundlers like webpack!

* Answer any questions before proceeding to the next activity.

* In preparation for the activity, ask TAs to start directing students to the activity instructions found in `14-Stu_Client-Server/README.md`.

### 6. Student Do: Client-Server Model (15 min)

* Direct students to the activity instructions found in `14-Stu_Client-Server/README.md`, which are also shown below.

* Break your students into pairs that will work together on this activity.

  ```md
  # 📐 Add Comments to Implementation of Client-Server Model

  Work with a partner to add comments describing the functionality of the code found in [Unsolved/package.json](./Unsolved/package.json), [Unsolved/server/routes/htmlRoutes.js](./Unsolved/server/routes/htmlRoutes.js), and [Unsolved/server/server.js](./Unsolved/server/server.js).

  In addition, in the [Unsolved/client/README.md](./Unsolved/client/README.md) and [Unsolved/server/README.md](./Unsolved/server/README.md), add comments describing the files and directories found in both folders.

  ## 📝 Notes

  Refer to the documentation:

  [NPM docs on concurrently](https://www.npmjs.com/package/concurrently)

  [MDN web docs client-server overview](https://expressjs.com/en/starter/installing.html)

  [Installing Express.js server](https://expressjs.com/en/starter/installing.html)

  [Express.js routing](https://expressjs.com/en/starter/basic-routing.html)

  [Installing Express.js server](https://expressjs.com/en/starter/installing.html)

  ## 🏆 Bonus

  If you have completed this activity, work through the following challenge with your partner to further your knowledge:

  * What is a proxy server?

  Use [Google](https://www.google.com) or another search engine to research this.
  ```

* While breaking everyone into groups, be sure to remind students and the rest of the instructional staff that questions on Slack or otherwise are welcome and will be handled. It's a good way for your team to prioritize students who need extra help.

### 7. Instructor Review: Client-Server Model (15 min)

* Ask the class the following questions (☝️) and call on students for the answers (🙋):

  * ☝️ How comfortable do you feel with the client-server model? (Poll via Fist to Five, Slack, or Zoom)

* Assure students that we will cover the solution to help solidify their understanding. If questions remain, remind them to use Office Hours to get extra help.

* Use the prompts and talking points (🔑) below to review the following key points:

  * ✔️ `concurrently`

  * ✔️ `npm run start:dev`

  * ✔️  `server` directory

  * ✔️  `app.use()`

  * ✔️  `app.get()`

  * ✔️  `client` directory

* Open `14-Stu_Client-Server/Solved/package.json` in your IDE to explain the following:

  * 🔑 To use concurrently, we install it as a dev dependency at the root level so that it can access both the client and server directories.

    ```json
    "devDependencies": {
      "concurrently": "^5.2.0"
    }
    ```

  * 🔑 We also add a script that when executed will navigate into the client directory to run the build script and navigate into the server directory to spin up the Express.js server to serve up our app. Note that order matters here! We first have to run the build and create the `dist` folder before the dist files can be served up by our server!

    ```json
    "start:dev": "concurrently \"cd client && npm run build\" \"cd server && npm run server\" "
    ```

* Open `14-Stu_Client-Server/Solved/server/README.md` in your IDE to explain the following:

  * The server directory holds the server-side application. At the root is the server's `package.json` that contains the dependencies and scripts needed for the server app to run.

  * The `server.js` file is also at the root level. This JavaScript file contains the code needed for our basic Express.js server. At the root level is also a directory containing the logic needed for our HTML route.

* Open `14-Stu_Client-Server/Solved/server/server.js` in your IDE to explain the following:

  * 🔑 The `server.js` file contains a basic Express server that runs on port `3001`.

  * 🔑 To use static files in the entire client's `dist` folder, we add the `app.use()` method. This will make sure all the bundled assets we need for our app to run are available for use!

    ```js
    app.use(express.static('../client/dist'))
    ```

  * We also require our HTML route. For smaller apps, the routes can sometimes also be placed directly in the `server.js` file. In our case, we modularized the code, by giving the HTML route its own file.

    ```js
    require('./routes/htmlRoutes')(app);
    ```

* Open `14-Stu_Client-Server/Solved/server/routes/htmlRoutes.js` in your IDE to explain the following:

  * We access our app through the `index.html` file. Previously, we had to open up the `dist` directory's `index.html` using the Live Server tool. Now, using a simple Express `GET` route, we can match requests to the root route `/` and serve up the `index.html` file in the client's `dist` folder using our own simple server app.

    ```js
    module.exports = (app) =>
      app.get('/', (req, res) =>
        res.sendFile(path.join(__dirname, '../client/dist/index.html'))
      );
    ```

  * Now, when we run the build script to create a `dist` directory and spin up the server, our app will appear in the browser at `localhost:3001/` or `localhost:3001`.

* Navigate to `14-Stu_Client-Server/Solved/client/README.md` in your IDE to explain the following:

  * The client directory holds our front-end app. Since our app is a front-end app, all these files will be found in the client directory.

  * At the root level of the client directory, we typically have the client's package.json that contains the scripts and dependencies needed to run the client app, the `index.html`, and configuration files such as `webpack.config.js`.

  * The `src` folder containing our raw JavaScript, CSS, and image files is also in the client folder.

  * When a build script is executed, the `dist` folder will be found in the client folder.

* Navigate to `14-Stu_Client-Server/Solved/` in your terminal and run `npm install` and `npm run start:dev` to explain the following:

  * When we open up the localhost on the port assigned in our Express server, or `localhost:3001`, we can see our Express server is now serving up the client app!

* Ask the class the following questions (☝️) and call on students for the answers (🙋):

  * ☝️ How does concurrently help us use the client-server model?

  * 🙋 The idea is that we can run both the client and the backend server at the same time when developing, and when it comes time to deploy, we can run the build command for the client, and then the server command for the backend.

  * ☝️ What can we do if we don't completely understand this?

  * 🙋 We can refer to supplemental material, read the [Open-CLI Docs on concurrently](https://github.com/open-cli-tools/concurrently), and attend Office Hours to ask for help.

* Answer any questions before proceeding to the next activity.

### 8. Instructor Demo: Workbox Service Workers (5 min)

* Navigate to `15-Ins_Workbox-Service-Workers` in your terminal, run `npm install` and `npm run dev` to demonstrate the following:

  * 🔑 When we run the application, the first thing you will notice is that unlike the previous activities, this one doesn't use or require webpack. Instead, we see a simple message that our server is running on port `3001`.

  * This demo is a very simple page that contains a card with a title, a description, and an image. It also features a service worker that is running in the background.

  * 🔑 This demo is very similar to other simple Express applications that we have created in the past, with one key distinction. This application uses a service worker written in plain Javascript to cache the application's assets.

  * **Important**: There are two ways to create a service worker. One is to create it manually using the steps found on MDN, and the other is to use the [workbox](https://developers.google.com/web/tools/workbox/modules/workbox-webpack-plugin) plugin. While we will use workbox in the next activity, it is important that we take a look at how to create a service worker manually to understand how it works.

* Open `15-Ins_Workbox-Service-Workers/src/sw.js` in your IDE to demonstrate the following:

  * This is a service worker that runs in the background and caches the assets that we are using. Services respond to different events, much like a button or input field.

  * In the browser, we can navigate to Chrome DevTools and click on the Application tab and see that the service worker is running and what status it is in.

  * There are generally three stages in the service worker life cycle:

    1. Install: When the service worker is installed, it will cache the assets that we are using.

    2. Activate: The phase in which the service worker is activated. This is the phase in which the service worker is ready to handle events.

    3. Claim: The phase when the service worker is claiming the clients that are using it.

  * This particular service worker is also a cache-first strategy, meaning that it will first check to see if the assets are in the cache before trying to fetch them from the network. When we create a service worker, it is important to add logic that defines a caching strategy, as shown below:

    ```js
    self.addEventListener('fetch', (e) =>
      e.respondWith(caches.match(e.request).then((res) => res || fetch(e.request)))
    );
    ```

* Open `15-Ins_Workbox-Service-Workers/src/index.js` in your IDE to demonstrate the following:

  * Typically, all one needs to do in order to register a service worker is check to see if they are supported in the browser, and then use the `navigator.serviceWorker.register()` method to register the worker in the browser, as shown below:

    ```js
    if ('serviceWorker' in navigator) {
      navigator.serviceWorker
        .register('./sw.js')
        .then((register) => console.log(register));
    }
    ```

* Now that we have explored the fundamentals of how to build a service worker, in the next activity you will refer to the docs to build your own service worker using a simple library called workbox.

* Ask the class the following questions (☝️) and call on students for the answers (🙋):

  * ☝️ What do service workers do?

  * 🙋 Service workers are a way to cache assets that are used in the application, and are used to speed up the application's loading time.

* Answer any questions before proceeding to the next activity.

* In preparation for the activity, ask TAs to start directing students to the activity instructions found in `16-Stu_Workbox-Service-Workers/README.md`.

### 9. Student Do: Workbox Service Workers (15 min)

* Direct students to the activity instructions found in `16-Stu_Workbox-Service-Workers/README.md`, which are also shown below.

* Break your students into pairs that will work together on this activity.

  ```md
  # 📖 Use Workbox to Generate a Service Worker

  * As an app user, I want to be able to precache assets and view my app even when offline.

  ## Acceptance Criteria

  * It’s done when logic is added to the `index.js` to register a service worker.

  * It's done when the `webpack.config.js` file is updated to use the GenerateSW class of the workbox webpack plugin.

  * It’s done when the app is started using `npm install` and `npm run start:dev` and a log from GenerateSW appears in the console with a message similar to the following: `“The service worker at service-worker.js will precache 5 URLs, totaling 35.1 kB.”`

  * It’s done when a `service-worker.js` file is generated in the build directory.

  * It’s done when the service worker is active and the app is still visible even when offline.

  ## 📝 Notes

  Refer to the documentation:

  * [Workbox docs on generating a service worker with webpack using GenerateSW](https://developers.google.com/web/tools/workbox/guides/generate-service-worker/webpack)

  * [Workbox docs on GenerateSW](https://developers.google.com/web/tools/workbox/reference-docs/latest/module-workbox-webpack-plugin.GenerateSW)

  * [Simulate offline behavior with Chrome DevTools](https://developers.google.com/web/ilt/pwa/tools-for-pwa-developers#simulate_offline_behavior)
  )

  * [Interact with service workers with Chrome DevTools](https://developers.google.com/web/ilt/pwa/tools-for-pwa-developers#interact_with_service_workers_in_the_browser)

  ## 💡 Hints

  * How can we use Chrome DevTools to test if our service worker is active and our app is still visible even when offline?

  ## 🏆 Bonus

  If you have completed this activity, work through the following challenge with your partner to further your knowledge:

  * Why don't JavaScript modules work inside service workers?

  Use [Google](https://www.google.com) or another search engine to research this.
  ```

* While breaking everyone into groups, be sure to remind students and the rest of the instructional staff that questions on Slack or otherwise are welcome and will be handled. It's a good way for your team to prioritize students who need extra help.

### 10. BREAK (15 min)

### 11. Instructor Review: Workbox Service Workers (10 min)

* Ask the class the following questions (☝️) and call on students for the answers (🙋):

  * ☝️ How comfortable do you feel with service workers in general? (Poll via Fist to Five, Slack, or Zoom)

* Assure students that we will cover the solution to help solidify their understanding. If questions remain, remind them to use Office Hours to get extra help.

* Use the prompts and talking points (🔑) below to review the following key points:

  * ✔️ `GenerateSW`

  * ✔️ `Workbox()`

* Open `16-Stu_Workbox-Service-Workers/Solved/client/webpack.config.js` in your IDE to demonstrate the following:

  * 🔑 To make workbox generate a service worker when the application is built, we will use the GenerateSW class to generate a pre-built service worker as part of the webpack build process.

  * 🔑 GenerateSW is a method that supports creating a new service worker file as part of the webpack build process.

  * 🔑 To use the GenerateSW class of the workbox webpack plugin, we need to import it and add it to our webpack configuration.

    ```js
    const WorkboxPlugin = require('workbox-webpack-plugin');
    ```

  * 🔑 In our exported object, we add a new entry to the `plugins` array that invokes the GenerateSW class. It is important this plugin is last!

    ```js
    new WorkboxPlugin.GenerateSW()
    ```

  * In terms of webpack configuration, this is all we need to do to generate a service worker.

  * The setup is so much easier than writing a plain JavaScript service worker from scratch in the previous activity. This is the benefit of using workbox, and this is just the beginning of what workbox can do!

* Open `16-Stu_Workbox-Service-Workers/Solved/client/src/js/register-sw.js` in your IDE to demonstrate the following:

  * Much like we did with the plain JavaScript service worker, we still need to register the service worker that gets created by `GenerateSW`.

  * 🔑 To register, we need to check to make sure service workers are supported in the browser. We can then use the window load event to register the service worker. When working with workbox, it is important to check the docs for this code!

    ```js
    export const registerSW = () => {
      // Check that service workers are supported
      if ('serviceWorker' in navigator) {
      // Use the window load event to keep the page load performant
        window.addEventListener('load', () => {
        navigator.serviceWorker.register('/service-worker.js');
       });
      }
    };
    ```

  * Now that we have reviewed the service worker, let's test our application in the browser.

* Navigate to `16-Stu_Workbox-Service-Workers/Solved` in your terminal and run `npm install` and `npm run start:dev`.

  * When we start our app, we see a message similar to this in the console, showing that our service worker is running and our files are being precached.

* Open `localhost:3001` in an incognito browser to demonstrate the following:

    ```text
    “The service worker at service-worker.js will precache 5 URLs, totaling 35.1 kB.”
    ```

* Navigate to `localhost:3001/` in an incognito browser to demonstrate the following:

  * When we open Chrome DevTools, click on the Application tab and select Service Worker, we see our service worker is activated and is running.

* Ask the class the following questions (☝️) and call on students for the answers (🙋):

  * ☝️ What is the difference between using workbox and plain JavaScript service workers?

  * 🙋 The benefit of using workbox is that it is so much easier to understand and use. It's a great way to get started with service workers without having to write a plain JavaScript service worker from scratch.

  * ☝️ What can we do if we don't completely understand this?

  * 🙋 We can refer to supplemental material, read the [Workbox docs on GenerateSW](https://developers.google.com/web/tools/workbox/reference-docs/latest/module-workbox-webpack-plugin.GenerateSW), and attend Office Hours to ask for help.

* Answer any questions before proceeding to the next activity.

### 12. Instructor Demo: Caching Images (5 min)

* Navigate to `17-Ins_Caching-Images` and run `npm install` and `npm run start:dev` to demonstrate the following:

  * In the console, we see a log from GenerateSW indicating that our files have been precached similar to the following:

    ```md
    The service worker at service-worker.js will precache
    [0] 5 URLs, totaling 38.7 kB.
    ```

* Navigate to `localhost:3001` in an incognito window and open DevTools to demonstrate the following:

  * Working with a cache can be tricky especially during development. If you are running into issues, it is a good idea to do a hard refresh by holding down the refresh icon on the left side browser toolbar and clicking on "Empty Cache and Hard Reload" on a Mac or pressing `Ctrl + Shift + r` or `F5` on Windows. This will make sure you are seeing the latest changes to your app!

  * Once we have done a hard refresh, we can navigate to the Applications tab and click on the `Cache Storage` option under `Cache` to see our apps current cache. When we click on the cache, a clickable table of all cache's files should appear on the right.

  * The images will have names that contain a long string of numbers and letters due to the bundling process. To see our cached images and determine which images are cached, we can click on the Preview mode below the table.

  * In our cache table, it looks like we currently have two precached images even though we have four images in our app. To see why, we can click on the `index.html` file in the table and view it in preview mode.

  * In our `index.html`, it seems two of our images are actually external URL links. Remember, when we use GenerateSW only the images that are stored locally and bundled are included in the cache!

  * By default, when we use GenerateSW all images that have been bundled will be automatically precached when the service worker is installing. This is useful when building a simple app. However, this is often not the behavior we want and it may even slow your app's performance down when apps get larger.

  * That is when adding runtime caching strategy will help make your app more performant and give you more control over when images are cached. In the next activity, you will be adding a runtime strategy to an existing app so that images are only saved once they are used on the page. As usual. Don't forget to consult the documents!

* Ask the class the following questions (☝️) and call on students for the answers (🙋):

  * ☝️ What is precaching?

  * 🙋 When the service worker is installing, files are saved to the cache. This is referred to as "precaching". When using the GenerateSW, precaching is the default behavior.

* Answer any questions before proceeding to the next activity.

* In preparation for the activity, ask TAs to start directing students to the activity instructions found in `18-Stu_Caching-Images/README.md`.

### 13. Student Do: Caching Images (15 min)

* Direct students to the activity instructions found in `18-Stu_Caching-Images/README.md`, which are also shown below.

* Break your students into pairs that will work together on this activity.

  ```md
  # 🐛 Images Are Not Using a Runtime Caching Strategy

  Work with a partner to resolve the following issue:

  * As a developer, I want to be able use runtime caching so that my images are cached as they are used and not automatically precached.

  ## Expected Behavior

  Images should not only be cached as they are used and not precached. In addition, the total number of cached images should be limited to 2.

  ## Actual Behavior

  All images are precached when the service worker is loaded.

  ## Steps to Reproduce the Problem

  To reproduce the problem, follow these steps:

  1. Navigate to the `Unsolved` folder and run `npm install` and `npm run start:dev`

  2. Open a new incognito browser tab and navigate to `http://localhost:3001/`.

  3. Open Chrome DevTools, click the Application tab and select Cache Storage to see the precached files. Note: You may need to do hard refresh!

  ## 📝 Notes

  Refer to the documentation:

  [Workbox docs on runtime caching](https://developers.google.com/web/tools/workbox/guides/generate-service-worker/webpack#adding_runtime_caching)

  ## 💡 Hints

  * How can we enable runtime caching when using the GenerateSW class of the workbox webpack plugin?

  ## 🏆 Bonus

  If you have completed this activity, work through the following challenge with your partner to further your knowledge:

  * What is the Cache Storage API? How do we use it?

  Use [Google](https://www.google.com) or another search engine to research this.
  ```

* While breaking everyone into groups, be sure to remind students and the rest of the instructional staff that questions on Slack or otherwise are welcome and will be handled. It's a good way for your team to prioritize students who need extra help.

### 14. Instructor Review: Caching Images (10 min)

* Ask the class the following questions (☝️) and call on students for the answers (🙋):

  * ☝️ How comfortable do you feel with caching images? (Poll via Fist to Five, Slack, or Zoom)

* Assure students that we will cover the solution to help solidify their understanding. If questions remain, remind them to use Office Hours to get extra help.

* Use the prompts and talking points (🔑) below to review the following key points:

  * ✔️ `exclude`

  * ✔️ `runtimeCaching`

  * ✔️ `cacheFirst`

* Open `18-Stu_Caching-Images/Solved/client/webpack.config.js` in your IDE and explain the following:

  * The GenerateSW class precaches all images by default. However, that is often not the behavior that we want, especially when we have many images.

  * Runtime caching allows us to only cache images as we use them. When we use runtime caching, the request is only populated after a request is made for an asset, like an image.

  * To use runtime caching, we need to add parameters to our GenerateSW class in our `webpack.config.js`.

  * First we need to set the property to exclude our images from precaching.

    ```js
     exclude: [/\.(?:png|jpg|jpeg|svg)$/],
    ```

  * 🔑 Then, we enable `runtimeCaching` to match URLs that are images and use the `CacheFirst` strategy, so that the cache is checked for the URL before making a call on the network. The `CacheFirst` strategy is a perfect choice for optimizing repetitive requests, since it only reaches out to the network for "fresh" assets.

  * We also need to add a custom cache name and can select the maximum number of images we want to hold in the cache at one time. This allows us to control the size of our cache.

    ```js
    runtimeCaching: [{
        urlPattern: /\.(?:png|jpg|jpeg|svg)$/,
        handler: 'CacheFirst',
        options: {
          cacheName: 'images',
          expiration: {
            maxEntries: 2,
          },
        },
      }],
    ```

* Navigate to `18-Stu_Caching-Images/Solved/` in your terminal and run `npm install` and `npm run start` to demonstrate the following:

  * When we open `localhost:3001` in an incognito window and navigate to the Application Tab and view the cache storage, we see all our images are no longer precached.

  * When we click on the network tab and then click on the `Change Box Image` in our app, we can see that a network call is being used the first time our images are shown on the browser page.

  * If this doesn't work the first time, don't worry! Caches are notoriously tricky when using `localhost`. Try running a hard refresh to make sure the cache is cleared. Or, if that option fails, you can try changing the port in your `server.js` to a new port you have not yet used such as `3010`. Using these tricks will usually allow you to see the intended behavior!

* Ask the class the following questions (☝️) and call on students for the answers (🙋):

  * ☝️ What is runtime caching?

  * 🙋 When we use a runtime caching strategy, the files are not stored in the cache until they are actually used in the app. For larger apps, a successful runtime caching strategy can help prevent cache bloat and help make your apps perform better.

  * ☝️ What can we do if we don't completely understand this?

  * 🙋 We can refer to supplemental material, read the [Runtime caching with workbox](https://web.dev/runtime-caching-with-workbox/), and attend Office Hours to ask for help.

* Answer any questions before proceeding to the next activity.

### 15. Instructor Demo: InjectManifest (5 min)

> **Important**: The `dist` folder for both of these examples have been pre-generated for you.

* Open `19-Ins_InjectManifest/GenerateSWexample/client/dist/service-worker.js` in your IDE to demonstrate the following:

  * 🔑 When we use the GenerateSW class, a service worker is automatically generated for you in the `dist` folder. This is fine for simple configurations or when you do not want to customize your service worker.

  * However, since the service worker is autogenerated, the options for caching are limited and we cannot use our service worker with other APIs.

  * 🔑 When we need more control over our service worker, we can use another workbox webpack plugin class, InjectManifest.

* Open `19-Ins_InjectManifest/InjectManifestExample/client/src/sw.js` in your IDE to demonstrate the following:

  * Using InjectManifest we can build our own custom service worker with more advanced scripts and caching strategies and place the file in our `src` directory.

* Open `19-Ins_InjectManifest/InjectManifestExample/client/dist/service-worker.js` in your IDE to demonstrate the following:

  * When the build script is executed, InjectManifest creates a list -- or manifest -- of URLs that are to be precached and injects them into your existing service worker. This can appear as a separate file in your `dist` directory or injected directly into the bundled, custom service worker file.

    ```js
    /**
    * The precacheAndRoute() method efficiently caches and responds to
    * requests for URLs in the manifest.
    * See https://goo.gl/S9QRab.com
    */

    workbox.precacheAndRoute([{
      "url": "80551ea7ee802057b7d8.png",
      "revision": null
    }, {
      "url": "bundle.js",
      "revision": "5769c1b7478f9595223c2626a48d66b3"
    }, {
      "url": "fc083abf258238e3b7f5.png",
      "revision": null
    }, {
      "url": "index.html",
      "revision": "8e97463e73cce4383fab046b0911645f"
    }, {
      "url": "main.css",
      "revision": "985f2d9b63b6a02489442a56cbd104c8"
    }], {});
    ```

* Open `19-Ins_InjectManifest/InjectManifestExample/client/dist/sw.js` in your IDE to demonstrate the following:

  * When we use InjectManifest, our custom service worker including any specific configurations we need is bundled but otherwise unchanged. This allows us to add the custom scripts -- and control -- we need to our service worker.

* Ask the class the following questions (☝️) and call on students for the answers (🙋):

  * ☝️ Why would we choose to use the InjectManifest class over GenerateSW?

  * 🙋 When we want to quickly generate a service worker and don't need service workers with other API's, GenerateSW is a great and easier choice. However for more complex configurations, or when you need to interact with an API like WebPush, InjectManifest is a better option because it allows us far more choices to customize how our service worker behaves.

* Answer any questions before proceeding to the next activity.

* In preparation for the activity, ask TAs to start directing students to the activity instructions found in `20-Stu_InjectManifest/README.md`.

### 16. Student Do: InjectManifest (15 min)

* Direct students to the activity instructions found in `20-Stu_InjectManifest/README.md`, which are also shown below.

* Break your students into pairs that will work together on this activity.

  ```md
  # 📖 Implement InjectManifest to Generate a List of URLs to Add to Existing Service Worker

  Work with a partner to implement the following user story:

  * As a developer, I want to generate a list of URLs to precache and add that precache manifest to an existing service worker file.

  ## Acceptance Criteria

  * It is done when I have imported `injectManifest` class from the `workbox-webpack-plugin` inside the `webpack.config.js` file.

  * It is done when I have registered a new Workbox service worker inside the `src/index.js` file using the `Workbox` constructor.

  * It is done when I have added a new `InjectManifest` plugin to the `plugins` array in `webpack.config.js`.

  * It is done when I have specified the `swSrc` properties in the `InjectManifest` constructor in the `plugins` array in `webpack.config.js`.

  ## 📝 Notes

  Refer to the documentation:

  * [Workbox docs on InjectManifest](https://developers.google.com/web/tools/workbox/modules/workbox-webpack-plugin#injectmanifest_plugin)

  ## 💡 Hints

  * What is the difference between the `GenerateSW` and `InjectManifest` class?

  * What are some different methods of matching files that we want to cache? How can we use the `destination` property on the `request` object to our advantage?

  ## 🏆 Bonus

  If you have completed this activity, work through the following challenge with your partner to further your knowledge:

  * What are some different methods of matching files that we want to cache? How can we use the `destination` property on the `request` object to our advantage?

  Use [Google](https://www.google.com) or another search engine to research this.
  ```

* While breaking everyone into groups, be sure to remind students and the rest of the instructional staff that questions on Slack or otherwise are welcome and will be handled. It's a good way for your team to prioritize students who need extra help.

### 17. Instructor Review: InjectManifest (10 min)

* Ask the class the following questions (☝️) and call on students for the answers (🙋):

  * ☝️ How comfortable do you feel with using InjectManifest? (Poll via Fist to Five, Slack, or Zoom)

* Assure students that we will cover the solution to help solidify their understanding. If questions remain, remind them to use Office Hours to get extra help.

* Use the prompts and talking points (🔑) below to review the following key points:

  * ✔️ `InjectManifest`

  * ✔️ `swSrc`

* Open `20-Stu_InjectManifest/Solved/client/src/sw.js` in your IDE and explain the following:

  * When we use GenerateSW, a complete service worker is generated for us. When we use InjectManifest, we start by creating our own service worker in the `src` directory. This file was provided for us, but is a great resource to refer to when you want to build a custom service worker using InjectManifest on your own.

* Open `20-Stu_InjectManifest/Solved/client/webpack.config.js` in your IDE and explain the following:

  * 🔑 In our config file, we require the InjectManifest class of the workbox webpack plugin.

    ```js
    const {InjectManifest} = require('workbox-webpack-plugin');
    ```

  * 🔑 Next, we add InjectManifest last on our list of plugins and make sure to add the service worker source file, or `swSrc`. The `swDest` file provides the the path and filename of the service worker file that is generated during the build.

    ```js
    new InjectManifest({
      swSrc: './src/sw.js',
      swDest: 'service-worker.js',
    }),
    ```

  * Since we have already installed `workbox-webpack-plugin` as a dependency, that is all we need to do to get our service worker up and running.

* Navigate to `20-Stu_InjectManifest/Solved` and run `npm install` and `npm run start:dev`.

  * A log appears in the console indicating with a message similar to the following:

    ```text
    The service worker at sw.js will precache
    7 URLs, totaling 66.9 kB.
    ```

  * When we navigate to Chrome Dev Tools and click on Applications Tab and select Service Workers, we see our service worker is activated.

  * When we click on Cache Storage, we see that our files that have been injected into our existing service worker have been precached.

* Open `20-Stu_InjectManifest/Solved/client/dist/sw.js` in your IDE to demonstrate the following:

  * Except for the addition of the manifest, the existing service worker, as well as any custom configurations, are otherwise unchanged.

* Ask the class the following questions (☝️) and call on students for the answers (🙋):

  * ☝️ How does InjectManifest work differently than GenerateSW?

  * 🙋 GenerateSW offers only a limited number of options. With InjectManifest, we have a number of options to cache assets and can include our own custom scripts and service worker file. In addition, GenerateSW generates an entire service worker during the build process. InjectManifest, in contrast, injects a list of URLS to be cached into an existing service worker.

  * ☝️ What can we do if we don't completely understand this?

  * 🙋 We can refer to supplemental material, read the [Workbox docs on InjectManifest](https://developers.google.com/web/tools/workbox/modules/workbox-webpack-plugin) and attend Office Hours to ask for help.

* Answer any questions before ending the class.

### 18. END (0 min)

How did today’s lesson go? Your feedback is important. Please take 5 minutes to complete this [anonymous survey](https://forms.gle/RfcVyXiMmZQut6aJ6).

---
© 2022 edX Boot Camps LLC. Confidential and Proprietary. All Rights Reserved.
