# 21.2 Part-Time Lesson Plan: Integrating the Front-End

## Overview

This class focuses on using Apollo's client-side library to consume a GraphQL API. React Router is also covered.

## Instructor Notes

* In this lesson, students will complete activities `11-Ins_MERN-Setup` through `20-React-Router`.

* It is highly recommended that prior to class, you go through each demo and activity so that you are familiar with the code and can anticipate issues that students new to the MERN framework and React.js may face.

* In the previous class, students were introduced to MERN's three-layer architecture and learned how to construct a GraphQL API. Encourage students to refer back to that material, as needed, to review these key concepts.

* The `17-Ins_Apollo-Cache` uses Apollo Client Developer Tools to visualize the in-memory cache. If you have not yet done it, install the [Apollo Client Developer Tools extension for Google Chrome](https://chrome.google.com/webstore/detail/apollo-client-developer-t/jdkknkkbebbapilgoeccciglkfbmbnfm?hl=en-US). Once installed, open Chrome DevTools and navigate to the `>>` arrow on the toolbar to see additional tools available. Click on `Apollo` to open the interface.

* For activity `18-Stu_Apollo-Cache`, please point the students to the console to see the error message.

* Today's Stoking Curiosity is intentionally structured to allow students to think about what an API is and how it is used in a full-stack MERN app. Rather than provide a quick answer to the initial question, encourage students to share their observations in their own words and frame their observations in the context of what they are learning. This will help solidify their understanding of this important concept.

* Remind students to do a `git pull` of the class repo and to have today's activities ready and open in VS Code.

* If you are comfortable doing so, live-code the solutions to the activities. If not, just use the solutions provided and follow the prompts and talking points for review.

* Let students know that the Bonus at the end of each activity is not meant to be extra coding practice, but instead is a self-study on topics beyond the scope of this module for those who want to further their knowledge.

## Learning Objectives

By the end of class, students will be able to:

* Explain what an API is and identify an API's role in a MERN app.

* Create a full-stack MERN app for use in both development and production environments.

* Use `useQuery` and `useMutation` Apollo Hooks to fetch and update data.

* Explain what the Apollo Cache is and identify when it needs updating.

* Use React Router to tie a component to a URL route.

## Time Tracker

| Start  | #   | Activity Name                       | Duration |
|---     |---  |---                                  |---       |
| 6:30PM | 1   | Instructor Do: Stoke Curiosity      | 0:10     |
| 6:40PM | 2   | Instructor Demo: MERN Setup         | 0:05     |
| 6:45PM | 3   | Student Do: MERN Setup              | 0:15     |
| 7:00PM | 4   | Instructor Review: MERN Setup       | 0:10     |
| 7:10PM | 5   | Instructor Demo: useQuery           | 0:05     |
| 7:15PM | 6   | Student Do: useQuery                | 0:15     |
| 7:30PM | 7   | Instructor Review: useQuery         | 0:10     |
| 7:40PM | 8   | Instructor Demo: useMutation        | 0:05     |
| 7:45PM | 9   | Student Do: useMutation             | 0:15     |
| 8:00PM | 10  | BREAK                               | 0:15     |
| 8:15PM | 11  | Instructor Review: useMutation      | 0:10     |
| 8:25PM | 12  | Instructor Demo: Apollo Cache       | 0:05     |
| 8:30PM | 13  | Student Do: Apollo Cache            | 0:15     |
| 8:45PM | 14  | Instructor Review: Apollo Cache     | 0:10     |
| 8:55PM | 15  | Instructor Demo: React Router       | 0:05     |
| 9:00PM | 16  | Student Do: React Router            | 0:15     |
| 9:15PM | 17  | Instructor Review: React Router     | 0:15     |
| 9:30PM | 18  | END                                 | 0:00     |

---

## Class Instruction

### 1. Instructor Do: Stoke Curiosity (10 min)

* Welcome students to class.

* Ask the class the following questions (‚òùÔ∏è):

  * ‚òù What exactly is an `API`?

* Encourage students to respond with their own thoughts and observations and let them know they are on the right track.

* Explain that, as developers, it is important to be able to define what an API, or Application Programming Interface, is and how it is used to handle data in the context of our applications.

* To practice, let's take a look at the API we will be using to build our own full-stack MERN apps.

* Navigate to `11-Ins_MERN-Setup` in your command line and run `npm install`, `npm run seed`, and `npm run develop`.

* Open `http://localhost:3001/graphql` to demonstrate the following:

  * An API is the part of the server that responds to data requests and sends responses. When we open the Apollo Sandbox, we can visualize how a GraphQL API performs these tasks.

  * When we click on the `schema` tab, we see a set of instructions. APIs use instructions to define the shape of the data that can be requested and the functions that will be executed when requests are made.

  * We can also make a request for specific data by writing a query. Once a request is made, the API executes the function needed to handle the request. The requested data is then returned as a JSON object:

     ```gql
     query allProfiles {
       profiles {
        _id
        name
        skills
       }
     }
     ```

* Open the [illustration of MERN three-layer architecture in the Module 21 slide deck](https://docs.google.com/presentation/d/15HFGsli3B1UvM8-khsTi7-DjkN1zX8mpLULMn7oGwX4/edit#slide=id.g102fba7df29_0_2442) and explain the following:

  * In a MERN app, requests are sent to the API from the client.

  * The API handles the request, executes a function to retrieve data from a database, and returns a JSON object. The client can then use that returned object to display the results to the user.

* Explain that during today's class, we will focus on the tools needed to integrate a React.js front end to enable it to send requests to a GraphQL API and use the returned JSON object to display data on a page.

* Remind that students while there is a lot to cover today, by the end of the class they will have all the steps needed to start building a full-stack MERN app on their own.

### 2. Instructor Demo: MERN Setup (5 min)

* Navigate to `11-Ins_MERN-Setup` in your command line and run `npm install`, `npm run seed` and `npm run develop`.

* Open `http://localhost:3001/graphql` to demonstrate the following:

  * When we open up the Apollo Sandbox, we see that our API is up and running and ready to receive requests. Yet, there is no front end on this port.

  * üîë In a MERN setup, the front end and back end are separate entities.

* Open `http://localhost:3000` to demonstrate the following:

  * üîë The React.js front end is located on a separate port.

* Open `11-Ins_MERN-Setup/` in your IDE to demonstrate the following:

  * üîë When we look at the structure of our project directory, we see all the code needed to run the front end is contained in the `client` directory and all the code needed to run the back end is contained in the `server` directory.

  * Because they are two separate apps, we need to use two separate terminals to start up each app independently and run them on their own ports.

  * However, in a development environment, using two terminals can be cumbersome. So, to start up both apps simultaneously, we can add a third app located at the root. This will allow us to use just one set of commands -- and a single terminal -- to control both apps.

* Open `11-Ins_MERN-Setup/package.json` in your IDE to demonstrate the following:

  * üîë The root-level `package.json` belongs to this third app. We install `concurrently` as a development dependency at the root level so that we can run multiple commands at the same time during development. The installed dependency appears in `package.json`:

     ```js
     "devDependencies": {
       "concurrently": "^5.1.0"
     }
     ```

  * üîë We then add the scripts needed to start up both apps using a single terminal:

     ```js
      "scripts": {
       "start": "node server/server.js",
       "develop": "concurrently \"cd server && npm run watch\" \"cd client && npm start\"",
       "install": "cd server && npm i && cd ../client && npm i",
       "seed": "cd server && npm run seed",
       "build": "cd client && npm run build"
     }
     ```

* Open `11-Ins_MERN-Setup/client/package.json` in your IDE to demonstrate the following:

  * While in development, we also need a way for our front end to send requests to our back end on a different port.

  * To do this, we will use a proxy to handle requests and update them to include the URL location of our back end.

  * We add a `proxy` field to the client's `package.json` and add the URL of our back end as the value. Now, while in development, requests will be prefixed by `"http://localhost:3001"` to allow them to be received by the API.

     ```json
     "proxy": "http://localhost:3001"`
     ```

* Ask the class the following questions (‚òùÔ∏è) and call on students for the answers (üôã):

  * ‚òùÔ∏è How does our front end and back end communicate when running on separate ports?

  * üôã In the client directory's `package.json` we add a proxy that identifies the port where the server is running. This allows the front end (or client) to send requests to the API, which is the back end (or the server).  We can then use the npm package `concurrently` to start up both the front end and back end during development, using `npm run develop`.

* Answer any questions before proceeding to the next activity.

* In preparation for the activity, ask TAs to start directing students to the activity instructions found in `12-Stu_MERN-Setup/README.md`.

### 3. Student Do: MERN Setup (15 min)

* Direct students to the activity instructions found in `12-Stu_MERN-Setup/README.md`.

* Break your students into pairs that will work together on this activity.

    ```md
    # üìê Add Comments to Implementation of the MERN-stack Architecture

    Work with a partner to add comments in the [Unsolved README.md file](./Unsolved/README.md) describing the functionality of the code found in [package.json](./Unsolved/package.json), [client/package.json](./Unsolved/client/package.json), and [server/server.js](./Unsolved/server/server.js).

    ## üìù Notes

    Refer to the documentation:

    [Create React App Docs on proxying API requests](https://create-react-app.dev/docs/proxying-api-requests-in-development)

    ---

    ## üèÜ Bonus

    If you have completed this activity, work through the following challenge with your partner to further your knowledge:

    * What GitHub tool can we use to automate functionality such as running tests or deploying our applications?

    Use [Google](https://www.google.com) or another search engine to research this.
    ```

* While breaking everyone into groups, be sure to remind students and the rest of the instructional staff that questions on Slack or otherwise are welcome and will be addressed. It's a good way for your team to prioritize students who need extra help.

### 4. Instructor Review: MERN Setup (10 min)

* Ask the class the following questions (‚òùÔ∏è) and call on students for the answers (üôã):

  * ‚òùÔ∏è How comfortable do you feel with the implementation of MERN-stack architecture? (Poll via Fist to Five, Slack, or Zoom)

* Assure students that we will cover the solution to help solidify their understanding. If questions remain, remind them to use office hours to get extra help.

* Use the prompts and talking points (üîë) below to review the following key points:

  * ‚úîÔ∏è `"proxy": "http://localhost:3001"`

  * ‚úîÔ∏è `concurrently`

  * ‚úîÔ∏è `install`

  * ‚úîÔ∏è `seed`

  * ‚úîÔ∏è `develop`

  * ‚úîÔ∏è `../client/build'`

* Open `12-Stu_MERN-Setup/Solved/client/package.json` in your IDE and explain the following:

  * The `client` directory contains all the code needed to run our React.js front end.

  * üîë We check the proxy to the client's `package.json` to identify the port where the server will run. The proxy directs requests to the API and will allow our front end and back end to communicate:

     ```json
     "proxy": "http://localhost:3001"
     ```

* Open `12-Stu_MERN-Setup/Solved/package.json` in your IDE and explain the following:

  * At the root of our project folder, we have a third app that contains a `package.json`.

  * This `package.json` contains scripts that allow us to easily start up our `client` and `server` apps in a single set of terminal commands while in development.

  * üîë  When we enter `npm install` into the terminal, npm will execute the terminal commands defined in the `install` script, installing the dependencies in both the `client` and `server` directories:

     ```json
     "install": "cd server && npm i && cd ../client && npm i"
     ```

  * üîë We also add a script to execute the terminal commands to seed our database:

     ```json
     "seed": "cd server && npm run seed"
     ```

  * üîë To run our `client` and `server` simultaneously, we first install `concurrently` as a development dependency at the root-level:

     ```json
     "devDependencies": {
       "concurrently": "^5.1.0"
     }
     ```

  * üîë We then use `concurrently` in our `develop` script to execute the commands to start up the `client` and `server` simultaneously by simply entering `npm run develop`:

     ```json
     "develop": "concurrently \"cd server && npm run watch\" \"cd client && npm start\""
     ```

* Open `12-Stu_MERN-Setup/Solved/server/server.js` in your IDE and explain the following:

  * When we are ready to deploy our app, we will create a production build of our React.js front end and set the Express.js server to serve the `build` directory. This will allow our front end and back end to operate from the same port when in production:

     ```js
     if (process.env.NODE_ENV === 'production') {
      app.use(express.static(path.join(__dirname, '../client/build')));
     }

     app.get('*', (req, res) => {
      res.sendFile(path.join(__dirname, '../client/build/index.html'));
     });
     ```

* Ask the class the following questions (‚òùÔ∏è) and call on students for the answers (üôã):

  * ‚òùÔ∏è How can we use this boilerplate app when developing our own MERN full-stack apps?

  * üôã This app has the code needed to connect our front end and back end in both development and production for any MERN app. This makes it a great resource to refer to when building our own MERN apps.

  * ‚òùÔ∏è What can we do if we don't completely understand this?

  * üôã We can refer to supplemental material, read the [Create React App docs on proxying API requests](https://create-react-app.dev/docs/proxying-api-requests-in-development), and stay for office hours to ask for help.

* Answer any questions before proceeding to the next activity.

### 5. Instructor Demo: useQuery (5 min)

* Navigate to `13-Ins_useQuery` in your command line and run `npm install`, `npm run seed` and `npm run develop`.

* Open `http://localhost:3000` to demonstrate the following:

  * When we seed our database and open the app, we see a roster of friends and their endorsed skills.

  * Each time this page loads, the client sends a request to the API. The returned data is then displayed on the page, allowing us to see the roster.

* Open `13-Ins_useQuery/client/src/App.js` in your IDE and demonstrate the following:

  * To set up our React.js front end to be able to send requests, we need to use one more tool.

  * üîë Apollo Client is a library that allows us to handle data using the GraphQL on the front end.

  * üîë We first install `@apollo/client` and import the component and classes we need for setup:

     ```js
     import { ApolloClient, InMemoryCache, ApolloProvider } from '@apollo/client';
     ```

  * üîë Next, we create a new instance of the imported `ApolloClient` class to implement the core client-side API and provide the uri of our GraphQL API so we can send requests. We also create a new instance of `InMemoryCache` to enable caching:

     ```js
     const client = new ApolloClient({
       uri: '/graphql',
       cache: new InMemoryCache()
     });
     ```

  * üîë To access the `ApolloClient` instance from anywhere in your component tree, we use the `ApolloProvider` component to wrap our React.js app:

     ```js
     <ApolloProvider client={client}>
       <div className="flex-column justify-flex-start min-100-vh">
         <Header />
         <div className="container">
           <Home />
         </div>
         <Footer />
       </div>
     </ApolloProvider>
     ```

  * Now, our Apollo Client is set up and we are ready to write a query and start sending requests.

* Open `13-Ins_useQuery/client/src/utils/queries,js` in your IDE and demonstrate the following:

  * üîë We write a query that uses the `profile` entry point and return values for the `_id`, `name`, and `skills` fields. It is important that these values match a type defined in our GraphQL API schema exactly. Otherwise, the query will not work:

     ```js
     query allProfiles {
       profiles {
         _id
         name
         skills
       }
     }
     ```

  * üîë For our query to execute, it must be contained in a `gql` function. We import the functionality from `apollo/client` at the top of the page:

     ```js
     import { gql } from '@apollo/client';
     ```

  * üîë Next, we wrap our query in the `gql` function and add `export` so we can use our query in our component:

     ```js
     export const QUERY_PROFILES = gql`
       query allProfiles {
         profiles {
           _id
           name
          skills
         }
       }
     `;
     ```

* üîë Open `13-Ins_useQuery/client/src/pages/Home.js` in your IDE and demonstrate the following:

  * We import the query into the component where we want our data to be displayed:

     ```js
     import { QUERY_PROFILES } from '../utils/queries';
     ```

  * üîë We also import the `useQuery` Hook from `apollo/client` to return our data:

     ```js
     import { useQuery } from '@apollo/client';
     ```

  * We use the `useQuery` Hook to execute the query when the page renders. The returned object will contain both `loading` and `data` properties:

     ```js
     const { loading, data } = useQuery(QUERY_PROFILES);
     ```

  * We can then store the returned data in a variable so we can display the information on our page:

     ```js
     const profiles = data?.profiles || [];
     ...

     <ProfileList
       profiles={profiles}
       title="Here's the current roster of friends..."
     />
     ```

* Ask the class the following questions (‚òùÔ∏è) and call on students for the answers (üôã):

  * ‚òùÔ∏è What is Apollo Client?

  * üôã  Apollo Client is a powerful library allows us to request data from our API and handles the whole request cycle.

  * ‚òùÔ∏è What can we do with Apollo Client?

  * üôã  Using Apollo Client, we can easily execute a query and use the returned data to populate our page in a few lines of code.

* Answer any questions before proceeding to the next activity.

* In preparation for the activity, ask TAs to start directing students to the activity instructions found in `14-Stu_useQuery/README.md`.

### 6. Student Do: useQuery (15 min)

* Direct students to the activity instructions found in `14-Stu_useQuery/README.md`.

* Break your students into pairs that will work together on this activity.

   ```md
   # üèóÔ∏è Implement Query to Retrieve Thought Data

   Work with a partner to implement the following user story:

   * As a user, when I visit the application's homepage, I am shown a list of thoughts.

  ## Acceptance Criteria

   The activity is complete when it meets the following criteria:

   * The application's homepage displays all thought data queried from the API in a list.

   * The homepage renders a loading screen when the thought data has not returned from the API yet.

   ## Assets

   The following image demonstrates the web application's appearance and functionality:

   ![The Tech Thoughts homepage displays a list of thoughts, who wrote them, and when they were created.](./Images/01-screenshot.png)

   ---

   ## üí° Hints

   * Where can a query be created to be used anywhere in our application?

   * What properties returned from `useQuery()` can be used to determine if the request hasn't completed yet?

   * How can we seed the database so there's data to query?

   ## üèÜ Bonus

   If you have completed this activity, work through the following challenge with your partner to further your knowledge:

   * What React API is the Apollo Client provider functionality built with?

   Use [Google](https://www.google.com) or another search engine to research this.
   ```

* While breaking everyone into groups, be sure to remind students and the rest of the instructional staff that questions on Slack or otherwise are welcome and will be addressed. It's a good way for your team to prioritize students who need extra help.

### 7. Instructor Review: useQuery (10 min)

* Ask the class the following questions (‚òùÔ∏è) and call on students for the answers (üôã):

  * ‚òùÔ∏è How comfortable do you feel with using the `useQuery` Hook? (Poll via Fist to Five, Slack, or Zoom)

* Assure students that we will cover the solution to help solidify their understanding. If questions remain, remind them to use office hours to get extra help.

* Use the prompts and talking points (üîë) below to review the following key points:

  * ‚úîÔ∏è `gql`

  * ‚úîÔ∏è `import { useQuery }`

  * ‚úîÔ∏è `import { QUERY_THOUGHTS }`

  * ‚úîÔ∏è `useQuery(QUERY_THOUGHTS)`

* Open `14-Stu_useQuery/client/src/App.js` in your IDE and explain the following:

  * To send requests, we first have to set up Apollo Client in our `App.js` file and create a new `ApolloClient` instance that identifies the URL of our GraphQL server. This step has already been done for us:

     ```js
     const client = new ApolloClient({
       uri: '/graphql',
       cache: new InMemoryCache(),
     });
     ```

* Open `14-Stu_useQuery/client/src/utils/queries.js` in your IDE and explain the following:

  * The app is running and ready to make requests. Let's create a new query.

  * üîë We start by using the entry point `thoughts` and add the fields we want to access. It is important to refer to the schema so that the names match a defined type exactly:

     ```js
     query getThoughts {
       thoughts {
         _id
         thoughtText
         thoughtAuthor
         createdAt
       }
     }
     ```

  * üîë We then wrap our completed query in a `gql` function and export it:

     ```js
     export const QUERY_THOUGHTS = gql`
       query getThoughts {
       thoughts {
         _id
         thoughtText
         thoughtAuthor
         createdAt
       }
     }
     `;
     ```

* Open `14-Stu_useQuery/client/src/pages/Home.js` in your IDE and explain the following:

  * üîë To use our query, we start by importing the `useQuery` Hook and the query into the component where we want the data to be displayed:

     ```js
     import { useQuery } from '@apollo/client';
     import { QUERY_THOUGHTS } from '../utils/queries';
     ```

  * üîë We then use the `useQuery` Hook to execute the query and return a JSON object that contains loading information and the requested data:

     ```js
     const { loading, data } = useQuery(QUERY_THOUGHTS);
     ```

  * üîë If data is returned, we store the returned data in a variable. If no data is available, we use an empty array instead:

     ```js
     const thoughts = data?.thoughts || [];
     ```

  * üîë We use the variable to access the data in our JSX so the data can be displayed on our page:

     ```js
     <ThoughtList
       thoughts={thoughts}
       title="Some Feed for Thought(s)..."
     />
     ```

* Ask the class the following questions (‚òùÔ∏è) and call on students for the answers (üôã):

  * ‚òùÔ∏è How do we use the `useQuery` Hook to return data?

  * üôã The `useQuery` Hook takes in a GraphQL query wrapped in a `gql` function and returns the requested data as a JSON object. We can then use that data object to display information on the page.

  * ‚òùÔ∏è What can we do if we don't completely understand this?

  * üôã We can refer to supplemental material, read the [Apollo Docs on queries](https://www.apollographql.com/docs/react/data/queries/), and stay for office hours to ask for help.

* Answer any questions before proceeding to the next activity.

### 8. Instructor Demo: useMutation (5 min)

* Navigate to `15-Ins_useMutation` in your command line and run `npm install`, `npm run seed` and `npm run develop`.

* Open `http://localhost:3000` to demonstrate the following:

  * üîë When we enter a name into the text box and submit the form, a new profile containing the name we entered is created and the profile is displayed on the page.

  * üîë To create and modify data, we use mutations. This allows us to have a full CRUD app.

* Open `15-Ins_useMutation/client/src/utils/mutations.js` to demonstrate the following:

  * Setting up a mutation is a lot like setting up a query. First, we set up our front end to send requests using Apollo Client.

  * üîë Then, we write our mutation, making sure our entry point and fields match definitions in our schema exactly and that our variable definition is set. We also define a variable `$name`. This variable will be used to pass back data when our mutation executes:

     ```js
     mutation addProfile($name: String!) {
       addProfile(name: $name) {
         _id
         name
         skills
       }
     }
     ```

  * Finally, we wrap our completed mutation in a `gql` function and export it.

* Open `15-Ins_useMutation/client/src/components/ProfileForm/index.js` to demonstrate the following:

  * üîë In the component where we want to execute the mutation, we import the mutation we created as well as the `useMutation` Hook:

     ```js
     import { useMutation } from '@apollo/client';
     import { ADD_PROFILE } from '../../utils/mutations';
     ```

  * üîë Next, we apply the `useMutation` Hook to return a mutation function that we can use to trigger the mutation as needed:

     ```js
     const [addProfile, { error }] = useMutation(ADD_PROFILE);
     ```

  * Because we want our mutation function to execute when we submit the form, we place it inside the `handleFormSubmit` function:

     ```js
     const { data } = await addProfile({
       variables: { name },
     });
     ```

  * üîë We then assign a value to our mutation variable that represents the name entered by the user:

     ```js
     variables: { name }
     ```

  * We wrap our mutation function in a `try...catch` and add error handling. This will handle any errors gracefully if our request fails:

     ```js
     try {
       const { data } = await addProfile({
         variables: { name },
       });

     } catch (err) {
       console.error(err);
     }
     ```

  * üîë Finally, we add a refresh to allow our page to reload after the mutation is executed. This will stop any cache issues and allow our new profile to be displayed:

      ```js
     window.location.reload();
      ```

* Ask the class the following questions (‚òùÔ∏è) and call on students for the answers (üôã):

  * ‚òùÔ∏è When are mutations executed using `useMutation()`?

  * üôã Mutations are not immediately executed when the page is rendered. Instead, the `useMutation()` Hook returns a mutation function that can be called inside another function. This makes it easy to attach a mutation to an event, like a form submission.

* Answer any questions before proceeding to the next activity.

* In preparation for the activity, ask TAs to start directing students to the activity instructions found in `16-Stu_useMutation/README.md`.

### 9. Student Do: useMutation (15 min)

* Direct students to the activity instructions found in `16-Stu_useMutation/README.md`.

* Break your students into pairs that will work together on this activity.

   ```md
   # üèóÔ∏è Implement Mutation to Create New Thought

   Work with a partner to implement the following user story:

   * As a user, when I submit a new thought, I want that thought to be created and displayed on the page.

   ## Acceptance Criteria

   The activity is complete when the following criteria is met:

   * A thought is added to the database upon form submission.

   * A successful thought submission reloads the page and displays the new thought.

   ---

   ## üí° Hints

   * Where can we define mutations that accept arguments?

   * What information about the mutation's state can we use in our UI?

   ## üèÜ Bonus

   If you have completed this activity, work through the following challenge with your partner to further your knowledge:

   * How can Apollo Client be set up as a state management tool?

   Use [Google](https://www.google.com) or another search engine to research this.
   ```

* While breaking everyone into groups, be sure to remind students and the rest of the instructional staff that questions on Slack or otherwise are welcome and will be addressed. It's a good way for your team to prioritize students who need extra help.

### 10. BREAK (15 min)

### 11. Instructor Review: useMutation (10 min)

* Ask the class the following questions (‚òùÔ∏è) and call on students for the answers (üôã):

  * ‚òùÔ∏è How comfortable do you feel with the `useMutation` Hook? (Poll via Fist to Five, Slack, or Zoom)

* Assure students that we will cover the solution to help solidify their understanding. If questions remain, remind them to use office hours to get extra help.

* Use the prompts and talking points (üîë) below to review the following key points:

  * ‚úîÔ∏è `($thoughtText: String!, $thoughtAuthor: String!)`

  * ‚úîÔ∏è `import { useMutation }`

  * ‚úîÔ∏è `useMutation(ADD_THOUGHT)`

  * ‚úîÔ∏è `const { data } = addThought()`

  * ‚úîÔ∏è `variables: { ...formState }`

* Open `16-Stu_useMutation/Solved/client/src/utils/mutations.js` in your IDE and explain the following:

  * üîë The `ADD-THOUGHT` mutation has two variables `$thoughtText` and `$thoughtAuthor`. We will use these variables to pass back data that is entered by the user:

     ```js
     ($thoughtText: String!, $thoughtAuthor: String!)
     ```

  * To pass our mutation to a component so it can be used by our Hook, we wrap the mutation in a `gql` function and export it. This work has been done for us:

     ```js
     export const ADD_THOUGHT = gql`
       mutation addThought($thoughtText: String!, $thoughtAuthor: String!) {
         addThought(thoughtText: $thoughtText, thoughtAuthor: $thoughtAuthor) {
           _id
           thoughtText
           thoughtAuthor
           createdAt
           comments {
             _id
             commentText
           }
         }
       }
     `;
     ```

* Open `16-Stu_useMutation/Solved/client/src/components/ThoughtForm/index.js` in your IDE and explain the following:

  * üîë In the component where we want use the mutation, we import both the mutation and the `useMutation` Hook:

     ```js
     import { useMutation } from '@apollo/client';
     import { ADD_THOUGHT } from '../../utils/mutations';
     ```

  * üîë Then, we set up our `useMutation` Hook to apply our mutation. We also add error handling:

     ```js
     const [addThought, { error }] = useMutation(ADD_THOUGHT);
     ```

  * üîë The `useMutation` Hook returns a mutation function, `addThought`, that can then be used to execute the function as needed. Because we want it to execute when a form is submitted, we add it to the form submit handler:

     ```js
     const { data } = addThought({
       });
     ```

  * üîë We also set the value of our mutation variables to equal the current value of `thoughtText` and `thoughtAuthor` in our form state to allow use to pass the user-generated values back to our mutation:

     ```js
      variables: { ...formState },
     ```

  * We add a window refresh to reload our page and avoid an error with the cache:

       ```js
       window.location.reload();
       ```

  * Finally, we wrap the function in a `try...catch` to allow graceful error handling:

     ```js
      try {
       const { data } = addThought({
         variables: { ...formState },
       });

       window.location.reload();
       } catch (err) {
         console.error(err);
       }
     };
     ```

* Ask the class the following questions (‚òùÔ∏è) and call on students for the answers (üôã):

  * ‚òùÔ∏è How do we use variables to pass data inputted by the user back to our mutation?

  * üôã When we write a mutation, we define the variable. Then, when the mutation is executed, we assign the variable a value. This value is then passed back to the mutation so that it can be used in the associated function to create, update, or delete data.

  * ‚òùÔ∏è What can we do if we don't completely understand this?

  * üôã We can refer to supplemental material, read the [Apollo Docs on mutations](https://www.apollographql.com/docs/react/data/mutations/), and stay for office hours to ask for help.

* Answer any questions before proceeding to the next activity.

### 12. Instructor Demo: Apollo Cache (5 min)

* Navigate to `17-Ins_Apollo-Cache` in your command line and run `npm install`, `npm run seed`, and `npm run develop`.

* Open `http://localhost:3000` and navigate to Chrome DevTools and open the `Apollo` tool to demonstrate the following:

  * üîë When we add a name and click and submit the form, a mutation executes and a new profile is added to our database.

  * üîë The in-memory cache is updated as well.

* Open `17-Ins_Apollo-Cache/client/src/App.js` in your IDE and demonstrate the following:

  * üîë Apollo Client has an in-memory cache that stores the data from completed requests. To use Apollo's in-memory cache, we first import `InMemoryCache` in our `App.js` file:

      ```js
     import { ApolloClient, InMemoryCache, ApolloProvider } from '@apollo/client';
     ```

  * We then set the cache value in our `client` to a new instance of a `InMemoryCache()` object. We will reference this `cache` object when we want to retrieve data or update the data stored in the cache:

     ```js
     const client = new ApolloClient({
       uri: '/graphql',
       cache: new InMemoryCache(),
     });
     ```

* Open `17-Ins_Apollo-Cache/client/src/components/ProfileForm/index.js` in your IDE and demonstrate the following:

  * When we execute the `useMutation` Hook, the data in our back-end database is updated and an object is returned. In some cases -- like when we create or delete data -- the cache may not update automatically:

  * In those cases, we add an update function as the second argument of our `useMutation` Hook:

     ```js
     const [addProfile, { error }] = useMutation(ADD_PROFILE, {update()})
     ```

  * We add two arguments to the update function: the cache object that represents the Apollo Client cache and a `data` property. The `data` property is set to hold the data returned from the mutation function:

     ```js
     update(cache, { data: { addProfile } })
     ```

  * We then use the web API function `.readQuery()` to retrieve the existing list of profiles in the cache:

     ```js
     const { profiles } = cache.readQuery({ query: QUERY_PROFILES });
     ```

  * Next, we combine the data from the newly executed mutation function with the data we retrieved from the cache and store the results in our `data` property:

     ```js
     data: { profiles: [...profiles, addProfile] }
     ```

  * We use `.writeQuery()` to update the data on the cache and keep the cache in sync with our back end:

     ```js
     cache.writeQuery({
       query: QUERY_PROFILES,
       data: { profiles: [...profiles, addProfile] },
     })
     ```

* Ask the class the following questions (‚òùÔ∏è) and call on students for the answers (üôã):

  * ‚òùÔ∏è How do we use an `update()` function to modify our cache?

  * üôã We pass the update function as the second argument of our `useMutation` Hook. Then, we retrieve the existing data from our cache and combine it with the data generated when our mutation executed and write the new data to our cache.

* Answer any questions before proceeding to the next activity.

* In preparation for the activity, ask TAs to start directing students to the activity instructions found in `18-Stu_Apollo-Cache/README.md`.

### 13. Student Do: Apollo Cache (15 min)

* Direct students to the activity instructions found in `18-Stu_Apollo-Cache/README.md`.

* Break your students into pairs that will work together on this activity.

  ```md
  # üêõ Apollo Client Cache Update Throws an Error

  Work with a partner to resolve the following issue:

  * As a user, when I submit a new thought, I want that thought to be displayed on the page without reloading it.

  ## Expected Behavior

  When as user submits a new thought through the form, the thought should be automatically added to the page without refreshing the page.

  ## Actual Behavior

  When a user submits a new thought through the form, the thought is created but the cache update functionality throws an error in the console and doesn't update correctly.

  ## Steps to Reproduce the Problem

  To reproduce the problem, follow these steps:

  1. Run `npm install` and `npm run develop` from the command line at the root of the application's directory.

  2. Navigate to `http://localhost:3000` in the browser.

  3. Fill out the form at the top of the page and submit the form to see the error.

  ## Assets

  The following image shows the error:

  ![The Chrome Console displays an error after the update cache functionality executes.](./Images/01-screenshot.png)

  ---

  ## üí° Hint

  * Where does the cache update functionality go when executing a mutation?

  ## üèÜ Bonus

  If you have completed this activity, work through the following challenge with your partner to further your knowledge:

  * What is another means of storing data globally client-side that we can implement?

  Use [Google](https://www.google.com) or another search engine to research this.
  ```

* While breaking everyone into groups, be sure to remind students and the rest of the instructional staff that questions on Slack or otherwise are welcome and will be addressed. It's a good way for your team to prioritize students who need extra help.

### 14. Instructor Review: Apollo Cache (10 min)

* Ask the class the following questions (‚òùÔ∏è) and call on students for the answers (üôã):

  * ‚òùÔ∏è How comfortable do you feel with Apollo Cache? (Poll via Fist to Five, Slack, or Zoom)

* Assure students that we will cover the solution to help solidify their understanding. If questions remain, remind them to use office hours to get extra help.

* Use the prompts and talking points (üîë) below to review the following key points:

  * ‚úîÔ∏è `Missing field` error

  * ‚úîÔ∏è `{ data: { addThought } }`

* Open `18-Stu_Apollo-Cache/Solved/client/src/components/ThoughtForm/index.js` in your IDE and explain the following:

  * üîë The update function modifies the data in the cache to match the changes made in the database when a mutation executes. But while the app seems to work, let's check the Console for safety. It looks like we have a few `Missing field '...' while writing result` errors.

  * For the `update()` function to operate without errors, we must pass in two arguments: a cache object and a `data` property that holds the value of data returned from our mutation function. Because our broken code is returning a `Missing field` error, it is likely that one of these is not passing data about our thought correctly.

  * üîë The data is not separate from the `addThought()` mutation data. Instead, the data we want to store IS the mutation data, identified as `addThought()`. This could be causing the bug!

    ```js
     update(cache, data, addThought)
    ```

  * To fix the error, we add the `data` property to the mutation data and give it a value of `{addThought}`. Now the `update()` function has the data -- in the format it needs:

    ```js
    update(cache, { data: { addThought } }) {
    ```

* Ask the class the following questions (‚òùÔ∏è) and call on students for the answers (üôã):

  * ‚òùÔ∏è What two things do we need to pass into the update function?

  * üôã We pass the cache object that represents the Apollo Client cache as well as a data property that holds the data returned when the mutation is executed.

  * ‚òùÔ∏è What can we do if we don't completely understand this?

  * üôã We can refer to supplemental material, read the [Apollo Docs on reading and writing data to the cache](https://www.apollographql.com/docs/react/caching/cache-interaction/), and stay for office hours to ask for help.

* Answer any questions before proceeding to the next activity.

### 15. Instructor Demo: React Router (5 min)

* Navigate to `19-Ins_React-Router` in your command line and run `npm install`, `npm run seed` and `npm run develop`.

* Open `http://localhost:3000` in your browser to demonstrate the following:

  * At this point, we have covered all that is needed so that our front end can send requests to our GraphQL API and handle responses. Congrats, that is a huge step!

  * To make it easy for our user to easily navigate between multiple pages, though, we have a bit more more work to do.

  * When we enter `http://localhost:3000/` in our browser we are directed to the home page.

  * üîë We can also navigate to a new page that contains the information about a single tech friend.

  * üîë The URL has also changed and now includes a `/profile` route followed by an id. We can copy and paste the URL into a new browser window and view the same page and even bookmark it to return to this page later.

* Open `19-Ins_React-Router/client/src/App.js` in your IDE to demonstrate the following:

  * React Router is a library that allows us to easily add navigation and dynamic routing to our apps.

  * üîë To use React Router, we start by importing the `BrowserRouter`, `Routes`, and `Route` components from `react-router-dom`:

    ```js
    import { BrowserRouter as Router, Routes, Route } from 'react-router-dom';
    ```

  * üîë Next, we wrap our `Router` component around our app elements. This allows us to keep track of the location and easily navigate between pages:

    ```js
    <Router>...</Router>
    ```

  * üîë To create a static route, we wrap a `Route` component around the page we want to access and identify the path. Be sure to wrap any `Route` components within a `Routes` component. Note that within the `Route` component we have a `path` as well as an `element`. The `path` signifies the URL and the `element` signifies which component we want the user to see when they hit that path! Now, when we navigate to `http://localhost:3000/`, the `Home` page will display:

    ```js
    <Routes>
      <Route
        path="/">
        element={<Home />}
      />
    </Routes>
    ```

  * üîë To create a dynamic route, we simply add a parameter `:profileId` to our path. For the `profile` page, the URL will change depending on which tech friend's information is being displayed. Note that regardless of if we want to create a static or dynamic route, the `Route` must be within a `Routes` component. The profile pages will now be available at `http://localhost:3000/profiles/<profileId>`:

    ```js
    <Routes>
      <Route
        path="/profiles/:profileId">
        element={<Profile />}
      />
    </Routes>
    ```

* Open `19-Ins_React-Router/client/src/components/ProfileList/index.js` in your IDE to demonstrate the following:

  * üîë Links are a React Router component that allow us to navigate around our app using a hyperlink.

  * To use a link, we first have to import the component:

    ```js
    import { Link } from 'react-router-dom';
    ```

  * üîë Then, we create the link inside the `.map()` function and give it a path to an existing route using `to`. We use `${profile._id}` to assign the route's parameter to the id of our current tech friend:

    ```js
    <Link
      className="btn btn-block btn-squared btn-light text-dark"
        to={`/profiles/${profile._id}`}
     >
       View and endorse their skills.
    </Link>
    ```

* Open `19-Ins_React-Router/client/src/pages/Profile.js` in your IDE to demonstrate the following:

  * When the user clicks on the link inside our app or enters the page's URL in the browser, we want only the associated tech friend's information to display on the page.

  * üîë To do this, we first grab the needed profile id from the URL's parameter using the `useParams()` Hook:

    ```js
    const { profileId } = useParams();
    ```

  * üîë Then, we use that profile id to query our data and return the associated tech friend's information:

    ```js
    const { loading, data } = useQuery(QUERY_SINGLE_PROFILE, {
      variables: { profileId: profileId },
    });
    ```

  * üîë We can then use the returned data to populate the page:

    ```js
    <h2 className="card-header">
      {profile.name}'s friends have endorsed these skills...
    </h2>
    ```

* Ask the class the following questions (‚òùÔ∏è) and call on students for the answers (üôã):

  * ‚òùÔ∏è How do we use React Router to add navigation to our site?

  * üôã React Router is a library that allows us to easily create a route for each page for our app. The route can then be used by either entering the path into a browser window or internally, when a user clicks on a link.

* Answer any questions before proceeding to the next activity.

* In preparation for the activity, ask TAs to start directing students to the activity instructions found in `20-Stu_React-Router/README.md`.

### 16. Student Do: React Router (15 min)

* Direct students to the activity instructions found in `20-Stu_React-Router/README.md`.

* Break your students into pairs that will work together on this activity.

  ```md
  # üèóÔ∏è Implement Single-Thought Page Display

  Work with a partner to implement the following user stories:

  * As a user, I want to view individual thoughts and a list of comments.

  * As a user, I want to be able to bookmark a thought's page so I can come back and read more comments.

  ## Acceptance Criteria

  The activity is complete when the following criteria are met:

  * When I select a thought on the homepage, I am taken to that thought's page to view its comments without reloading the page.

  * When I visit the thought directly in the browser, I am taken to that thought's page to view its comments.

  ## Assets

  The following image demonstrates the web application's appearance and functionality:

  ![The single thought's page displays the thought's information, its list of comments, and a form to add a new comment.](./Images/01-screenshot.png)

  ---

  ## üí° Hints

  * How can the value of the `to` prop in each thought's `<Link>` component help us define our route?

  * How can we define a route with a parameter using React Router?

  * How can the `useParams()` Hook be used to retrieve data to be used in the `useQuery()` Hook?

  ## üèÜ Bonus

  If you have completed this activity, work through the following challenge with your partner to further your knowledge:

  * Which browser API does React Router leverage?

  Use [Google](https://www.google.com) or another search engine to research this.
  ```

* While breaking everyone into groups, be sure to remind students and the rest of the instructional staff that questions on Slack or otherwise are welcome and will be addressed. It's a good way for your team to prioritize students who need extra help.

### 17. Instructor Review: React Router (15 min)

* Ask the class the following questions (‚òùÔ∏è) and call on students for the answers (üôã):

  * ‚òùÔ∏è How comfortable do you feel with React Router? (Poll via Fist to Five, Slack, or Zoom)

* Assure students that we will cover the solution to help solidify their understanding. If questions remain, remind them to use office hours to get extra help.

* Use the prompts and talking points (üîë) below to review the following key points:

  * ‚úîÔ∏è `<Routes>` and `<Route>` components

  * ‚úîÔ∏è `<Link>` component

  * ‚úîÔ∏è `useParams()` hook

* Open `20-Stu_React-Router/client/src/App.js` in your IDE and explain the following:

  * üîë To navigate to the thoughts page, we first must define a route. Because the route is dynamic and will change based on the id of the thought we want to display, we use a `:thoughtID` parameter:

    ```js
    <Routes>
      <Route
        path="/thoughts/:thoughtId"
        element={<SingleThought />}
      />
    </Routes>
    ```

* Open `20-Stu_React-Router/client/src/components/ThoughtList/index.js` in your IDE and explain the following:

  * To access the page from inside our app, we use a link.

  * üîë Inside our map function, we create a link component that uses the route we just created. Then, we assign the value of the `:thoughtId` parameter to be the id of our current thought:

    ```js
    <Link
       className="btn btn-primary btn-block btn-squared"
        to={`/thoughts/${thought._id}`}
    >
    ```

* Open `20-Stu_React-Router/client/src/pages/SingleThought.js` in your IDE and explain the following:

  * Import the react-router-dom:

    ```js
    import { useParams } from "react-router-dom";
    ```

  * üîë To populate the data for the individual thought on our page, we first retrieve the id from the URL's parameter using the `useParams()` Hook:

    ```js
    const { thoughtId } = useParams();
    ```

  * üîë Then, we pass the retrieved id into a query to return the information needed to populate the page:

    ```js
    const { loading, data } = useQuery(QUERY_SINGLE_THOUGHT, {
      variables: { thoughtId: thoughtId },
    });
    ```

  * We can then use the returned data to display information on our page:

    ```js
    <h3 className="card-header bg-dark text-light p-2 m-0">
      {thought.thoughtAuthor} <br />
      <span style={{ fontSize: '1rem' }}>
         had this thought on {thought.createdAt}
      </span>
    </h3>
    ```

* Ask the class the following questions (‚òùÔ∏è) and call on students for the answers (üôã):

  * ‚òùÔ∏è What are two ways we can access a page when we use React Router?

  * üôã We can access the page directly, by entering the URL of the page directly into the browser. If the path uses a variable, a value for the variable must be provided. We can also use a Link component to allow a user to click on a link and be directed to another page.

  * ‚òùÔ∏è What can we do if we don't completely understand this?

  * üôã We can refer to supplemental material, review the [React Router example of URL parameters](https://reactrouter.com/docs/en/v6/getting-started/overview#reading-url-parameters) and the [React Router example of basic routes](https://reactrouter.com/docs/en/v6/getting-started/overview#configuring-routes), and stay for office hours to ask for help.

* Answer any questions before ending the class.

### 18. END (0 min)

How did today‚Äôs lesson go? Your feedback is important. Please take 5 minutes to complete this [anonymous survey](https://forms.gle/RfcVyXiMmZQut6aJ6).

---
¬© 2022 edX Boot Camps LLC. Confidential and Proprietary. All Rights Reserved.
